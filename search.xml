<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[说话]]></title>
    <url>%2F2018%2F03%2F25%2F00079%E8%AF%B4%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[题目就叫说话，也许给人比较歧义的感觉，其实想表达的是如何说话。 当今社会，说话是门艺术，会说话有时候能够事半功倍。至于如何会说话，从简单来说，就是投其所好，说对方爱听的话。有时候，你比较耿直，心直口快，以为自己很真诚，亦或以为对方是自己熟悉或者亲近的人，可以明着说话，而不用顾忌别人的感受，其实，这种情况才是要注意的，不经意间，你有可能伤害的是至亲朋友。所以，说话前三思，或者更极端点，顺着别人说，似乎永远不会犯错。 有个哥哥，他特别会说话，滔滔不绝，而且不令人厌烦。可见能说话，会说话多重要。会说话，就更能拉近人与人之间的距离，尤其在如今的生活工作中，电子科技如此发达，更是如此。不能因为是至亲朋友而放肆，要克制，不能图一时之快。 切忌！！！]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TFRecords读取测试]]></title>
    <url>%2F2018%2F03%2F25%2F00078TFRecords%E8%AF%BB%E5%8F%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[tfBoy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import osimport randomimport numpy as npimport tensorflow as tffrom PIL import Imagefrom tensorflow.contrib import slimfrom tensorflow.contrib.slim.nets import vggtrain_files_path='D://science//data//DogsandCats//train//'records_path='records_data'def create_tfrecord_data(train_files_path='D://science//data//DogsandCats//train//'): dirs=os.listdir(train_files_path) print(len(dirs)) random.shuffle(dirs) print(len(dirs)) for i in range(25): writer=tf.python_io.TFRecordWriter("records_data//cd_%d.tfrecords"% i) spilt_dirs=dirs[i*1000:(i+1)*1000] print(spilt_dirs) print(len(spilt_dirs)) for img_name in spilt_dirs: # print(img_name) s=str.split(img_name,'.') # print(s[0]) if s[0]=='cat': label=0 else: label=1 # print(label) img_path=train_files_path+img_name img=Image.open(img_path) width=img.width height=img.height # img=img.resize((224,224)) img_raw=img.tobytes() example=tf.train.Example( features=tf.train.Features( feature=&#123; "image/label": tf.train.Feature(int64_list=tf.train.Int64List(value=[label])), "image/height": tf.train.Feature(int64_list=tf.train.Int64List(value=[height])), "image/width": tf.train.Feature(int64_list=tf.train.Int64List(value=[width])), "image/encoded": tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw])), &#125; ) ) writer.write(example.SerializeToString()) writer.close()def read_tfrecord_data(): def shuffle_tfrecords_files(): tfrecords_files = os.listdir("records_data//") # print(tfrecords_files) random.shuffle(tfrecords_files) # print(tfrecords_files) for i in range(len(tfrecords_files)): tfrecords_files[i] = "records_data//" + tfrecords_files[i] print(tfrecords_files) return tfrecords_files filename_queue=tf.train.string_input_producer(shuffle_tfrecords_files()) # filename_queue = tf.train.string_input_producer(["records_data//cd_0.tfrecords"]) reader=tf.TFRecordReader() _,serialized=reader.read(filename_queue) features=tf.parse_single_example( serialized=serialized, features=&#123; 'image/label': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'image/encoded': tf.FixedLenFeature(shape=(), dtype=tf.string), 'image/width': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'image/height': tf.FixedLenFeature(shape=(), dtype=tf.int64) &#125; ) label = tf.cast(features['image/label'], tf.int32) label=slim.one_hot_encoding(label,2) width = tf.cast(features['image/width'], tf.int32) height = tf.cast(features['image/height'], tf.int32) record_image = tf.decode_raw(features['image/encoded'], tf.uint8) image=tf.reshape(record_image,[height,width,3]) # tf.summary.image("original image",tf.expand_dims(image,0)) image=tf.image.resize_images(image,[224,224]) tf.summary.image("resized image",tf.expand_dims(image,0)) return image,labelimage,label=read_tfrecord_data()image_batch,label_batch=tf.train.shuffle_batch( [image,label], batch_size=32, capacity=300, min_after_dequeue=100, num_threads=4)x=tf.placeholder(dtype=tf.float32,shape=[None,224,224,3])y_=tf.placeholder(dtype=tf.float32,shape=[None,2])logits,end_points=vgg.vgg_16(x,2,is_training=True)gs=tf.get_collection(tf.GraphKeys.VARIABLES)for var in gs: tf.summary.histogram(var.name,var)loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=logits))acc=tf.reduce_mean(tf.cast(tf.equal(tf.arg_max(logits, dimension=1), tf.arg_max(y_, dimension=1)), tf.float32))train_op = tf.train.GradientDescentOptimizer(0.001).minimize(loss)tf.summary.scalar('loss',loss)tf.summary.scalar('acc',acc)# saver=tf.train.Saver()saver=tf.train.Saver(tf.trainable_variables()[:-2])with tf.Session() as sess: merged = tf.summary.merge_all() summary_writer = tf.summary.FileWriter('image_tensorboard', sess.graph) sess.run(tf.initialize_all_variables()) saver.restore(sess,'D:/science/github/tensorboy/repo_tf/pre_trained/vgg_16.ckpt') coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) for i in range(5000): # print(i) image,label=sess.run([image_batch,label_batch]) # print(label.shape) summary_all,loss_,acc_,_=sess.run([merged,loss,acc,train_op],feed_dict=&#123;x:image,y_:label&#125;) if i%50==0: # print("====") summary_writer.add_summary(summary_all, i) print("Step: %s, Loss: %s, Accuracy: %s"%(i, loss_, acc_)) if i%500==0: saver.save(sess, './image_tensorboard/cd_vgg16', global_step=i) # print(image.shape) coord.request_stop() coord.join(threads) summary_writer.close()]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链]]></title>
    <url>%2F2018%2F03%2F23%2F00077%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[To be Continued!!!]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半监督学习以及GAN的应用]]></title>
    <url>%2F2018%2F03%2F23%2F00076%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8AGAN%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近看了对抗网络，感觉开启了另一扇大门，尤其应用在半监督学习上。举一个例子，在mnist数据集上，只需要200带标签的数据以及其他不带标签的数据(参考资料3)，就能达到监督学习所能达到的准确率，这令人惊叹。 To be continued!!!😂 参考资料 手把手教你用GAN实现半监督学习 (平价数据)GAN用于半监督学习 - CSDN博客 👈👈👈👈 生成对抗网络（GAN）应用于图像分类 - CSDN博客 半监督学习近几年有哪些突破性的进展？尤其是在与深度学习方面 - 知乎 半监督深度学习小结 提高驾驶技术：用GAN去除(爱情)动作片中的马赛克和衣服👈👈 用GAN生成二维样本的小例子 GAN 的发展对于研究通用人工智能有什么意义？ DCGAN、WGAN、WGAN-GP、LSGAN、BEGAN原理总结及对比 GAN学习指南：从原理入门到制作生成Demo 17种GAN变体的Keras实现请收好 | GitHub热门开源代码🌞🌞🌞🌞 GAN入门教程｜从0开始，手把手教你学会最火的神经网络 历史最全GAN网络及其各种变体整理（附论文及代码实现） 通俗理解生成对抗网络GAN ​]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Deep Learning</tag>
        <tag>GAN</tag>
        <tag>Generative Adersarial Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制删除工具Geek Uninstaller]]></title>
    <url>%2F2018%2F03%2F22%2F00072%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%B7%A5%E5%85%B7Geek-Uninstaller%2F</url>
    <content type="text"><![CDATA[介绍一个强力删除windows软件的小工具，只有2M大小。官方网址在此 经测试，QQ拼音输入法还是不能完全删除，这锅得QQ来背。太流氓！！！不过这款软件还是很好用！ 参考资料 2M强力“卸载神器”，从此对流氓软件说“不”]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jackie Chan 成龙]]></title>
    <url>%2F2018%2F03%2F19%2F00075Jackie-Chan-%E6%88%90%E9%BE%99%2F</url>
    <content type="text"><![CDATA[想开篇来聊一聊成龙。 读了这么多书，总想着写东西首先得规划怎么写，采用什么框架写，才不至于流水账形式。 对于成龙来说，看着他的电影长大，喜欢李连杰的飘逸，可惜李连杰老了，再不复当年之勇，光环慢慢退却；而成龙，还时常活跃在视线中，他还是那个能打能给人带来欢乐的影人，虽然偶尔也发现他也是个六十多岁的老头了，但对他的欣赏仍旧没有改变，反倒随着时间的推移，越来越爱。为了了解他，特地去知乎上搜了：如何评价成龙？从众网友的文字中不难发现，大家都很爱成龙，他超越了同时代的其他影人，成为了旗帜，成了龙。 这首歌，是我比较喜欢的大哥的一首歌，歌词平淡，很生活化。其实在众多华语音乐人来说，成龙的标签很明显，这跟他的从师经历有很大的关系。师从京剧名家，京剧表演已经深深烙印在他的灵魂里，无论拍戏还是唱歌，都能发现京剧对他的影响，他很好的把传统与现代结合，独树一帜。 这个B站链接有问题，可以直接点进去观看。 这部电影揭示了成家班的特效制作，作为影人，成龙将成家班做到了专业化，这也是他走出去回来给自己带来的变化。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>成龙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一人之下]]></title>
    <url>%2F2018%2F03%2F16%2F00035%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[国漫崛起时，最近被一部国漫《一人之下》实力圈粉，尤其喜欢剧内的各种方言配音，当然少不了各种人物角色歌曲，下面即是网易云的链接： 诸葛青]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>一人之下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[faster_rcnn训练自己的数据]]></title>
    <url>%2F2018%2F01%2F16%2F00073faster-rcnn%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[女朋友要带回家]]></title>
    <url>%2F2018%2F01%2F14%2F00054%E5%A5%B3%E6%9C%8B%E5%8F%8B%E8%A6%81%E5%B8%A6%E5%9B%9E%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[这是昨晚翻B站突然听到的很老的歌，谭杰希的《女朋友要带回家》，还是一个小女生唱的，以前自己玩尤克里里也唱过，那还是刚学那会，现在这么老，唱这么苏的歌有点不好意思唱了，所以每次尽量选择励志的歌来学习，学了好久，至今还是扫弦君。。。大半夜听这么苏的歌很想拿起吉他啊。。。]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>谭杰希</tag>
        <tag>郑湫泓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNN生成古诗]]></title>
    <url>%2F2018%2F01%2F07%2F00025RNN%E7%94%9F%E6%88%90%E5%8F%A4%E8%AF%97%2F</url>
    <content type="text"><![CDATA[利用RNN生成古诗，看看生成的样子。 隐室令帆出水令，猎人宜道意初干。 鸣波太众岚彩禁，易郭香鸣栈堕风。 风竹出茏寒透匣，碧榛终乱异宫祠。 迷坛金石人难到，骏退多候快逐连。 千里战旗亭万匝，望烟川色耀光辉。 异人不敢传秘著，形骸情无念太平。 参考资料]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>RNN</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于微博图床]]></title>
    <url>%2F2018%2F01%2F06%2F00056%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[今天发现，上传到微博上的照片，即使客户端删除之后，服务器中还保存副本，链接依然有效，所以考虑到安全问题，有关个人信息的图片还是不要上传到微博上。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>微博</tag>
        <tag>WeiBO</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金陵一梦]]></title>
    <url>%2F2018%2F01%2F04%2F00055%E9%87%91%E9%99%B5%E4%B8%80%E6%A2%A6%2F</url>
    <content type="text"><![CDATA[金陵的第十个年头了，这些年没培养什么爱好，但一直想着做这个那个，摄影于是就成了一个遥不可及的梦想，但是没有啥拿得出手的作品，今天又下雪了，本想早早起床，趁着还没有人，拍几张，可。。。 这是上班途中拍的，彭彭说，正面显得太板正了，试着从侧面拍，于是在正面全是单反君的无奈之下，某从侧面一边打着伞，一边拍摄起来。到班上，发给彭彭看，她说还不错，上面这张是经过裁剪加静谧的滤镜之后上传的，再没有其他后期。 望指正。]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晚婚]]></title>
    <url>%2F2017%2F12%2F29%2F00051%E6%99%9A%E5%A9%9A%2F</url>
    <content type="text"><![CDATA[突然听到李宗盛的《晚婚》，感觉比江蕙的更好听，唱出了那种岁月沉淀，饱含沧桑。以前很喜欢李宗盛的歌，基本去KTV必点他的歌，这首歌也让我单曲循环了好久，此刻就在。 大叔说：我从来不想独身，却有预感晚婚。快30的年头，这已经不是预感了。少不听李宗盛，听了他这么多年，越来越觉得他的词不经岁月打磨，很难到这个境界。他唱歌带吟带唱，像独白、诉说，又或低吟。往往令人情不自禁，所以，今天分享这首，听歌的人每个人感受都不一样，歌者需要的就是拨动人的心弦。 岁月如歌，年华残酷。]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
      <tags>
        <tag>李宗盛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摄影笔记手机摄影入门]]></title>
    <url>%2F2017%2F12%2F22%2F00042%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这是摘选自摄影笔记的内容，在自己的博客中留存。 手机摄影入门]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月供是怎么回事]]></title>
    <url>%2F2017%2F12%2F06%2F00002%E8%BD%AC%E6%9C%88%E4%BE%9B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[买房、买车，人生大事，抛开全款，你了解月供几何？ 参考文献 月供是怎么回事？]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转傅立叶白话分析]]></title>
    <url>%2F2017%2F12%2F05%2F00017%E8%BD%AC%E5%82%85%E7%AB%8B%E5%8F%B6%E7%99%BD%E8%AF%9D%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文以简明的语言向读者阐述了傅立叶分析的基本原理，适合入门。 参考文献 傅里叶分析之掐死教程（完整版）更新于2014.06.06]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>傅立叶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转从LeNet到DenseNet]]></title>
    <url>%2F2017%2F12%2F05%2F00018%E8%BD%AC%E4%BB%8ELeNet%E5%88%B0DenseNet%2F</url>
    <content type="text"><![CDATA[本文详细介绍了CNN各网络的发展史，值得一读。 参考文献 从LeNet-5到DenseNet]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京美食记]]></title>
    <url>%2F2017%2F12%2F05%2F00045%E5%8D%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[平时无聊，总想着去哪吃，会看到一些网友推荐，过后再想吃的时候又忘了，所以，特开此文广记南京美食，采取完成任务列表模式，当然，现在一家都没吃过，开篇啦！！！ 正餐 尤广记牛杂王 大蔬无界 泽锅草原牛肉火锅 米桃餐厅 饮品 甜荟 ​]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>美食</tag>
        <tag>南京</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛排常识]]></title>
    <url>%2F2017%2F12%2F04%2F00044%E7%89%9B%E6%8E%92%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[常听别人说起某某某牛排，那么各种牛排的区别是什么，本博文假他人之手娓娓道来。 先来一张我大蔚蓝海岸尼斯柠檬节的神牛镇题 法国人虽然没有西班牙人对牛如此有感情把牛当成国家图腾（法兰西喜欢大公鸡+ +), 但是对于个个吃货的法国来说牛排和牛肉简直就是人生活下去的动力之一。所以在吃牛上法国的讲究都是世界牛肉研究的领头羊。在做牛排这事上还是得看法国人的，所以基本牛肉在牛身上的位置专业单词都是法语基础，英语的单词都是直接引用法语词汇换成英语发音而已。下文有些专业单词我就直接用法语写了。 只是牛排的话小牛肉veau 是最好的牛排食材既兼顾鲜嫩多汁而且肉的弹性也非常完美，但是牛肉的做法十分复杂，根据肉质不同用法也不尽相同。 在硕士一年级修味嗅觉分析的时候专门研究过牛排的口感和味道不同，还写了一篇论文。 把当时的论文用图先放出来，文字的话看完今晚的世界杯翻译过来 : D 世界杯看完了，意大利万岁，我又赢了一顿日本料理 : D 在讨论味道的时候不先讨论牛的品种和产地都是耍流氓，我的论文第一部分就是对各个AOC产地保护的法国牛种的讨论和确定它们各自的特点。 这些都是被欧盟承认的法国产区保护的独特牛种，其中最后一种白色的charolaise 白牛肉质最为鲜美，在广阔的特种牧草放牧长大，并且本身肉质就以肉内血脂细腻出名。是在世界范围内都是很出名不可多得的高大上牛肉。 好漂亮的牛牛，么么嗒 :》 其他的高品质牛肉还有人尽皆知的日本和牛，澳洲牛肉，匈牙利牛肉等等，这些牛肉某些部位脂肪肌肉比例搭配完美直接sashimi 是最好的选择，牛排浪费了。 比如这道法国牛肉名菜：tartare du boeuf。 也是被各种排名文章和传说中的仰望星空派一样放在绝对不要点的外国菜里面，排名还挺高。 有一次在巴黎歌剧院附近的HIPOPOTAMUS 吃饭，旁边两个中国情侣游客看到法国人点的这个，立马眼睛瞪得牛大开始议论：哎呀，妈呀，生肉哎，那个中国人能吃这个呀！话音还没落，服务员就给我上了一道一样的，他俩的表情别说多精彩了 : p 法国的tartare du boeuf 做法不够细腻，牛肉块比较大，主要靠搭配不同的SAUCE来调味。而意大利的做法更加适合想要品尝一下牛肉原味而又不是吃肉老饕的人，用剁碎的牛肉搭配各种香草，味道很好，比更加出名的意大利生牛肉切片CARPACIO 更有肉质风味。（有点像生吃牛肉饺子馅:》) 回到正题讨论牛排的不同部位口感： 一只牛可以吃的部位不要太多，我们得确定牛身上那些部分是可以煎牛排的：从表中我们可以看到3，4，5，7，9,20,21,22,23,24 这几个部位都是用来做煎牛排的，那么这些部位叫什么名字呢？ 部位三entrecôte 是肋排，是最经典的煎牛排部位。 肋排肋排必然是排骨肉啦。 跟猪肉一样，肋排口感不够细腻，但是咬头很好，很咬口，而且不会有含牛筋那种藕断丝连嚼不烂的感觉。 最重要的是肋排一般比较便宜比较大块，饭店里动辄350G 或者500G的大肋排，适合我这种食肉动物。 部位五六七味道相近，但等级不同 部位六就是传说中的菲利（法语filet）牛排，是牛排中最顶级的部位。腰内肉部分牛腰肉（英语tenderloin），最嫩处切出，是牛脊上的肉，形状头大尾小，脂肪含量少，适合三分熟，吸吮甜美的肉汁，肉质鲜嫩，菲力牛排包裹在牛腹腔中，所以肌肉都没运动到，故肌肉纤维不粗。是牛排中单价最高的。 五七两个部分比较复杂，5 faux filet 就是接近于菲利牛排的牛胸脊肉部分，口感与菲利牛排类似，但是鲜嫩度较低，弹性较好和肉质稍稍偏硬但不会让人觉得咀嚼困难。 这两个部分在美国英国等地叫法不同，或者翻译成沙朗牛排或者西冷牛排。沙朗牛排在美国指牛后腰脊柱两侧的肉，肉质细嫩，价格高。其中顶部（top sirloin）的肉质最好，价格最高，一般会标明。 沙朗牛排在英国、香港等地指牛胸脊肉部分，肉质细嫩度次于菲利牛排，售价也较低于菲力牛排，上端部分的西冷牛排较为鲜嫩，售价亦稍高。 filet 菲利是除了小牛肉这种高级食材外做牛排最好最高价的部位，基本都是各个牛排屋的拿手绝活。 二十，二十一两个部位比较相近常常放到一起讨论，这两个部位是牛肉中最少见的部分。基本不会在大的超市里销售，肉店老板会留给识货或相熟的大厨朋友。 ONGLET是膈柱肌肉， 可以做牛排，但是一定要避免过度煎烤。因为肌肉纤维较长，如果全熟会导致牛排过硬难以切割，更别说下口了。 HAMPE 是靠近大腿内侧的腹部肉， 一般情况下不会直接煎成牛排，因为肌肉纤维太长外表看起来都很明显。 但这个部位可以做成最好的steak haché 碎肉牛排，不会因为肉质过软导致剁碎后牛肉失去弹性。碎肉牛排就是一般汉堡包会使用的牛排。是不是高档汉堡就看其中的肉排是不是HAMPE做的就可以了。 这两个部位一般是被认为最接近下水的牛肉，所以不是牛肉老饕根本不会关注这两个部位的口感。 23，24 bavette 是牛的腰腹部细肉， bavette à l’échalote 是一道用小洋葱做的传统法国名菜。 这个部位牛排做法比较奇特，厨师用非常热的手在肉的两端各放几分钟，牛排的内心必须是全生的。因为这个部分筋非常多，如果烤熟就太过难咬。但如果做的适当，可以说是牛身上味道最丰富的一个部位。 24 flanchet是腹肉，相当少见用来做牛排的一个部分。因为作为牛身体脂肪最多的部位，应该说油脂能增加牛排香味。可是此处油脂含量过高，导致牛排煎起来较生会油腻，煎熟又会导致牛排肉质因为煎烤时间过长而过老难以下口，所以通常是做牛排牛肉中最后一个选择。 2 basses cotes 牛上脑 或者翻译成牛眼肉，也是我个人最喜欢的一个部位。 不光是做牛排，就算是中国的传统火锅，牛上脑也是最棒的刷锅肉材！ 肉质绵软细腻，肥瘦相宜，如若切片生吃，可算是慢慢在口中融化的感觉异常美妙。 普罗旺斯的AIX 我住的城市里有一家韩国烧烤，提供匈牙利牛上脑烧烤，每次去朋友们都是烟熏火绕异常热闹，而只有我自己慢慢品味上脑在口中融化纠缠的感觉。每次被人笑话把韩餐吃成日料 : ) 大家下次在高档火锅店确定是内蒙牛肉的上脑薄切片肉可以试试用清淡调料腌制一下，然后生食，享受如同西班牙火腿的如丝织般的性感。 如果用牛上脑做牛排，比较适合的是5成熟。外表的虽然已熟透，但下口没有阻碍感，内部的汁水会浸满过舌，略微甜甜又不腥腻，咀嚼起来丝毫不用力，微微咬动已经满口肉香。有点像吃鲑鱼子寿司挤破鱼子的快感。 而相较于菲利（filet）牛上脑体积比较大，价格并不昂贵，是非常具有性价比的牛排部位。 参考文献 不同部位的牛肉有什么区别，做出的牛排口感有何差异？ - 晨曦的回答 - 知乎]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>牛排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种咖啡种类区别]]></title>
    <url>%2F2017%2F12%2F04%2F00068%E5%90%84%E7%A7%8D%E5%92%96%E5%95%A1%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[平时听说各种咖啡，还有各种区别，听起来头大，在此笔记。]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>咖啡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地编辑markdown工具Typora]]></title>
    <url>%2F2017%2F12%2F04%2F00059%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91markdown%E5%B7%A5%E5%85%B7Typora%2F</url>
    <content type="text"><![CDATA[推荐一个本地编辑markdown的工具，在各平台下都有版本。 官方网址为：Typora]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows绝赞应用]]></title>
    <url>%2F2017%2F12%2F04%2F00019windows%E7%BB%9D%E8%B5%9E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[「Windows 绝赞应用」项目由 @EMLVIRUS 发起，旨在帮用户提供优秀的 Windows 应用以免除繁琐的搜寻工作。我们姑且可以将其理解为一份人工维护的优质 Windows 应用推荐榜单，前往 该项目的 GitBook 页面 即可在线进行阅读和索引。 Windows绝赞应用]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BAT面试1000题系列]]></title>
    <url>%2F2017%2F12%2F04%2F00064BAT%E9%9D%A2%E8%AF%951000%E9%A2%98%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[准备面试的时候可以看看，查漏补缺，不要有偏见之类。 BAT机器学习面试1000题系列（第1~10题） BAT机器学习面试1000题系列（11-20题） BAT机器学习面试1000题系列（21-30题） BAT机器学习面试1000题系列（31-35题） BAT机器学习面试1000题系列（36-40题） BAT机器学习面试1000题系列（41-45题） BAT机器学习面试1000题系列（46-50题） BAT机器学习面试1000题系列（51-55题） BAT机器学习面试1000题系列（56-60题） BAT机器学习面试1000题系列（61-65题） BAT机器学习面试1000题系列（66-70题） BAT机器学习面试1000题系列（71-75题） BAT机器学习面试1000题系列（76-80题） BAT机器学习面试1000题系列（81-85题） BAT机器学习面试1000题系列（86-90题） BAT机器学习面试1000题系列（91-95题） BAT机器学习面试1000题系列（96-100题） BAT机器学习面试1000题系列（101-105题） BAT机器学习面试1000题系列（106-110题） BAT机器学习面试1000题系列（111-115题） BAT机器学习面试1000题系列（116-120题） BAT机器学习面试1000题系列（121-125题） BAT机器学习面试1000题系列（126-130题） BAT机器学习面试1000题系列（131-135题） BAT机器学习面试1000题系列（136-140题） BAT机器学习面试1000题系列（141-145题） BAT机器学习面试1000题系列（146-150题） BAT机器学习面试1000题系列（151-155题） BAT机器学习面试1000题系列（156-160题） BAT机器学习面试1000题系列（161-165题） BAT机器学习面试1000题系列（166-170题） BAT机器学习面试1000题系列（171-175题） BAT机器学习面试1000题系列（176-180题） BAT机器学习面试1000题系列（181-185题）]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一千年以后]]></title>
    <url>%2F2017%2F11%2F26%2F00036%E4%B8%80%E5%8D%83%E5%B9%B4%E4%BB%A5%E5%90%8E%2F</url>
    <content type="text"><![CDATA[感叹养猪家音乐越来越办不下去了，现在基本是企鹅一家独大，好多养猪家的歌曲现在都听不了了，于是悄悄下了企鹅家的QQ音乐，其实现在对企鹅家的东西不是太排斥，尽管年少曾骂过。企鹅家的音乐有个不好的地方，就是我不方便在自己的网页中嵌入代码。不像养猪家那么人性化，比如，我今天听到一千年之后，就想在自己的网页中嵌入这段音乐，可惜只有链接。这时候又念叨养猪家的东西好啊！！！ 越老越怀念以前，可能是单身或者在学校的时间久了，有太多的时间迷茫和感伤，所以就听歌吧！！！ 不知道一年之后的自己是什么样子，也许也许，板凳坐久了总想出去看看，想多了也就看淡了，现在少年老成的词也许已经不合适了，人到中年了哈！！！]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些资料翻译收集]]></title>
    <url>%2F2017%2F11%2F25%2F00034%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E7%BF%BB%E8%AF%91%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[参考资料1.Scikit-Learn 中文文档第一期校验完成，邀请你来参与维护，一起走的更远 | ApacheCN2.3.4.5.]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>tensorflow</tag>
        <tag>scikit-learn</tag>
        <tag>elastic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在python下利用opencv读取图片]]></title>
    <url>%2F2017%2F11%2F23%2F00037%E5%9C%A8python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1234567891011import numpy as npimport cv2img=cv2.imread('filename')print(type(img))#&lt;class 'numpy.ndarray'&gt;cv2.imshow('window_name',img)cv2.waitKey(0)cv2.destroyWindow('window_name') 注意opencv读出来的img格式直接是numpy.ndarray格式，可以用numpy直接操作。 参考资料1不是用opencv读取图像的，可以尝试看看，以供学习。 参考资料1.python 读取并显示图片的两种方法]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10安装django错误集]]></title>
    <url>%2F2017%2F11%2F20%2F00074win10%E5%AE%89%E8%A3%85django%E9%94%99%E8%AF%AF%E9%9B%86%2F</url>
    <content type="text"><![CDATA[在cmd中创建第一个项目吧。 django-admin startproject mysite(千万不要使用django-admin.py startproject mysite这样老是打开django-admin.py文件，仅纪念踩过的坑) cd mysite,运行python manage.py runserver,打开浏览器输入http://127.0.0.1:8000/,下面就开始开发你的网站吧 参考资料1.window10下安装Django]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转PyQt5教程]]></title>
    <url>%2F2017%2F11%2F20%2F00032%E8%BD%ACPyQt5%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[参考资料 PyQt5]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>python</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底卸载VisualStudio]]></title>
    <url>%2F2017%2F11%2F20%2F00067%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVisualStudio%2F</url>
    <content type="text"><![CDATA[有个插件叫TotalUninstaller，启用这个插件就可以完全删除visual studio的版本！在此mark，在我的百度网盘里有留存！ 参考资料 教你彻底卸载Visual Studio 2015]]></content>
      <categories>
        <category>软件工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转：目标检测系列博客]]></title>
    <url>%2F2017%2F11%2F20%2F00031%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[晓雷机器学习笔记 RCNN-将CNN引入目标检测的开山之作 SPPNet-引入空间金字塔池化改进RCNN Fast R-CNN Faster R-CNN 图解YOLO SSD YOLO2 Learning Machine keras版faster-rcnn算法详解(1.RPN计算) keras版faster-rcnn算法详解(2.roi计算及其他) 机器学习随笔 Faster R-CNN 刘航呈 R-CNN学习总结 Fast R-CNN学习总结 Faster R-CNN学习总结]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手做聊天机器人]]></title>
    <url>%2F2017%2F07%2F22%2F00001%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[自己动手做聊天机器人]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RNN资料收集]]></title>
    <url>%2F2017%2F07%2F22%2F00024RNN%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs Recurrent Neural Networks Tutorial, Part 2 – Implementing a RNN with Python, Numpy and Theano Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano 另外WILDML的一些博客： Implementing a Neural Network from Scratch in Python – An Introduction Speeding up your Neural Network with Theano and the GPU Understanding Convolutional Neural Networks for NLP Implementing a CNN for Text Classification in TensorFlow Attention and Memory in Deep Learning and NLP Deep Learning for Chatbots, Part 1 – Introduction Deep Learning for Chatbots, Part 2 – Implementing a Retrieval-Based Model in Tensorflow RNNs in Tensorflow, a Practical Guide and Undocumented Features Learning Reinforcement Learning (with Code, Exercises and Solutions)]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>rnn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装latex]]></title>
    <url>%2F2017%2F07%2F22%2F00066%E5%AE%89%E8%A3%85latex%2F</url>
    <content type="text"><![CDATA[本文主要记录下安装使用latex的两个软件： miktex texmaker 首先安装miktex，然后再安装texmaker。 参考文献 Miktex 2.9+Texmaker 4.4.1安装及中英PDF生成过程]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果我爱你]]></title>
    <url>%2F2017%2F07%2F21%2F00043%E5%A6%82%E6%9E%9C%E6%88%91%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[最近新上的剧《春风十里》的主题曲，最近越来越喜欢周冬雨了。以前不待见这么个演员，从老谋子选角山楂树开始，觉得老谋子怎么选了个这么样的女演员，长得不怎么好看，眼镜如此之小。现如今再看，真为当时的自己感到羞愧，如此以貌取人。近段时间，从《七月与安生》到《喜欢你》，本来我不喜欢的电影，愣是凭着周冬雨的戏让我坚持看了下来，从此开始喜欢上这个有点神经再细看又如此美丽的演员。新剧《春风十里》估计符合她这几部剧一贯的风格，调皮、青涩、生动，只她演过的那几部戏，就深深吸引了我。这是她和张一山为《春风十里》而唱的主题曲，尽管唱功不是那么完美，但是由这两人唱出来平添了许多的韵味，有初恋的那种单纯，有春风化雨的细腻，有怦然心跳的悸动。如果我爱你……]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
      <tags>
        <tag>周冬雨</tag>
        <tag>张一山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab常用函数及技巧]]></title>
    <url>%2F2017%2F07%2F17%2F00063Matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%8A%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文记录常用matlab函数以及技巧，不定时更新。 regexpTBD strrepTBD imwriteimwrite(参数变量,’保存名称.保存格式’); 如果参数变量是double类型的，在保存的时候切记将参数变量除以参数变量的动态范围以归一化到[0,1]，这样才能正确保存为bmp或者jpg等格式。 var/cov方差/协方差 dirdir(路径); 遍历变量路径下的文件和文件夹 isdir判断dir得到的struct是否是文件夹 fread/fopen/fclose12345678fid = fopen(路径);if fid &gt; 0 data = fread(fid,[高 宽],存储格式); fclose(fid);else error('文件未能打开');end fullfile1234fullfile(变量1,变量2,变量3,变量4);&gt; &gt; 变量1/变量2/变量3/变量4 strcat1234strcat(变量1,变量2,变量3,变量4);&gt; &gt; 变量1变量2变量3变量4 num2str123456num2str(变量,'%04d') % 整数补充到4位，不足前面加零num2str(2,'%04d')&gt; &gt; 0002 ginput12[x y] = ginput(2); % 手动在图上选取2个点 corr计算矩阵列向量相关系数函数 movefile/copyfile移动文件/复制文件 参考文献 matlab imwrite 保存图像详解 方差var、协方差cov、协方差矩阵（浅谈）-（一） 方差var、协方差cov、协方差矩阵（浅谈）-（二）_函数var 方差var、协方差cov、协方差矩阵（浅谈）（三）_函数cov]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf生成c++代码详解(初稿)]]></title>
    <url>%2F2017%2F07%2F13%2F00065protobuf%E7%94%9F%E6%88%90cplusplus%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文翻译自C++ Generated Code 本文描述了protocol缓冲编译器为指定的protocol定义生成的C++代码。proto2和proto3生成代码之间的任何区别都会突出显示。请注意，这些差异在生成代码中，而不在base classes/interfaces，这两个版本的base classes/interfaces都相同。在阅读本文档之前，您应该阅读proto2语言指南和/或proto3语言指南。 Compiler Invocationprotocol缓冲区编译器在使用--cpp_out=命令行时生成C++输出。该--cpp_out=选项的参数是编译器生成C++代码输出的目录。编译器为每个.proto文件输入创建头文件和实现文件。输出文件的名称通过获取.proto文件的名称并进行两次更改来实现： 源文件扩展名.proto被替换为.pb.h或.pb.cc，即为头或实现文件。 proto路径（用--proto_path=或-I命令行标志指定）被输出路径（用--cpp_out=标志指定）替换。 假设你调用编译器如下： 1protoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto 编译器将读取这些文件src/foo.proto和src/bar/baz.proto，产生四个输出文件：build/gen/foo.pb.h，build/gen/foo.pb.cc，build/gen/bar/baz.pb.h，build/gen/bar/baz.pb.cc。编译器根据需要自动创建目录将build/gen/bar，但不会创建build或build/gen，它们必须已经存在（即需要自己创建）。 Packages如果.proto文件包含一个package声明，则文件的全部内容将被放置在相应的C++命名空间中。例如，给出package声明： 1package foo.bar; 文件中的所有声明将在foo::bar命名空间中。 Messages给出一个简单的消息声明：1message Foo &#123;&#125; protocol缓冲区编译器生成一个由google::protobuf::Message公开派生的类Foo。这个类是一个具体的类，没有纯虚函数等待实现。根据优化模式，Message中的虚函数但不是纯虚函数可以被Foo覆盖也可以不被覆盖。默认情况下，Foo以最大速度实现所有函数的专门版本。但是，如果.proto文件包含该行： 1option optimize_for = CODE_SIZE; 那么Foo将仅覆盖功能所需的最小的一组方法，并依赖其余的基于反射的实现。这显著减少了生成的代码，但也降低了性能。或者，如果.proto文件包含： 1option optimize_for = LITE_RUNTIME; 那么Foo将包括所有方法的快速实现，将实现该google::protobuf::MessageLite接口，该接口只包含Message方法的子集。特别地，它不支持描述符或映射。但是，在这种模式下，生成的代码只需要链接libprotobuf-lite.so（libprotobuf-lite.lib在Windows上），而不是libprotobuf.so（libprotobuf.lib）。lite库比完整的库小得多，更适合资源有限的系统，如手机。 你不能创建自己的Foo子类。如果您将此类子类化并覆盖虚函数，则覆盖可能会被忽略，因为许多生成的方法调用都将被去虚拟化以提高性能。 Message接口定义了检查、处理、读取或写入整个message的方法，包括解析和序列化到二进制字符串。除了这些方法，Foo类还定义了以下方法： 1234567Foo()：默认构造函数。~Foo()：默认析构函数。Foo(const Foo&amp; other)：拷贝构造函数。Foo&amp; operator=(const Foo&amp; other)：赋值运算。void Swap(Foo* other)：用另一个消息交换内容。const UnknownFieldSet&amp; unknown_fields() const：返回解析此消息时遇到的一组未知字段。UnknownFieldSet* mutable_unknown_fields()：返回指向解析此消息时遇到的未知字段的可变集的指针。 该类还定义了以下静态方法： 12345static const Descriptor* descriptor()- 返回类型的描述符。这包含有关类型的信息，包括它的字段和它们的类型。这可以用映射以编程方式检查字段。static const Foo&amp; default_instance()- 返回一个const单例实例Foo与新构造的实例相同Foo（所有单个字段未设置，所有重复字段都为空）。请注意，消息的默认实例可以被用作工厂通过调用其New()方法。 message可以在另一个message中声明。例如：1message Foo &#123; message Bar &#123; &#125; &#125; 在这种情况下，编译器生成两个类：Foo和Foo_Bar。另外，编译器会在Foo类下生成一个typedef ： 1typedef Foo_Bar Bar; 这意味着您可以使用嵌套类型的类，就像它是嵌套类Foo::Bar一样。但是，请注意，C++不允许向前声明嵌套类型。如果要在另一个文件中转发声明并使用该声明，则必须将其标识为Foo_Bar。 Fields除了上一节中描述的方法之外，protocol缓冲区编译器为.proto文件中的消息中定义的每个字段生成一组访问方法。 除了访问器方法之外，编译器还会为包含其字段编号的每个字段生成一个整数常量。常数名称是字母k，后跟字段名称转换为驼峰法，后跟FieldNumber。例如，给定该字段optional int32 foo_bar = 5;;编译器将生成常量static const int kFooBarFieldNumber = 5;。 对于返回const引用的字段访问器，当对消息进行下一个修改访问时，该引用可能会无效。这包括调用任何const字段的任何非访问者，通过其他方法（例如，使用该消息作为参数）调用const继承Message或修改消息的任何非方法Swap()。相应地，如果在此期间没有对消息进行任何修改访问，返回引用的地址只能在访问器的不同调用中保持相同。 对于返回指针的字段访问器，当对消息进行下一个修改或不修改访问时，该指针可能无效。这包括，不管const是什么，调用任何字段的任何访问者，Message通过其他方式调用继承或访问消息的任何方法（例如，通过使用复制构造函数复制消息）。相应地，返回的指针的值不能保证在访问器的两个不同调用中是相同的。 Singular Numeric Fields (proto2)对于任一这些字段定义： 12optional int32 foo = 1;required int32 foo = 1; 编译器将生成以下访问器方法： 1234bool has_foo() const：返回true是否设置了该字段。int32 foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。void set_foo(int32 value)：设置字段的值。调用后，has_foo()将返回true并foo()返回value。void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。 对于其他数字字段类型（包括bool），int32将根据标量值类型表替换为相应的C++类型。 Singular Numeric Fields (proto3)对于此字段定义：1int32 foo = 1; 编译器将生成以下访问器方法： 123int32 foo() const：返回字段的当前值。如果未设置该字段，则返回0。void set_foo(int32 value)：设置字段的值。调用后，foo()会返回value。void clear_foo()：清除字段的值。调用这个之后，foo()会返回0。 对于其他数字字段类型（包括bool），int32将根据标量值类型表替换为相应的C++类型。 Singular String Fields (proto2)对于任何这些字段定义： 1234optional string foo = 1;required string foo = 1;optional bytes foo = 1;required bytes foo = 1; 编译器将生成以下访问器方法： 12345678910111213141516171819202122232425bool has_foo() const：返回true是否设置了该字段。const string&amp; foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。void set_foo(const string&amp; value)：设置字段的值。调用后，has_foo()将返回true并foo()返回一份value。void set_foo(const char* value)：使用C风格的以null结尾的字符串设置字段的值。调用后，has_foo()将返回true并foo()返回一份value。void set_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。string* mutable_foo()：返回指向可变string对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空（而不是默认值）。调用它后，has_foo()将返回true并foo()返回任何写入给定字符串的值。void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。void set_allocated_foo(string* value)：将string对象设置为字段，并释放前一个字段值（如果存在）。如果string指针不是NULL，消息将获取所分配的string对象的所有权并has_foo()返回true。否则，如果value是NULL，行为与调用相同clear_foo()。string* release_foo()：释放字段的所有权并返回string对象的指针。调用该string函数后，调用者将获取已分配对象的所有权，has_foo()将返回false，并foo()返回默认值。 Singular String Fields (proto3)对于任何这些字段定义： 12string foo = 1;bytes foo = 1; 编译器将生成以下访问器方法： 123456789101112131415161718192021const string&amp; foo() const：返回字段的当前值。如果未设置该字段，则返回空字符串/空字节。void set_foo(const string&amp; value)：设置字段的值。调用后，foo()会返回一份value。void set_foo(const char* value)：使用C风格的以null结尾的字符串设置字段的值。调用后，foo()会返回一份value。void set_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。string* mutable_foo()：返回指向可变string对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空。调用它之后，foo()将返回写入给定字符串的任何值。void clear_foo()：清除字段的值。调用这个之后，foo()将返回空字符串/空字节。void set_allocated_foo(string* value)：将string对象设置为字段，并释放前一个字段值（如果存在）。如果string指针不是NULL，该消息将占用所分配string对象的所有权。否则，如果value是NULL，行为与调用相同clear_foo()。string* release_foo()：释放字段的所有权并返回string对象的指针。调用该方法后，调用者将获取已分配string对象的所有权，并foo()返回空字符串/空字节。 Singular Enum Fields (proto2)给定枚举类型： 1234enum Bar &#123; BAR_VALUE = 0; OTHER_VALUE = 1;&#125; 对于任一这些字段定义： 12optional Bar foo = 1;required Bar foo = 1; 编译器将生成以下访问器方法： 12345678bool has_foo() const：返回true是否设置了该字段。Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。void set_foo(Bar value)：设置字段的值。调用后，has_foo()将返回true并foo()返回value。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。 Singular Enum Fields (proto3)给定枚举类型： 1234enum Bar &#123; BAR_VALUE = 0; OTHER_VALUE = 1;&#125; 对于此字段定义： 1Bar foo = 1; 编译器将生成以下访问器方法：12345Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值（0）。void set_foo(Bar value)：设置字段的值。打电话后，foo()会返回value。void clear_foo()：清除字段的值。调用该命令后，foo()将返回默认值。 Singular Embedded Message Fields给定消息类型： 1message Bar &#123;&#125; 对于任何这些字段定义： 123//proto2optional Bar foo = 1;required Bar foo = 1; 12//proto3Bar foo = 1; 编译器将生成以下访问器方法：12345678910111213141516bool has_foo() const：返回true是否设置了该字段。const Bar&amp; foo() const：返回字段的当前值。如果未设置该字段，则返回一个不设置Bar其字段（可能Bar::default_instance()）的字段。Bar* mutable_foo()：返回指向可变Bar对象的指针，该对象存储字段的值。如果在调用之前没有设置该字段，则返回Bar的字段将不会设置任何字段（即它将与新分配的相同Bar）。调用这个之后，has_foo()将返回true并foo()返回对同一个实例的引用Bar。void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。void set_allocated_foo(Bar* bar)：将Bar对象设置为字段，并释放前一个字段值（如果存在）。如果Bar指针不是NULL，消息将获取所分配的Bar对象的所有权并has_foo()返回true。否则，如果Bar是NULL，行为与调用相同clear_foo()。Bar* release_foo()：释放字段的所有权并返回Bar对象的指针。调用该Bar函数后，调用者将获取已分配对象的所有权，has_foo()将返回false，并foo()返回默认值。 Repeated Numeric Fields对于此字段定义： 1repeated int32 foo = 1; 编译器将生成以下访问器方法：12345678910111213141516int foo_size() const：返回字段中当前的元素数。int32 foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。void set_foo(int index, int32 value)：设置给定基于零的索引的元素的值。void add_foo(int32 value)：用给定的值追加一个新元素到该字段。void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。const RepeatedField&lt;int32&gt;&amp; foo() const：返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。RepeatedField&lt;int32&gt;* mutable_foo()：返回指向RepeatedField存储字段元素的底层mutable的指针。这个容器类提供了类似STL的迭代器和其他方法。对于其他数字字段类型（包括bool），int32将根据标量值类型表替换为相应的C ++类型。 Repeated String Fields对于任一这些字段定义： 12repeated string foo = 1;repeated bytes foo = 1; 编译器将生成以下访问器方法：12345678910111213141516171819202122232425int foo_size() const：返回字段中当前的元素数。const string&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。void set_foo(int index, const string&amp; value)：设置给定基于零的索引的元素的值。void set_foo(int index, const char* value)：使用C风格的以null结尾的字符串来设置给定基于零的索引处的元素的值。void set_foo(int index, const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。string* mutable_foo(int index)：返回一个指向可变string对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。void add_foo(const string&amp; value)：用给定的值追加一个新元素到该字段。void add_foo(const char* value)：使用C风格的以null结尾的字符串向字段添加一个新元素。void add_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。string* add_foo()：添加一个新的空字符串元素并返回一个指针。void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。const RepeatedPtrField&lt;string&gt;&amp; foo() const：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。RepeatedPtrField&lt;string&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层mutable的指针。这个容器类提供了类似STL的迭代器和其他方法。 Repeated Enum Fields给定枚举类型： 1234enum Bar &#123; BAR_VALUE = 0; OTHER_VALUE = 1;&#125; 对于此字段定义： 1repeated Bar foo = 1; 编译器将生成以下访问器方法：12345678910111213int foo_size() const：返回字段中当前的元素数。Bar foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。void set_foo(int index, Bar value)：设置给定基于零的索引的元素的值。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。void add_foo(Bar value)：用给定的值追加一个新元素到该字段。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。const RepeatedField&lt;int&gt;&amp; foo() const：返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。RepeatedField&lt;int&gt;* mutable_foo()：返回指向RepeatedField存储字段元素的底层mutable的指针。这个容器类提供了类似STL的迭代器和其他方法。 Repeated Embedded Message Fields给定消息类型： 1message Bar &#123;&#125; 对于此字段定义： 1repeated Bar foo = 1; 编译器将生成以下访问器方法： 12345678910111213int foo_size() const：返回字段中当前的元素数。const Bar&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。Bar* mutable_foo(int index)：返回一个指向可变Bar对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。Bar* add_foo()：添加一个新元素并返回一个指针。返回的Bar将不会设置任何字段（即它将与新分配的相同Bar）。void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。const RepeatedPtrField&lt;Bar&gt;&amp; foo() const：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。RepeatedPtrField&lt;Bar&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层mutable的指针。这个容器类提供了类似STL的迭代器和其他方法。 Oneof Numeric Fields对于这个oneof字段定义：1234oneof_name &#123; int32 foo = 1; ...&#125; 编译器将生成以下访问器方法：123456789101112bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。int32 foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。void set_foo(int32 value)：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- 设置此字段的值，并将其中的一个设置为kFoo。- has_foo()（仅原型2）将返回true，foo()将返回value，并oneof_name_case()返回kFoo。void clear_foo()：- 如果不是，情况不会改变kFoo。- 如果一个情况是kFoo，清除字段的值和一个case。has_foo()（仅限proto2）将返回false，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。 对于其他数字字段类型（包括bool）， int32将根据标量值类型表替换为相应的C ++类型。 Oneof String Fields对于任何这些oneof字段定义：12345678oneof_name &#123; string foo = 1; ...&#125;oneof_name &#123; bytes foo = 1; ...。&#125; 编译器将生成以下访问器方法：12345678910111213141516171819202122232425262728293031323334bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。const string&amp; foo() const：如果一种情况，则返回该字段的当前值kFoo。否则返回默认值。void set_foo(const string&amp; value)：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- 设置此字段的值，并将其中的一个设置为kFoo。- has_foo()（仅原始2）将返回true，foo()将返回value并oneof_name_case()返回kFoo。void set_foo(const char* value)：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- 使用C风格的空值终止的字符串设置字段的值，并将其中的一个设置为kFoo。- has_foo()（仅原始2）将返回true，foo()将返回value并oneof_name_case()返回kFoo。void set_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。string* mutable_foo()：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- kFoo将一个case设置为并返回一个指向可变字符串对象的指针，该对象存储字段的值。如果一个情况不在kFoo调用之前，则返回的字符串将为空（而不是默认值）。- has_foo()（仅原型2）将返回true，foo()将返回任何写入给定字符串的值，oneof_name_case()并返回kFoo。void clear_foo()：- 如果一个案件不是kFoo，任何事情都不会改变。- 如果一个案例是kFoo，释放字段并清除一个case。has_foo()（仅原型2）将返回false，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。void set_allocated_foo(string* value)：- 电话clear_oneof_name()。- 如果字符串指针不是NULL：将字符串对象设置为字段并将其设置为一个kFoo。该消息将获取已分配的字符串对象的所有权，has_foo()（仅原型2）将返回true并oneof_name_case()返回kFoo。- 如果字符串指针是NULL，has_foo()（仅原型2）将返回false并oneof_name_case()返回ONEOF_NAME_NOT_SET。string* release_foo()：- NULL如果一个情况不是返回kFoo。- 清除一个情况，释放该字段的所有权并返回字符串对象的指针。调用这个之后，调用者占用所分配的字符串对象，has_foo()（仅原型2）将返回false，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。 Oneof Enum Fields给定枚举类型： 1234enum Bar &#123; BAR_VALUE = 0; OTHER_VALUE = 1;&#125; 对于oneof字段定义： 1234oneof oneof_name &#123; Bar foo = 1; ...&#125; 编译器将生成以下访问器方法： 12345678910111213bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。Bar foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。void set_foo(Bar value)：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- 设置此字段的值，并将其中的一个设置为kFoo。- has_foo()（仅原型2）将返回true，foo()将返回value并oneof_name_case()返回kFoo。- 在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。void clear_foo()：- 如果一个案件不是，任何事情都不会改变kFoo。- 如果一个案例是kFoo，清除字段的值和一个case。has_foo()（仅限proto2）将返回false，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。 Oneof Embedded Message Fields给定消息类型： 1message Bar &#123;&#125; 对于oneof字段定义： 1234oneof oneof_name &#123; Bar foo = 1; ...&#125; 编译器将生成以下访问器方法：123456789101112131415161718192021bool has_foo() const：如果一个case返回true kFoo。const Bar&amp; foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回Bar::default_instance()。Bar* mutable_foo()：- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。- kFoo将一个情况设置为并返回一个指向可变的Bar对象的指针，该对象存储该字段的值。如果一个情况不在kFoo调用之前，则返回的栏将不会设置任何字段（即它将与新分配的Bar相同）。- 调用这个之后，has_foo()会返回true，foo()将返回一个引用到同一个实例Bar并oneof_name_case()返回kFoo。void clear_foo()：- 如果一个案件不是，任何事情都不会改变kFoo。- 如果一个情况相等kFoo，则释放该字段并清除该情况。has_foo()将返回false，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。void set_allocated_foo(Bar* bar)：- 电话clear_oneof_name()。- 如果Bar指针不是NULL：将Bar对象设置为字段并将其设置为一个kFoo。该消息占用所分配的Bar对象，has_foo（）将返回true，而oneof_name_case（）将返回kFoo。- 如果指针是NULL，has_foo()将返回false并oneof_name_case()返回ONEOF_NAME_NOT_SET。（行为就像调用clear_oneof_name()）Bar* release_foo()：- NULL如果一个情况不是返回kFoo。- 如果一种情况是kFoo，清除一种情况，释放该字段的所有权并返回该Bar对象的指针。调用这个之后，调用者占用所分配的Bar对象，has_foo()将返回false，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。 Map Fields对于此Map字段定义： 1map&lt;int32, int32&gt; weight = 1; 编译器将生成以下访问器方法：12const google::protobuf::Map&lt;int32, int32&gt;&amp; weight();：返回一个不可变的Map。google::protobuf::Map&lt;int32, int32&gt;* mutable_weight();：返回一个可变的Map。 一个google::protobuf::Map是用于存储映射字段的协议缓冲区中使用的特殊容器类型。从下面的界面可以看出，它使用常用的子集std::map和std::unordered_map方法。 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename Key, typename T&gt; &#123;class Map &#123; // Member types typedef Key key_type; typedef T mapped_type; typedef ... value_type; // Iterators iterator begin(); const_iterator begin() const; const_iterator cbegin() const; iterator end(); const_iterator end() const; const_iterator cend() const; // Capacity int size() const; bool empty() const; // Element access T&amp; operator[](const Key&amp; key); const T&amp; at(const Key&amp; key) const; T&amp; at(const Key&amp; key); // Lookup int count(const Key&amp; key) const; const_iterator find(const Key&amp; key) const; iterator find(const Key&amp; key); // Modifiers pair&lt;iterator, bool&gt; insert(const value_type&amp; value); template&lt;class InputIt&gt; void insert(InputIt first, InputIt last); size_type erase(const Key&amp; Key); iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); void clear(); // Copy Map(const Map&amp; other); Map&amp; operator=(const Map&amp; other);&#125; 添加数据的最简单的方法是使用普通的地图语法，例如： 12std::unique_ptr&lt;ProtoName&gt; my_enclosing_proto(new ProtoName);(*my_enclosing_proto-&gt;mutable_weight())[my_key] = my_value; pair&lt;iterator, bool&gt; insert(const value_type&amp; value)将隐含地导致value_type实例的深层副本。将新值插入到一个最有效的方法google::protobuf::Map如下： 1T&amp; operator[](const Key&amp; key): map[new_key] = new_mapped; 使用google::protobuf::Map标准Map google::protobuf::Map支持相同的迭代器API的std::map和std::unordered_map。如果您不想google::protobuf::Map直接使用，可以google::protobuf::Map通过执行以下操作转换为标准Map： 12std::map&lt;int32, int32&gt; standard_map(message.weight().begin(), message.weight().end()); 请注意，这将使整个Map的深层副本。 您还可以google::protobuf::Map按照以下方式从标准映射构建一个： 1google::protobuf::Map&lt;int32, int32&gt; weight(standard_map.begin(), standard_map.end()); 解析未知值 在线上，.proto映射等效于每个key/value对的映射条目消息，而映射本身是映射条目的重复字段。像普通消息类型一样，解析的映射条目消息可能具有未知字段：例如，int64定义为映射的映射中的类型字段map&lt;int32, string&gt;。 如果Map条目消息的有线格式中有未知字段，则它们将被丢弃。 如果Map条目消息的有线格式中有一个未知的枚举值，那么它在proto2和proto3中的处理方式不同。在proto2中，将整个map条目消息放入包含消息的未知字段集中。在proto3中，它被放入一个映射字段，就像它是一个已知的枚举值一样。 Any给出一个Any这样的字段： 123456import &quot;google/protobuf/any.proto&quot;;message ErrorStatus &#123; string message = 1; google.protobuf.Any details = 2;&#125; 在我们生成的代码中，该details字段的getter返回一个实例google::protobuf::Any。这提供了以下特殊方法来打包和解压缩Any的值： 123456789101112131415161718class Any &#123; public: // Packs the given message into this Any using the default type URL // prefix “type.googleapis.com”. void PackFrom(const google::protobuf::Message&amp; message); // Packs the given message into this Any using the given type URL // prefix. void PackFrom(const google::protobuf::Message&amp; message, const string&amp; type_url_prefix); // Unpacks this Any to a Message. Returns false if this Any // represents a different protobuf type or parsing fails. bool UnpackTo(google::protobuf::Message* message) const; // Returns true if this Any represents the given protobuf type. template&lt;typename T&gt; bool Is() const;&#125; Oneof给定一个这样的定义： 12345oneof_name &#123; int32 foo_int = 4; string foo_string = 9; ...&#125; 编译器将生成以下C++枚举类型： 12345enum OneofNameCase &#123; kFooInt = 4, kFooString = 9, ONEOF_NAME_NOT_SET = 0&#125; 另外，它会产生这种方法：1OneofNameCase oneof_name_case() const：返回指定哪个字段被设置的枚举。ONEOF_NAME_NOT_SET如果没有设置它们返回。 编译器还生成以下私有方法，它在一个字段访问器中使用： 1void clear_oneof_name()：如果一个字段集使用一个指针（Message或String），并设置一个case，则释放该对象ONEOF_NAME_NOT_SET。 Enumerations给定一个枚举定义，如： 12345enum Foo &#123; VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234;&#125; 协议缓冲区编译器将生成一个Foo使用相同值进行调用的C++枚举类型。此外，编译器将生成以下函数： 123456789101112131415const EnumDescriptor* Foo_descriptor()：返回类型的描述符，其中包含有关此枚举类型定义的值的信息。bool Foo_IsValid(int value)：true如果给定的数值与其中一个Foo定义的值匹配，则返回。在上面的例子中，true如果输入为0,5或1234 ，则返回。const string&amp; Foo_Name(int value)：返回给定数值的名称。如果不存在这样的值，则返回一个空字符串。如果多个值具有此数字，则返回第一个定义的值。在上面的例子中，Foo_Name(5)会返回"VALUE_B"。bool Foo_Parse(const string&amp; name, Foo* value)：如果name是此枚举的有效值名称，则将该值分配value并返回true。否则返回false。在上面的例子中，Foo_Parse("VALUE_C", &amp;someFoo)将返回true并设置someFoo为1234。const Foo Foo_MIN：枚举的最小有效值（示例中为VALUE_A）。const Foo Foo_MAX：枚举的最大有效值（在示例中为VALUE_C）。const int Foo_ARRAYSIZE：总是定义为Foo_MAX + 1。 将整数转换为proto2枚举时要小心。 如果将整数转换为proto2枚举值，则该整数必须是枚举以外的有效值之一，否则结果可能未定义。如果有疑问，请使用生成的Foo_IsValid()函数来测试该转换是否有效。将proto2消息的枚举类型字段设置为无效值可能会导致断言失败。如果在解析proto2消息时读取一个无效的枚举值，它将被视为未知字段。这些语义在proto3中已经改变了。只要适用于int32，就可以将任何整数转换为proto3枚举值。在解析proto3消息并由枚举字段访问器返回时，也将保留无效的枚举值。 在switch语句中使用proto3枚举时要小心。Proto3枚举是打开的枚举类型，可能的值超出了指定符号的范围。在解析proto3消息并由枚举字段访问器返回时，将不会识别到枚举值。在没有默认情况下的proto3枚举上的switch语句将无法捕获所有情况，即使列出了所有已知字段。这可能会导致意外的行为，包括数据损坏和运行时崩溃。始终添加默认情况，或者Foo_IsValid(int)在交换机外部显式调用以处理未知的枚举值。 您可以在消息类型中定义一个枚举。在这种情况下，协议缓冲区编译器会生成代码，使得它看起来是枚举类型本身被声明为嵌套在消息的类中。在Foo_descriptor()与Foo_IsValid()函数声明为静态方法。实际上，枚举类型本身及其值在全局范围内被声明为具有变量名称，并且通过typedef和一系列常量定义导入到类的范围内。这只是为了避免声明排序的问题。不要依赖于被破坏的顶级名称; 假装枚举真的嵌套在消息类中。 Extensions (proto2 only)给定一个扩展范围的消息： 123message Foo &#123; extensions 100 to 199;&#125; 该协议缓冲编译器将产生一些额外的方法Foo： HasExtension()，ExtensionSize()，ClearExtension()，GetExtension()，SetExtension()，MutableExtension()，AddExtension()，SetAllocatedExtension()和ReleaseExtension()。作为其第一参数，这些方法中的每一个都采用标识扩展字段的扩展标识符（如下所述）。剩余的参数和返回值与对于与扩展标识符相同类型的普通（非扩展）字段生成的相应存取器方法的参数和返回值完全相同。（GetExtension()对应于没有特殊前缀的访问器） 给定一个扩展定义： 1234extend Foo &#123; optional int32 bar = 123; repeated int32 repeated_bar = 124;&#125; 对于单个扩展字段bar，协议缓冲区编译器生成一个调用的扩展标识符 bar，您可以使用它们Foo的扩展访问器来访问此扩展，如下所示： 1234567Foo foo;assert(!foo.HasExtension(bar));foo.SetExtension(bar, 1);assert(foo.HasExtension(bar));assert(foo.GetExtension(bar) == 1);foo.ClearExtension(bar);assert(!foo.HasExtension(bar)); 类似地，对于重复的扩展字段repeated_bar，编译器生成一个调用的扩展标识符repeated_bar，您也可以使用Foo扩展名的扩展名： 12345678Foo foo;for (int i = 0; i &lt; kSize; ++i) &#123; foo.AddExtension(repeated_bar, i)&#125;assert(foo.ExtensionSize(repeated_bar) == kSize)for (int i = 0; i &lt; kSize; ++i) &#123; assert(foo.GetExtension(repeated_bar, i) == i)&#125; （扩展名标识符的确切实现是复杂的，涉及神奇使用模板 - 但是，您不需要担心扩展名标识符如何使用它们。） 扩展可以被声明为嵌套在另一种类型之内。例如，一个常见的模式是做这样的事情： 12345message Baz &#123; extend Foo &#123; optional Baz foo_ext = 124; &#125;&#125; 在这种情况下，扩展名标识符foo_ext被声明嵌套在里面Baz。可以使用如下： 123Foo foo;Baz* baz = foo.MutableExtension(Baz::foo_ext);FillInMyBaz(baz); Arena AllocationArena分配是一个仅C++功能，可帮助您优化内存使用情况，并在使用协议缓冲区时提高性能。在您.proto的C++生成的代码中添加额外的代码来使用Arena分配。您可以在“Arena分配指南”中了解有关竞技场分配API的更多信息。 Services如果.proto文件包含以下行： 1option cc_generic_services = true; 然后，协议缓冲区编译器将根据本节中所述的文件中找到的服务定义生成代码。然而，所生成的代码可能是不期望的，因为它不与任何特定的RPC系统相关联，并且因此需要针对一个系统进行编码的更多级别的间接代码。如果您不希望生成此代码，请将此行添加到文件中： 1option cc_generic_services = false; 如果不给出上述任何一行，则该选项默认 false为通用服务已被弃用。（请注意，在2.4.0之前，该选项默认为true） 基于.proto语言服务定义的RPC系统应该提供插件来为系统生成代码。这些插件可能要求抽象服务被禁用，以便它们可以生成自己的同名的类。插件是新版本2.3.0（2010年1月）。 本节的其余部分描述了启用抽象服务时协议缓冲区编译器生成的内容。 Interface给定服务定义： 123service Foo &#123; rpc Bar(FooRequest) returns(FooResponse);&#125; 协议缓冲区编译器将生成一个类Foo来表示此服务。 Foo将为服务定义中定义的每个方法设置虚拟方法。在这种情况下，该方法Bar定义为： 12virtual void Bar(RpcController* controller, const FooRequest* request, FooResponse* response, Closure* done); 参数等同于参数Service::CallMethod()，除了method参数是隐含的，request和response指定其确切类型。 这些生成的方法是虚的，但不是纯虚的。默认实现只需调用一个controller-&gt;SetFailed()错误消息，指示该方法未实现，然后调用回调done。实现自己的服务时，您必须对此生成的服务进行子类化，并根据需要实现其方法。 Foo子类Service接口。协议缓冲区编译器自动生成方法的实现Service如下： GetDescriptor：返回服务的ServiceDescriptor。 CallMethod：根据提供的方法描述符确定正在调用哪个方法，并直接调用它，将请求和响应消息对象降级到正确的类型。 GetRequestPrototype和GetResponsePrototype：返回给定方法的正确类型的请求或响应的默认实例。 还会生成以下静态方法： static ServiceDescriptor descriptor()：返回类型的描述符，其中包含有关此服务具有哪些方法及其输入和输出类型的信息。 Stub协议缓冲区编译器还生成每个服务接口的“stub”实现，由客户端希望向执行服务的服务器发送请求使用。对于Foo服务（上），Foo_Stub将定义存根实现。与嵌套消息类型一样，使用typedef Foo_Stub也可以被称为Foo::Stub。 Foo_Stub是一个子类Foo也实现了以下方法：123Foo_Stub(RpcChannel* channel)：构造在给定通道上发送请求的新存根。Foo_Stub(RpcChannel* channel, ChannelOwnership ownership)：构造一个新的存根，在给定的通道上发送请求，并且可能拥有该通道。如果ownership是，Service::STUB_OWNS_CHANNEL当存根对象被删除时，它也会删除该通道。RpcChannel* channel()：返回此存根的通道，传递给构造函数。 存根附加地将每个服务的方法实现为通道周围的包装器。调用一种方法简单地调用channel-&gt;CallMethod()。 协议缓冲库不包括RPC实现。但是，它包括将生成的服务类连接到您选择的任意任意RPC实现所需的所有工具。您只需要提供RpcChannel和的实现RpcController。有关service.h详细信息，请参阅文档。 Plugin Insertion Points要扩展C ++代码生成器的输出的代码生成器插件可以使用给定的插入点名称插入以下类型的代码。除非另有说明，否则每个插入点都显示在.pb.cc文件和.pb.h文件中。 includes：包含指令。 namespace_scope：属于文件包/命名空间但不在任何特定类中的声明。出现在所有其他命名空间范围代码之后。 global_scope：属于文件命名空间之外的顶层的声明。出现在文件的最后端。 class_scope:TYPENAME：属于消息类的成员声明。 TYPENAME是完整的原名，例如package.MessageType。在课后所有其他公开声明后出现。此插入点仅显示在.pb.h文件中。 不要生成依赖于标准代码生成器声明的私有类成员的代码，因为这些实现细节可能会在将来版本的协议缓冲区中更改。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>google</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理git命令]]></title>
    <url>%2F2017%2F07%2F13%2F00049%E6%89%B9%E5%A4%84%E7%90%86git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[每次更新博客，都需要输入大量指令来同步github，那么是否可以批处理这些命令使之自动之行？ 当然可以。 比如，我在hexo文件夹下有hexo博客文件，那么我只需在此创建upload.sh文件并输入： 12345678hexo cleanhexo ghexo dgit statusgit add -Agit add -ugit commit -m "Update at $(date)"git push origin master:mydesktop 创建好之后，在git bash中输入： 1./upload.sh 就会自动执行这一系列指令，省去了好多麻烦，敲一下，等待、喝杯咖啡、去个洗手间！！！]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows右键cmd]]></title>
    <url>%2F2017%2F07%2F13%2F00003windows%E5%8F%B3%E9%94%AEcmd%2F</url>
    <content type="text"><![CDATA[在使用windows操作系统的时候，常常需要win+R打开cmd窗口，在此特记简单快捷方法如下： 按住shift键在指定文件夹下右击鼠标出现“在此处打开命令窗口(W)”，点击此，就会在指定文件夹下打开cmd。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glog初步体验]]></title>
    <url>%2F2017%2F07%2F13%2F00014glog%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[最近看caffe源码，希望对源码中的每个知识点都吃透，遇到不会的记录。今天仅记录glog的一段测试代码，详细TBD。 123456789101112131415#include &lt;iostream&gt;#include &lt;glog\logging.h&gt;using namespace std;using namespace google;int main()&#123; google::InitGoogleLogging(""); google::SetLogDestination(google::GLOG_INFO, "./myInfo"); LOG(INFO) &lt;&lt; "This is a message!"; int a = 2; CHECK_GT(a, 3) &lt;&lt; "a is little than 3!"; google::ShutdownGoogleLogging(); return 0;&#125;]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>glog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类之虚函数,纯虚函数和普通函数]]></title>
    <url>%2F2017%2F07%2F07%2F00046%E7%B1%BB%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍了C++中的普通成员函数、虚函数以及纯虚函数,非常的详细，有需要的朋友可以参考下。 普通成员函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数； 虚函数为了重载和多态的需要，在基类中定义的，即便定义为空； 纯虚函数是在基类中声明的虚函数，它可以再基类中有定义，且派生类必须定义自己的实现方法。 假设我们有三个类Person、Teacher、Student它们之间的关系如下： 类的关系图 Demo-1根据这个类图，我们有下面的代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef __OBJEDT_H__#define __OBJEDT_H__#include &lt;string&gt;#include &lt;iostream&gt;class Person&#123;public: Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125; void ShowInfo()&#123; cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; "年龄：" &lt;&lt; m_age &lt;&lt; endl; &#125;protected: string m_name; //姓名 int m_age; //年龄&#125;;class Teacher : public Person&#123;public: Teacher(const string&amp; name, int age, const string&amp; title): Person(name, age), m_title(title)&#123;&#125; void ShowInfo()&#123; cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; "年龄：" &lt;&lt; m_age &lt;&lt; endl; cout &lt;&lt; "职称：" &lt;&lt; m_title &lt;&lt; endl; &#125;private: string m_title; //职称&#125;;class Student : public Person&#123;public: Student(const string&amp; name, int age, int studyId): Person(name, age), m_studyId(studyId)&#123;&#125; void ShowInfo()&#123; cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; "年龄：" &lt;&lt; m_age &lt;&lt; endl; cout &lt;&lt; "学号：" &lt;&lt; m_studyId &lt;&lt; endl; &#125;private: int m_studyId; //学号&#125;;#endif //__OBJEDT_H__ 测试代码： 1234567891011121314void test()&#123; Person* pPerson = new Person("张三", 22); Teacher* pTeacher = new Teacher("李四", 35, "副教授"); Student* pStudent = new Student("王五", 18, 20151653); pPerson-&gt;ShowInfo(); cout &lt;&lt; endl; pTeacher-&gt;ShowInfo(); cout &lt;&lt; endl; pStudent-&gt;ShowInfo(); cout &lt;&lt; endl; delete pPerson; delete pTeacher; delete pStudent;&#125; 结果： 12345678910姓名：张三 年龄：22姓名：李四 年龄：35 职称：副教授姓名：王五 年龄：18 学号：20151653 说明：这里的ShowInfo就是一个普通的函数。pPerson、pTeacher和pStudent三个对象调用ShowInfo分别展示自己的信息。我们知道：父类的指针是可以指向子类的对象的。我们把上面的测试代码稍微改一下： Demo-21234567891011121314void test()&#123; Person* pPerson = new Person(&quot;张三&quot;, 22); Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;); Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653); pPerson-&gt;ShowInfo(); cout &lt;&lt; endl; pTeacher-&gt;ShowInfo(); cout &lt;&lt; endl; pStudent-&gt;ShowInfo(); cout &lt;&lt; endl; delete pPerson; delete pTeacher; delete pStudent;&#125; 结果： 12345678姓名：张三 年龄：22姓名：李四 年龄：35姓名：王五 年龄：18 这时，pTeacher和pStudent只输出了姓名和年龄，并没有输出子类所具有的特性(职称和学号)。 这应该不是你期望的结果，你可能期望pTeacher和pStudent输出老师和学生的完整信息，这时就需要用虚函数。 虚函数 我们把Person中的ShowInfo成员改成虚函数(在前面加上virtual)，代码如下： Demo-3123456789101112class Person&#123;public: Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125; virtual void ShowInfo()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl; &#125;protected: string m_name; //姓名 int m_age; //年龄&#125;; 在执行上面[Demo-2]中的测试代码，得到我们想到的结果： 12345678910姓名：张三 年龄：22姓名：李四 年龄：35 职称：副教授姓名：王五 年龄：18 学号：20151653 虚函数用法要点： 虚函数的声明方式：virtual RETURN_TYPE functionName(ARGS 参数列表); 虚函数作用：现实C++中的多态，进行动态绑定(父类指针可指向子类的对象)，直到运行时才知道要调用哪个版本(哪个类定义)的函数； 我们必要对虚函数进行定义； 一旦父类的成员函数声明virtual，其子类的函数不管有没有声明为virtual，都是虚函数； 如果虚函数使用默认实参，父类和子类定义的默认实参最好一致。 Demo-4针对第4点说明： 12345678910111213141516class Person&#123;public: Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125; virtual void ShowInfo()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; string GetName(); //正确，普通函数如果不被使用，可以只有声明没有定义 virtual int GetAge(); //错误，虚函数必须要有定义，即使是一个空实现,因为编译器无法确定会使用哪个函数protected: string m_name; //姓名 int m_age; //年龄&#125;; Demo-5针对第5点进行说明：设计我们的类如下定义。1234567891011121314151617181920212223class Person&#123;public: virtual void SetAge(int age = 0)&#123; m_age = age; &#125; //... 省略&#125;;class Teacher : public Person&#123;public: virtual void SetAge(int age = 1)&#123; m_age = age; &#125; //... 省略&#125;;class Student : public Person&#123;public: virtual void SetAge(int age = 2)&#123; m_age = age; &#125; //... 省略&#125;; 测试1： 1234567891011121314151617181920void test()&#123; Person* pPerson = new Person(&quot;张三&quot;, 22); Teacher* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;); Student* pStudent = new Student(&quot;王五&quot;, 18, 20151653); pPerson-&gt;SetAge(); pTeacher-&gt;SetAge(); pStudent-&gt;SetAge(); pPerson-&gt;ShowInfo(); cout &lt;&lt; endl; pTeacher-&gt;ShowInfo(); cout &lt;&lt; endl; pStudent-&gt;ShowInfo(); cout &lt;&lt; endl; delete pPerson; delete pTeacher; delete pStudent;&#125; 结果： 12345678910姓名：张三 年龄：0姓名：李四 年龄：1 职称：副教授姓名：王五 年龄：2 学号：20151653 测试2： 123456789101112131415161718192021void test()&#123; Person* pPerson = new Person(&quot;张三&quot;, 22); Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;); Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653); pPerson-&gt;SetAge(); pTeacher-&gt;SetAge(); pStudent-&gt;SetAge(); pPerson-&gt;ShowInfo(); cout &lt;&lt; endl; pTeacher-&gt;ShowInfo(); cout &lt;&lt; endl; pStudent-&gt;ShowInfo(); cout &lt;&lt; endl; delete pPerson; delete pTeacher; delete pStudent;&#125; 结果： 12345678910姓名：张三 年龄：0姓名：李四 年龄：0 职称：副教授姓名：王五 年龄：0 学号：20151653 纯虚函数在上面的例子中，我们假设所有的人都要工作，但不同的人工作的方式不同。 于是我们就要强制要求继承自Person的子类都要有工作的方法，这就需要纯虚函数。 定义如下： Demo-61234567class Person&#123;public: //... 省略 virtual void DoWork() = 0; //... 省略&#125;; 但此时我们编译 1Person* pPerson = new Person(&quot;张三&quot;, 22); 这句话时会报错:1error C2259: ‘Person&apos; : cannot instantiate abstract class 这是因为我们并没有为Person实现DoWork方法，而包含纯虚函数的类是一个抽象的类，抽象类不能被实例化。 于是我们在子类中对它实现如下： Demo-712345678910111213141516171819class Teacher : public Person&#123;public: //... 省略 virtual void DoWork()&#123; cout &lt;&lt; &quot;教书...&quot; &lt;&lt; endl; &#125; //... 省略&#125;;class Student : public Person&#123;public: //... 省略 virtual void DoWork()&#123; cout &lt;&lt; &quot;学习...&quot; &lt;&lt; endl; &#125; //... 省略&#125;; 没用DoWork方法: 123456789101112void test()&#123; Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;); Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653); pTeacher-&gt;DoWork(); cout &lt;&lt; endl; pStudent-&gt;DoWork(); cout &lt;&lt; endl; delete pTeacher; delete pStudent;&#125; 结果： 12教书…学习… 纯虚函数用法要点： 纯虚函数的声明方式：1virtual RETURN_TYPE functionName(ARGS 参数列表) = 0; 含有纯虚函数的类是一个抽象的类，抽象类不能被实例化。 包含纯虚函数的抽象类常用来当作对外的接口，说明这个类有什么功能，而没有具体的实现，基体的实现交由子类完成。 通过以上对普通成员函数、虚函数以及纯虚函数的介绍，希望可以对大家有所帮助。 参考资料 原文链接C++之普通成员函数、虚函数以及纯虚函数的区别与用法要点]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白衬衫]]></title>
    <url>%2F2017%2F07%2F06%2F00060%E7%99%BD%E8%A1%AC%E8%A1%AB%2F</url>
    <content type="text"><![CDATA[袁野夕的《白衬衫》]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
      <tags>
        <tag>袁野夕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS创建动态链接库DLL]]></title>
    <url>%2F2017%2F07%2F06%2F00021VS%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL%2F</url>
    <content type="text"><![CDATA[官网链接：演练：创建和使用动态链接库 (C++)]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>visual studio</tag>
        <tag>dll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab中的P代码]]></title>
    <url>%2F2017%2F06%2F23%2F00030matlab%E4%B8%AD%E7%9A%84P%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[TBD 简单来说就是matlab中的加密代码，比M文件的优先级高，在和M文件同时存在时，优先调用P文件。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一别经年]]></title>
    <url>%2F2017%2F06%2F20%2F00039%E4%B8%80%E5%88%AB%E7%BB%8F%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[半夜，被鼻炎折磨，以致于睡不着，辗转反侧，手机本是放下复又拿起。APP翻来覆去，直至终于没啥可看。 半夜，总是怀念。 这学期没回过家，端午假期，于是早就计划利用假期回一趟。开始一切都好，而后母亲大人告诉我你陪你爸去医院看看，才知道父亲身体出了点状况。人到中年，难免会有这样或那样的病，作为人子而且是独生子女听到这样的话有点慌，毕竟没有经历过。焦躁，无助。正是农忙时，家里早已没有地了，只有屋前屋后的菜地，平时上班的父母还折腾点农作物，恰逢农忙，父亲执意要等农忙之后再去看。其实没啥可忙，就那点地，用我的话说，这还没你们一天的工资多呢。作为从那个年代走过来的父亲，多少会对我的言语反感，其实我也是关心则乱。无奈，本来在家甩手掌柜的我，也操起家伙帮他把作物收上来。用父亲的话说，他不弄，等他做完手术只有我妈一个人弄，她哪弄得过来，上班那么累。父亲还是心疼母亲的。于是执意倔强在手术前把该弄的弄好了。为此，我不得不延长假期。工作日就陪父亲去医院，医生说了手术，意料之中。于是就准备着，其实我也不知道准备什么，第一次经历。尽管医生说小手术，但还是担心，后来看是多余的。第一天手术叫了叔伯过来帮忙看着点，从进手术室开始无奈心慌，母亲也请了假，不知道她当时的心理。一小时过后，医生出来，手术顺利。期间我跑上跑下忙来忙去缓解自己紧张的情绪。后来就是漫长的陪床，也有埋怨父母不早点来看。后来静下来想想，又没多说什么，多说无益。总之，这个假期的经历难忘。父亲第三天就能下地慢慢走动了，于是父母开始催我回学校。用室友的话说，谁不心疼自己的孩子。而怕母亲忙不过来，所以一直待到快出院才回南京。父母年纪越大，开始越像小孩。我们之间的角色开始慢慢对调。这时，才感觉父母老了，头上已经有了白发，岁月无情镌刻了道道皱纹。此时才真正理解朱自清的背影所要表达的情感。 一别经年，曾是少年。 快到而立之年的我，难免怅然若失。身边好友一个个成家立业，回头看看自己，还在为自己心中的那点执着奋斗。现在回想，其实读不读这个博士都没有关系，工作只是工作，人还有其他追求。有时我走在路上，透过镜片看人来人往，有时也会想这个合适吗，然后擦肩而过。 习惯独来独往之后，可以肆无忌惮做想做的事，比如死宅。死宅之后，看了好多电影，弹了好多首歌，最后又吃了好多外卖。于是在体重飙升之后，又急忙开始跑步减肥。美其名曰，锻炼身体。于是开始收集网上的教程，指望能够毕其功于一役。可是，哪有这么美得好事。凡事因果，总有轮回。最近异形上映了，筹划着去看啊，然后瞅着一个人去没意思就没有然后了。有时，也会更新博客，想记录点滴，提笔忘词，遂又作罢，本来生活博客硬是写成了技术札记。也算是小有所得，无心插柳。 现在应该三更天了吧，鼻炎折磨好多了，明天应该快好了吧，俗话病来如山倒。外面还有三两毕业生在说话，以前的我大概也是这样。一别经年，三号路，下马坊，你曾是少年。 丁酉丙午戊寅仅此小记聊慰长夜。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[visio安装配套]]></title>
    <url>%2F2017%2F06%2F15%2F00023visio%E5%AE%89%E8%A3%85%E9%85%8D%E5%A5%97%2F</url>
    <content type="text"><![CDATA[某由于实验室电脑即将坏掉，赶紧在自己的电脑上装上office套装，奈何以前装了好多次，好多流程还得重复试一遍，特此笔记，原谅老年人的健忘症。 由于是在学校，很多东西有学校特供版本，免去查找各种破解工具，某在学校微软正版化下载office 2013 professional plus安装后，不知道该装2013 32位还是64位版本，经测试之后，需下载32位版本进行安装。 好了，装完用学校的激活工具激活就可以开心的写论文了！！！👏👏👏👏👏👏👏👏]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>visio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome油猴脚本]]></title>
    <url>%2F2017%2F06%2F13%2F00008Chrome%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[跑程序之间，给大家推荐一个小程序，叫油猴脚本，这是应用在浏览器中的脚本，很方便，安装很简单，在此不作介绍。 说说优点吧，可以跳过视频广告，可以直接观看VIP视频，还有诸多好处等你发现！！！！！！]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10安装多版本Python]]></title>
    <url>%2F2017%2F06%2F11%2F00020Windows10%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACPython%2F</url>
    <content type="text"><![CDATA[本文主要简要记录在同一台windows10系统的电脑上安装多版本python用于科学计算。 记录主要服务以后。 由于anaconda集成了大量的python库，所以在此用anaconda代替。 在anaconda官网下载最新的64位版本并安装，直到本文开始，python版本为3.6，注意：在安装过程中勾选上conda添加到系统路径以及python作为系统默认python版本。 上面这一步很简单，接下来完全是命令行操作。 123456789101112131415# 创建一个名为python35的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.5.x中的最新版本）conda create -n python35 python=3.5# 或者用如下命令安装所有conda包conda create -n python35 python=3.5 anaconda # 安装好后，使用activate激活某个环境activate python35 # for Windows# 如果想返回默认的python 3.6环境，运行deactivate python35 # for Windows# 删除一个已有的环境conda remove --name python35 --all 就是如此简单，如果需要安装2.7版本也一样。 参考资料 Anaconda使用总结]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邂逅日本]]></title>
    <url>%2F2017%2F05%2F15%2F00052%E9%82%82%E9%80%85%E6%97%A5%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[TBD 借开会时机，日本一游。 历史原因，本人对日本并无好感，总认为是一个无廉耻的民族。经此一游，某些方面改变自己的认识，从短暂的几天经历来说，至少日本人在表面上做的还是值得称赞的。我这里说表面上，因为时间短暂，不敢下最终结论，可能他们仅仅表现在表面上。如《菊与刀》所述，他们的另一面在短暂的时间里并不能完全体会到。 先这样吧，工作时间到了。]]></content>
      <categories>
        <category>追忆脚步</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[caffe学习资料收集]]></title>
    <url>%2F2017%2F04%2F25%2F00006caffe%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一些有关caffe的资料收集，不定期更新！ simshang博客 FCN in Caffe Fully Convolutional Networks PyCaffe in Practice caffe如何自定义网络以及自定义层python版 caffe如何自定义网络以及自定义层（python）（一） caffe如何自定义网络以及自定义层（python）（二） caffe如何自定义网络以及自定义层（python）（三） caffe如何自定义网络以及自定义层（python）（四） caffe如何自定义网络以及自定义层（python）（五） caffe如何自定义网络以及自定义层（python）（六） Caffe学习记录 caffe windows 学习第一步：编译和安装（vs2012+win 64) caffe windows学习：第一个测试程序 Caffe学习系列(1)：安装配置ubuntu14.04+cuda7.5+caffe+cudnn Caffe学习系列(2)：数据层及参数 Caffe学习系列(3)：视觉层（Vision Layers)及参数 Caffe学习系列(4)：激活层（Activiation Layers)及参数 Caffe学习系列(5)：其它常用层及参数 Caffe学习系列(6)：Blob,Layer and Net以及对应配置文件的编写 Caffe学习系列(7)：solver及其配置 Caffe学习系列(8)：solver优化方法 Caffe学习系列(9)：运行caffe自带的两个简单例子 Caffe学习系列(10)：命令行解析 Caffe学习系列(11)：图像数据转换成db（leveldb/lmdb)文件 Caffe学习系列(12)：训练和测试自己的图片 Caffe学习系列(13)：数据可视化环境（python接口)配置 Caffe学习系列(14)：初识数据可视化 Caffe学习系列(15)：计算图片数据的均值 Caffe学习系列(16)：caffemodel可视化 Caffe学习系列(17)：模型各层数据和参数可视化 Caffe学习系列(18): 绘制网络模型 Caffe学习系列(19): 绘制loss和accuracy曲线 Caffe学习系列(20)：用训练好的caffemodel来进行分类 Caffe学习系列(21)：caffe图形化操作工具digits的安装与运行 Caffe学习系列(22)：caffe图形化操作工具digits运行实例 Caffe学习系列(23)：如何将别人训练好的model用到自己的数据上 caffe的python接口学习（1）：生成配置文件 caffe的python接口学习（2）：生成solver文件 caffe的python接口学习（3）：训练模型（training) caffe的python接口学习（4）：mnist实例—手写数字识别 caffe的python接口学习（5）：生成deploy文件 caffe的python接口学习（6）：用训练好的模型（caffemodel）来分类新的图片 caffe的python接口学习（7）：绘制loss和accuracy曲线 caffe的python接口学习（8）：caffemodel中的参数及特征的抽取 caffe代码阅读 caffe代码阅读1：blob的实现细节-2016.3.14 caffe代码阅读2：common的实现细节-2016.3.14 caffe代码阅读3：data_reader、internalthread以及blocking_queue的实现细节-2016.3.15 caffe代码阅读4：DataTransformer以及io的实现细节-2016.3.16 caffe代码阅读5：Layer的实现细节-2016.3.17 caffe代码阅读6：Filler的实现细节-2016.3.18 caffe代码阅读7：LayerRegistry的实现细节-2016.3.18 caffe代码阅读8: Data_layers的实现细节（各个数据读取层的实现细节） 2016.3.25-28 caffe代码阅读9：SyncedMemory的实现细节-2016.3.28 caffe代码阅读10：Caffe中卷积的实现细节（涉及到BaseConvolutionLayer、ConvolutionLayer、im2col等）-2016.4.3 Caffe代码阅读11：absval_layer层的实现 Caffe各版本与源码全透析 大魔导师：从零开始山寨caffe 从零开始山寨Caffe·零：必先利其器 从零开始山寨Caffe·壹：仰望星空与脚踏实地 从零开始山寨Caffe·贰：主存模型 从零开始山寨Caffe·叁：全局线程管理器 从零开始山寨Caffe·肆：线程系统 从零开始山寨Caffe·伍：Protocol Buffer简易指南 从零开始山寨Caffe·陆：IO系统(一) 从零开始山寨Caffe·柒：KV数据库 从零开始山寨Caffe·捌：IO系统(二) 从零开始山寨Caffe·玖：BlobFlow 从零开始山寨Caffe·拾：IO系统(三) 从零开始山寨Caffe·拾贰：IO系统(四) caffe使用gdb单步调试及源码阅读 （Caffe，LeNet）IDE单步调试（一） （Caffe，LeNet）网络训练流程（二） （Caffe，LeNet）初始化训练网络（三） （Caffe，LeNet）初始化测试网络（四） （Caffe，LeNet）前向计算（五） （Caffe，LeNet）反向传播（六） （Caffe，LeNet）权值更新（七） （Caffe）基本类Blob，Layer，Net（一） （Caffe）基本类Solver、Caffe、Batch（二） （Caffe）基本类InternalThread（三） （Caffe）基本类DataReader、QueuePair、Body（四） （Caffe）基本类Filter（五） 知乎专栏：黑客与画家 深度学习源码解读-ch0-talk is cheap 深度学习源码解读-ch1-JSON is awesome 深度学习源码解读-ch3-部署 Caffe 网络 深度学习源码解读-ch4-Caffe 中的设计模式 知乎专栏：无痛的机器学习 Caffe代码阅读——层次结构 Caffe源码阅读——Net组装 Caffe代码阅读——Solver Caffe源码阅读——DataLayer&amp;Data Transformer 知乎专栏：晓雷机器学习笔记 caffe源码解析-开篇 caffe源码解析-命令行接口 caffe源码解析-solver_factory Caffe Source Code AnalysisCSDN博客：joshua_1988 VS2013配置Caffe卷积神经网络工具（64位Windows 7）——准备依赖库 VS2013配置Caffe卷积神经网络工具（64位Windows 7）——建立工程]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>caffe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界末日]]></title>
    <url>%2F2017%2F04%2F22%2F00041%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5%2F</url>
    <content type="text"><![CDATA[翻微博突然听见这首歌，有点感慨。网易没有外链，找了个视频。]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
      <tags>
        <tag>周杰伦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑崩了之后hexo的处置]]></title>
    <url>%2F2017%2F04%2F21%2F00057%E7%94%B5%E8%84%91%E5%B4%A9%E4%BA%86%E4%B9%8B%E5%90%8Ehexo%E7%9A%84%E5%A4%84%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[电脑崩溃之后，要重新更新博客是个麻烦的事，以下是个人的历程，现记录下来。 既然电脑崩溃了，那么第一步是重新安装git和node.js。 之后初始化git，设置ssh并添加到github中。 另寻地方，新建文件夹Hexo。 右击git bash here。 1234npm install hexo-cli -ghexo init 将以前保存在github中的源文件下载下来，复制到Hexo文件夹中。 接下来： 123npm install hexo-deployer-git --savenpm install hexo-util --save 这样就可以进行上传到github pages中了。 至于上传源码到github中，我的处置方法是删除原来的源码repo并新建一个repo，然后先将Hexo：git init，再将其上传到repo中。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你给我听好]]></title>
    <url>%2F2017%2F04%2F21%2F00069%E4%BD%A0%E7%BB%99%E6%88%91%E5%90%AC%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[陈奕迅的《你给我听好》。]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
      <tags>
        <tag>陈奕迅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观眉山论剑]]></title>
    <url>%2F2017%2F04%2F16%2F00071%E8%A7%82%E7%9C%89%E5%B1%B1%E8%AE%BA%E5%89%91%2F</url>
    <content type="text"><![CDATA[腾讯观视频工作室出品的《眉山论剑》，很好的时事讲坛类节目，对自己是一个启迪。小时候自己什么都不懂，长大了之后目空一切，以为自己什么都懂，再到现在又发现自己还是什么都不懂。除了自己的专业知识以外，政治博弈这个知识在我这还是空白，也许这个节目能给自己和困惑的你一点启发。庆幸中国有如此一批超级大脑，才能为祖国人民创造如此安定的生活环境。他们用自己的大脑解析外国的阴谋阳谋，学以致用，这一点值得我辈学习。尤其想到节目中陈平研究员提到现在的媒体经济学者，估计就是大多数人，很容易被所谓新闻欺骗，联想到共产党人需要辩证的看待事情这一马克思原理，深有感触。以前的知识并没有白学，只是没有好好利用，活读书。再联想到有句话“半部论语治天下”，其实，人是真正活学了论语，而不是死靠论语来治理天下。回到起点来说，要活读书，化为己用，才能透过现象看到本质。 在此给出眉山论剑的视频链接，以供读者观看。 眉山论剑1：听其言不如观其行 眉山论剑2：不学经济，学孙子兵法 眉山论剑3：媒体经济学的伪命题 眉山论剑4：他们都错了 眉山论剑5：印度超越中国？ 眉山论剑6：中国是1900年的美国 要用科学的辩证眼光来看待问题，也许节目中的问题讲的是对的，也许讲的是不全面的，要有自己的认识，才能达到学习的目的。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[摄影杂货铺]]></title>
    <url>%2F2017%2F04%2F07%2F00070%E6%91%84%E5%BD%B1%E6%9D%82%E8%B4%A7%E9%93%BA%2F</url>
    <content type="text"><![CDATA[本文收集了平时看到的有关摄影的小知识，不定时更新。 好照片的秘诀 - 对比和冲突 新手学习摄影应该注意什么？ 所谓摄影眼，究竟是什么眼？ | 一点思路 学会调色，从理解HSL面板开始 如何突出画面中的主体？布拉德·皮特 告诉你 | 一点技巧]]></content>
      <categories>
        <category>琴棋书画</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖南行见]]></title>
    <url>%2F2017%2F04%2F06%2F00047%E6%B9%96%E5%8D%97%E8%A1%8C%E8%A7%81%2F</url>
    <content type="text"><![CDATA[TBD 留存，以后再写，简单说两句。 行程 南京到张家界 张家界到武陵源 武陵源到张家界 天门山 张家界到长沙 小建议想去玩的朋友需准备充足的时间，武陵源3天为宜。天门山完全是坐索道，其实没啥可玩的，时间仓促可以不去。长沙小吃还不错，时间匆忙，只去了橘子洲，还没玄武湖漂亮。好了就这么多，有空再写。]]></content>
      <categories>
        <category>追忆脚步</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些感悟]]></title>
    <url>%2F2017%2F04%2F06%2F00053%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[本文转载自：一些感悟，仅供本博留存观看，其它商业目的请与原文联系。 首先要自律。这是最基本的。如果一个人不能控制自己的行为，那无法走出自己的路。像说到要做到，有规律地锻炼身体，勤奋努力，这些都是重要的。 接下来要跳出舒适区。举个例子，勤奋本来就是舒适区的一种。“勤能补拙”这个词是很好的，首先它说明现在处于“拙”的状态中，需要继续努力；其次，勤只能用来“补”拙，而不能让拙变巧，不是根本的解决方案。勤奋是一种惶惶然的状态，而不是一种满足的状态，勤奋意味着自己不如别人，于是得要花更多的时间去补救，别人干八小时就够了，自己得花十几个小时才能赶上。这种状态是不长久的，碰到出些小毛小病，或者家里有事，那就补不过来，就要掉队了。勤奋的用处是试错，是让自己在落后时可以多花点时间找到正确的方法，以达到和别人相当甚至更高的效率，从而提高自己的能力。别人是科班出身，我半路杀进来，当然要多花时间去补；别人学习效率高，我的效率不高，于是得要多花点时间去探索更好的方法。勤奋是暂态，它最终目的是找到更好的方法及时补上以离开这个状态，而不是以一直维持这个状态为荣。 不能按部就班，要随时作好把棋盘翻过来的准备，世事变化很快，以前的所有努力，不管经历过什么样的辛劳，全都是沉没成本，在必要时候都需要扔掉的，或许做了很多年方向A，时势告诉你情况不妙，要换成方向B，那就得坚决换。以前或许这个不常见，但是以后这样的事情会越来越多。干了十年方向A，人工智能把方向A吃掉了，然后马上转做方向B，做了五年，人工智能再把B吃掉，然后继续，如此往复。很多时候转变不是一朝一夕，而是靠滴水穿石的功夫，今天长进一点，明天长进一点，跟着领域一起变，若是一个人跑得比别人快，他就会在市场上稀缺并因此获得相对的安全。做研究的人都习惯这个，每天看新东西，每天打开思路，时刻承认自己老旧了几个月或者几周，马上拍拍屁股跟上。学会了这些再去教徒弟是饿不死师傅的，反而让师傅变得更厉害，因为师傅主动跳出来接受打脸，学得比徒弟快。对很多人来说这个比较难，特别是一直顺风顺水的。但若是一直不敢看外面的世界，那迟早有一天会被逼进去面对。与其被逼，不如提早一些主动跳进去。历史无数次以血的教训告诉了大家，适者生存乃永恒之铁律，人类在千万物种中杀出血路成为地球的主宰，也必将背负着这样的命运走向未来。一个人逃避，这个人会被淘汰，一个领域逃避，这个领域会被淘汰，一个国家逃避，这个国家就会被淘汰。 任何时候，自己一定是有错的，最可怕的不是自己错了，而是不知道自己哪里错，并且在错的方向上越走越远。如果周围有厉害的同事，这种感觉尤其强烈，碰上了随便讨论两句，就知道自己哪些知识不足，暗地里记下马上回去补。为此，主动发言积极讨论是很重要的，思维有碰撞才知道问题在哪里。我有时候觉得自己一直在悬崖边上走，也许之前走得还行，但那都过去了，下一步随时有可能踏进崖边的泥地即将摔倒。踏错了不要紧，及时发现自己错了收脚就行；怕的是一直走安稳的道，连悬崖长什么样都不知道了。前辈和老师们说的话，也非常有可能是错的，而身为后辈的我们，大任在于如何找出他们的错误来。找出了的话，能力就得到了提升。而自信，往往就是通过这种方式磨练出来的——为什么自己和别人不同？因为选了一条不一样的路。 再往上走，主次是要分清的。重要的要抓牢，不重要的要放手。有人读过很多文章看过很多书，勤勉自律好学爱问样样不缺，但门门都不精；有人事事亲为，务求完美，大事上往往把握不了。短木板理论是有问题的，大部分岗位不需要全才，要的是一专多能，要的是某方向很牛非常牛，相同程度的可以掰指头数过来，其它的过线就行，甚至不达标也无人关心。如果你不是专家，高薪聘请没有意义；如果你是专家，求全责备没有意义。人一天只有24小时，所以知道哪里要放弃是很重要的，很多时候，没有牺牲就没有得到，要得到就得付出代价，事前权衡利弊，事后愿赌服输。输了不要紧，再来一次。当然在现实中并没有那么惨烈的权衡，而往往是找到了自己的方向，自然而然地就向这个方向发展下去，这时候主要的阻力，就在于登顶之难而非选择之痛。然而，即便生于风平浪静的和平年代，觉悟依然要有，或许将来有一天，得要做出这样的决断。 最后，不要在优越感中停止自己的脚步。名利于人最可怕的莫过于此，分明刚刚启程，但欢呼声让你觉得已然冲线，本来要万里长征，却变成了百米短跑，接受完了鲜花之后，就再也看不见远处的风景。其实境界到了或是未到，只有自己知道。跋山涉水，风餐露宿，鼓掌的是别人，度化的是自己。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传本地博客源码到git服务器]]></title>
    <url>%2F2017%2F03%2F28%2F00050%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文主要想将本地的博客文件上传到github中，以备系统崩坏or不慎删除。 首先创建Repo，例如我创建了Blog（注意：不要添加readme.md） 然后在本地git bash中输入如下： 12345678910111213141516git remote rm origingit add -Agit commit -m '上传'git remote add origin https://github.com/maxiaoyuelun/Blog.gitgit push -u origin master#更新文件git status #查看已经更新哪些文件git add -u #把当前文件夹下中所有tracked文件中被修改过或已删除文件的信息添加到索引库，它不会处理untracked的文件。git commit -m '写出你的修改内容' #这一步必须有，否则下一步不成功git push -u origin mastergit add -A #添加文件时将untracked文件添加到更新索引中git commit -m '写出你的修改内容'git push]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插件收集]]></title>
    <url>%2F2017%2F03%2F28%2F00015hexo%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[本文主要记录收集的hexo插件，不定时更新。 博文末尾加版权addlink博客加密blog-encrypt]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows文本快捷键]]></title>
    <url>%2F2017%2F03%2F28%2F00061Windows%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[本文简记Windows文本的快捷键，以备不时之需，不定期更新。 选取块左移 Shift+Tab 选取块右移 Tab 关闭当前程序 Alt+F4 切换程序 Alt+Tab 将当前行上移、下移一行 Ctrl+Shift+左右方向键 删除当前行 Ctrl+L 选中文字 Shift+方向键]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Bash不能输入中文解决办法]]></title>
    <url>%2F2017%2F03%2F14%2F00012Git-Bash%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[打开Git Bash后， 对窗口右键-&gt;Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8， 关闭再打开。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dlib使用指南]]></title>
    <url>%2F2017%2F01%2F03%2F00011Dlib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[最近搞人脸识别的程序，于是广泛搜索可复用代码，再加上以前就知道的工具，在此笔记。 进入D:/github/dlib/，打开cmd。在此之前需要安装cmake 12345cd examplesmkdir buildcd buildcmake -G "Visual Studio 14 2015 Win64" -DCOMPILER_CAN_DO_CPP_11=ON -DCMAKE_PREFIX_PATH="D:/githun/cudnn/" ..cmake --build . --config Release face_recognition是搭建在dlib之上的代码，一个很好的框架。 测试代码 参考资料 Dlib官网 Dlib github face_recognition github FaceSwap github Dlib CUDA安装]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>cuda</tag>
        <tag>dlib</tag>
        <tag>face_recognition</tag>
        <tag>cudnn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[车站]]></title>
    <url>%2F2016%2F12%2F13%2F00058%E8%BD%A6%E7%AB%99%2F</url>
    <content type="text"><![CDATA[写着论文，听到这首车站，不觉潸然。 读博已经到了第二年，前路可期但前路漫漫。 越来越明白一些道理，就像有了一定的阅历之后再读某一本书，深有同感。 回忆会伤人的，在李健歌声的烘托下，那一丝丝的情绪蔓延开来，断了思绪。 读书这些年，不免多了书生气，少了人生在这个时间段的某种阅历，所谓行万里路。况且，有失必有得，祸福相倚，书读多了，就越来越接近一种说不出的真理，亦或某种大道，亦或某种淡然，有种殊途同归的感觉。 不理解的人可能会说读傻了，产生一种难以交流的感觉，而这正是经历之后的一种觉悟，尽管我才刚刚开始，但此时才真正知道我需要什么，不需要什么，而不是被环境或者外力裹挟前进。 还要经历或者两年，写文章，做实验，最终完成毕业论文，天复一天，年复一年，似乎无聊。 这只是一种经历，经历了之后，会为你打开另外一扇门，不仅仅是苟且，也许是理想。 音乐作为一种勾起思绪的媒介，的确是个好东西，不然即使平时再无聊，也不会好好沉淀，想想，思考。 自从研究生开始学起了尤克里里，而后吉他，对其爱不释手，有时候只是简单的扫弦，也会得到某种放松。可惜，这么久才开始学，幸运是，我已经开始学了。]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>李健</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mxnet初步安装及使用指北]]></title>
    <url>%2F2016%2F12%2F06%2F00062mxnet%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[开发环境 windows 10 visual studio 2013 community update 5 pycharm community edition 2016.3 anaconda 4.2.0 64 bit python 2.7.12 GTX 1070 安装小记 博主安装在D盘上，路径为D:\mxnet\ 首先确保电脑上已经安装好官方Git，并已经配置成功。 确保电脑上已经安装好cuda(博主安装版本8.0)，并已经配置成功。 cuda必须在visual studio 2013之前安装，否则不能在visual studio中正确配置cuda。 用Git下载Github上的源文件至指定路径下。 1git colne https://github.com/dmlc/mxnet.git 安装编译前必备的库和软件：cudnn，opencv，openblas 以下参考官方文档Building and Installing Packages on Windows进行安装并进行补充。 由于博主已经安装了update5，所以不再需要安装visual c++ compiler nov 2013 ctp。如需安装请参考mxnet官方文档。 cmake 3.7.0 cmake官网下载安装最新版本，用来编译Visual Studio Solution。 cudnn cudnn官网下载最新版本5.0，存放在路径D:\cudnn。 opencv opencv下载链接下载版本3.0.0，存放在路径D:\opencv。 在系统属性&gt;环境变量&gt;用户环境变量中添加变量OpenCV_DIR，并赋值D:\opencv\build。 openblas OpenBLAS-v0.2.14-Win64-int64下载链接，存放在路径D:\OpenBLAS-v0.2.14-Win64-int64。 在系统属性&gt;环境变量&gt;用户环境变量中添加变量OpenBLAS_HOME，并赋值D:\OpenBLAS-v0.2.14-Win64-int64。 anaconda anaconda官网下载安装anaconda，博主安装路径为C:\Program Files\Anaconda2\。 visual studio编译配置 首先在D:\mxnet\下新建文件夹build。 打开cmake。 在where is the source code中添加D:\mxnet。在where to build the binaries中添加D:\mxnet\build。 点击Configure，进行配置，若出现配置不成功，则将需要的路径手动添加在cmake中，当然根据出现的问题针对改动。 配置成功后点击Generate生成solution。 生成完成后可以发现在D:\mxnet\build下出现solution文件，用visual studio 2013打开solution。 在visual studio 2013中编译Debug和Release文件，静待几分钟编译成功。 由于大多数使用在python环境下，需要配置python使用环境，在系统属性&gt;环境变量&gt;用户环境变量中添加变量PYTHONPATH，并添加值D:\mxnet\python。由于需要在python中使用opencv，所以在PYTHONPATH变量中继续添加D:\opencv\build\python\2.7\x64。 范例测试 由于在pycharm中编写python代码，需要配置pycharm的编译环境，打开pycharm，在File&gt;Settings&gt;Interpreter中配置解释环境为C:\Program Files\Anaconda2\python.exe。 在pycharm中打开文件train_mnist.py。该文件在D:\mxnet\example\image-classification\文件夹下，是官方自带示例。 在61行中将gpus=None改成gpus=&#39;0&#39;即可用gpu运行代码，最终发现结果约为：0.981190。 使用小记mxnet自带可以将net画成pdf图的工具，但是需要配置相关库。 下面需按顺序安装 graphviz graphviz下载链接，博主下载的是zip文件并解压到D:\graphviz-2.38下。 接下来配置环境变量，在系统环境变量Path中添加值D:\graphviz-2.38\release\bin，保存关闭。 接下来以管理员身份运行cmd，由于博主anaconda是安装在C盘中，所以必须以管理员身份运行安装相关软件。 确保已经用conda安装好pip。 接下来输入如下代码安装： 12pip install graphvizpip install pydot 重启电脑，graphviz安装成功，至此再次声明，上面的安装顺序不能乱。 博主在路径D:\DLRVS\train\下创建自己的数据分类文件夹b和f，只有两类。 用mxnet自带的工具im2rec生成相关rec文件。im2rec.py在路径D:\mxnet\tools下。 在cmd中切换到路径D:\mxnet\tools下，使用im2rec.py先生成lst文件，然后再生成rec文件。 生成lst文件 1python im2rec.py --list True D:\DLRVS\yy D:\DLRVS\train\ --recursive True --shuffle True --train-ratio=0.8 在路径D:\DLRVS\下生成yy_train.lst，yy_val.lst，yy_test.lst文件。 1python im2rec.py D:\DLRVS\yy_train.lst D:\DLRVS\train --quality=100 在路径D:\DLRVS\下生成yy_train.rec文件，同样可以生成yy_val.rec和yy_test.rec文件。 以下是本人的测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import mxnet as mximport loggingimport numpy as npimport cv2import matplotlib.pyplot as pltimport osimport argparseimport loggingimport fitimport gzip, structdef get_iterators(batch_size,data_shape=(1,27,27)): train=mx.io.ImageRecordIter( path_imgrec="D:\DLRVS\yy_train.rec", mean_img="\DLRVS\mean.bin", data_name='data', label_name='softmax_label', batch_size=batch_size, data_shape=data_shape, shuffle=True, rand_crop=False, rand_mirror=True ) val= mx.io.ImageRecordIter( path_imgrec="D:\DLRVS\yy_val.rec", mean_img="D:\DLRVS\mean.bin", data_name='data', label_name='softmax_label', batch_size=batch_size, data_shape=data_shape, shuffle=True, rand_crop=False, rand_mirror=True ) return (train,val)def get_symbol(num_classes=10, **kwargs): data = mx.symbol.Variable('data') # first conv conv1 = mx.symbol.Convolution(data=data, kernel=(5,5), num_filter=20) tanh1 = mx.symbol.Activation(data=conv1, act_type="tanh") pool1 = mx.symbol.Pooling(data=tanh1, pool_type="max", kernel=(2,2), stride=(2,2)) # second conv conv2 = mx.symbol.Convolution(data=pool1, kernel=(5,5), num_filter=50) tanh2 = mx.symbol.Activation(data=conv2, act_type="tanh") pool2 = mx.symbol.Pooling(data=tanh2, pool_type="max", kernel=(2,2), stride=(2,2)) # first fullc flatten = mx.symbol.Flatten(data=pool2) fc1 = mx.symbol.FullyConnected(data=flatten, num_hidden=500) tanh3 = mx.symbol.Activation(data=fc1, act_type="tanh") # second fullc fc2 = mx.symbol.FullyConnected(data=tanh3, num_hidden=num_classes) # loss lenet = mx.symbol.SoftmaxOutput(data=fc2, name='softmax') return lenetdef fit(symbol,train,val,batch_size,num_gpus): devs=[mx.gpu(i) for i in range(num_gpus)] mod=mx.mod.Module(symbol=new_sym,context=devs) mod.bind(data_shapes=train.provide_data,label_shapes=train.provide_label) mod.init_params(initializer=mx.init.Xavier(rnd_type='gaussian',factor_type="in",magnitude=2)) mod.fit(train,val, num_epoch=1000, batch_end_callback=mx.callback.Speedometer(batch_size,10), optimizer='sgd', optimizer_params=&#123;'learning_rate':0.01&#125;, eval_metric='acc')if __name__ == '__main__': num_classes=2 batch_per_gpu=600 num_gpus=1 new_sym=get_symbol(num_classes=2) batch_size=batch_per_gpu*num_gpus (train,val)=get_iterators(batch_size) mx.viz.plot_network(new_sym).view() fit(new_sym,train,val,batch_size,num_gpus) 参考资料 从零开始学MXnet(一) mxnet深度学习实战：跑自己的数据实验和一些问题总结 mxnet学习记录 Mxnet学习系列 mxnet官网]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>mxnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我要你]]></title>
    <url>%2F2016%2F11%2F26%2F00040%E6%88%91%E8%A6%81%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[最近很喜欢听这首歌，主要是在学怎么弹啊，弹了好久都没连贯！！！]]></content>
      <categories>
        <category>音乐之声</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[女人如政治]]></title>
    <url>%2F2016%2F11%2F16%2F00048%E5%A5%B3%E4%BA%BA%E5%A6%82%E6%94%BF%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[女人如政治，自己想去吧！ 政治是不需要道德的政治是暴力或者实力征服政治是虚伪的政治是说一套做一套政治是讲究表面的装饰政治是要掩盖残酷真相的政治是需要给人远大幻想的政治是做了再说的]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Hexo中嵌入图片之七牛插件指北]]></title>
    <url>%2F2016%2F11%2F13%2F00033%E5%9C%A8Hexo%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87%E4%B9%8B%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[根据参考文献可以完成初步配置，不够完美，正在寻找新的替代插件（比较难用，博主已放弃）。 问题： 不能用hexo qiniu sync进行同步，在用hexo g -d也不能进行同步，需要将需要上传的image文件夹拷贝到public文件夹下，并在_config.yml文件中对sync_dir进行配置，则可以完成上传。 以上步骤还是麻烦，将待上传image文件夹拷贝到public文件夹下，在用hexo d命令时，图片也被上传到github中了，这违背了初始意愿，只能删除重复上传。 参考文献 hexo-deployer-qiniu 使用七牛在 Hexo 文档中嵌入图片]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django安装指北]]></title>
    <url>%2F2016%2F11%2F10%2F00010Django%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[前言近来突发兴致学习Django，初始根据教程学习，用内置服务器运行 1python manage.py runserver 在浏览器中输入 1http://127.0.0.1:8000 得到合适的页面，也是正确的页面。 但是，在Django的开发文档中也这么说明，runserver只作为开发用途，而不是发行用途。 所以，寻求用Apache来运行Django。 这也就带来了难题，即需要如题配置。经过大约一天的时间，各种谷歌、百度寻求帮助，排除一个个error终于配置成功。 现将过程介绍如下，防止以后再遇到此类问题。 我使用的是Ubuntu 14.04 LTS+Apache2.4+Python2或者3（根据mod_wsgi.so改变）+Django1.6或者以上 安装Apache等1sudo apt-get install apache2 libapache2-mod-wsgi python-django Apache配置 在/etc/apache2/中找到apache2.conf 在最后添加 1234567891011121314151617181920212223242526&lt;VirtualHost *:80&gt; ServerName hello.com DocumentRoot /var/www/yourproject &lt;Directory /var/www/yourprojec&gt; Order allow,deny Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 在/etc/apache2/sites-available/中添加wsgi.conf，在新创建的wsgi.conf中输入&lt;VirtualHost *:80&gt; ServerName wsgi.testserver DocumentRoot /var/www/yourproject &lt;Directory /var/www/yourproject&gt; Order allow,deny Allow from all &lt;/Directory&gt; WSGIScriptAlias / /var/www/django.wsgi &lt;/VirtualHost&gt; Django配置在/var/www/中创建django.wsgi，并在其中输入 1234567import osimport syssys.path.append('/var/www/yourproject')os.environ['DJANGO_SETTINGS_MODULE'] = 'yourproject.settings'from django.core.wsgi import get_wsgi_applicationapplication = get_wsgi_application() 测试输入 123sudo a2ensite wsgi.confsudo service apache2 reload 差不多成功了。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月下漫步]]></title>
    <url>%2F2016%2F11%2F10%2F00038%E6%9C%88%E4%B8%8B%E6%BC%AB%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[清冷的星光 不知今夜几更 漫步在桥头 留恋梦更深 难忘几段曲 轻叩夜门 你说今宵很美 不忍翻过这一夜 离经叛道的我们 都念这里虫声 云端的月牙偷笑尘世的凡人 却不懂自己的清冷 嫦娥孤寂 不再天下人 又是这个夜 早已物是人非 梧桐雨伴随脚步 敲打这不成文 想你的时候 默默呼唤 不敢更深 怕心碎 无端的烦躁 莫名的悲痛 花儿已凋谢 何时才能再开 只是独唱 寂寞沙洲冷 记忆已慢慢消逝 还留下什么 灯火辉煌的校园潜伏着这不知疲倦的老树 却已等不到灯下的人 昨天我们的温筑 早已变成别人的战场 避开熟悉的脸皮 僵硬的城池 踏过漫漫夜波 拥抱我身披的三世清辉 那些不愿说出的细节 就让她随风而去 绕过绿肥红瘦 追赶悄悄离开的雨 在深处 忆西窗烛影 一曲夜歌 祝福的哑语 你听到没？]]></content>
      <categories>
        <category>闲话桑麻</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MatConvNet安装指北]]></title>
    <url>%2F2016%2F11%2F10%2F00004MatConvNet%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[开发环境 Windows 10 VS2015/VS2013 Matlab 2016 MatConvNet各个版本 步骤解压下载后的文件夹到指定路径。假定为D:\matconvnet\ 在matconvnet下创建文件夹local，并将cudnn及文件夹下全部文件拷贝到local下。 在D:\matconvnet\matlab\下创建mex文件夹。 将local\cudnn\bin下的dll文件拷贝至mex文件夹下。 在Matlab工作环境下切换路径至D:\matconvnet\文件夹下，运行如下代码： 123run ./matlab/vl_setupnn.mvl_compilenn(&apos;enableGpu&apos;,true,&apos;enableCudnn&apos;,true,&apos;cudnnRoot&apos;,&apos;.\local\cudnn\&apos;); 至此安装成功。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>matconvnet</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vlfeat编译指北]]></title>
    <url>%2F2016%2F11%2F10%2F00022Vlfeat%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[首先下载源码文件解压至指定路径，例如C:\Users\colin\Documents\MATLAB。 查找C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20路径下发现有Makefile.mak文件。 打开菜单栏，找到Visual Studio Tools，双击打开VS2013 x64 本机工具命令提示。 在cmd中输入以下代码 12cd C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20nmake /f Makefile.mak 至此，发现输出信息最后几行为： 1234.... CC [MEX] toolbox\mex\mexw64\vl_aib.mexw64系统找不到指定的路径。NMAKE : fatal error U1077: “echo”: 返回代码“0x1”Stop. 不用管这些信息。 打开Matlab，切换路径至C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\。 在Matlab命令窗口中输入： 123vl_setupvl_compile 至此编译完成。 估计用nmake编译不成功是没有设置matlab路径。 切换matlab路径至C:\Users\colin\Documents\MATLAB\。 新建startup.m文件，在其中输入： 1run(&apos;C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\vl_setup.m&apos;); 这样就可以让matlab每次都启动vlfeat库。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>vlfeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visual-studio-2013编译64位boost]]></title>
    <url>%2F2016%2F11%2F09%2F00027visual-studio-2013%E7%BC%96%E8%AF%9164%E4%BD%8Dboost%2F</url>
    <content type="text"><![CDATA[开发环境 windows 10 visual studio 2013 ultimate boost 1.58 由于本人用1.61版本编译不成功，所以转战1.58版本。原因在visual studio 2013上，也许你用其他版本vs就能编译成功。 编译步骤编译64位进入开始菜单visual studio tools，找到VS2013 x64 本机工具命令提示，双击打开。 你会发现这就是一个cmd，而编译boost不是随便打开一个cmd就行的。编译64位需要打开这个cmd，而编译32位的需要打开VS2013 x86 本机工具命令提示这个cmd。 切换到你的boost根目录，例如我的在 1C:\local\boost_1_58_0 至此，你会发现在此路径下存在bootstrap.bat，在windows环境中只需运行call bootstrap.bat就会生成64位的b2.exe和bjam.exe。 接下来就是利用bjam.exe来编译。 如果需要获取动态库，编译命令如下： 1bjam --build-type=complete toolset=msvc-9.0 threading=multi link=shared address-model=64 以上是生成全部的lib，如果只生成需要的库，例如date_time，命令如下： 1bjam --with-date_time toolset=msvc-12.0 threading=multi link=static address-model=64 要有address-model=64属性，如果没有这个属性，会默认生成32位的平台库，加入这个选项才能生成64位的DLL。 如果需要获取静态库，编译命令如下： 1bjam --build-type=complete toolset=msvc-9.0 threading=multi link=static address-model=64 你会发现，这就是将link属性变为static。 也可以指定生成库的文件目录，例如： 1bjam --build-type=complete toolset=msvc-9.0 --stagedir="C:\boostLib" threading=multi link=shared address-model=64 编译32位编译32位库只需要将cmd换为VS2013 x86 本机工具命令提示然后和64位进行相同操作。 测试实例打开visual studio，创建工程。 编辑属性，打开配置属性 &gt; VC++目录，配置包含目录和库目录，接着打开配置属性 &gt; 链接器 &gt; 输入，在附加依赖项中添加lib。 1234libboost_chrono-vc120-mt-gd-1_58.liblibboost_system-vc120-mt-gd-1_58.liblibboost_thread-vc120-mt-gd-1_58.liblibboost_date_time-vc120-mt-gd-1_58.lib 我是编译的静态库，所以只需要在此添加所需的lib就可以了。如果生成的是动态库，还需要将dll所在的路径添加到系统路径path属性中，==重启==电脑使路径生效。 将visual studio的编译器换成x64。 至此，可以说环境配置完成，可以贴上测试代码运行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;boost/thread/condition.hpp&gt;#include &lt;boost/thread/mutex.hpp&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;iostream&gt;#include &lt;vector&gt;class bounded_buffer : private boost::noncopyable&#123;public: typedef boost::mutex::scoped_lock lock; bounded_buffer(int n) : begin(0), end(0), buffered(0), circular_buf(n) &#123; &#125; void send(int m) &#123; lock lk(monitor); while (buffered == circular_buf.size()) buffer_not_full.wait(lk); circular_buf[end] = m; end = (end + 1) % circular_buf.size(); ++buffered; buffer_not_empty.notify_one(); &#125; int receive() &#123; lock lk(monitor); while (buffered == 0) buffer_not_empty.wait(lk); int i = circular_buf[begin]; begin = (begin + 1) % circular_buf.size(); --buffered; buffer_not_full.notify_one(); return i; &#125;private: int begin, end, buffered; std::vector&lt;int&gt; circular_buf; boost::condition buffer_not_full, buffer_not_empty; boost::mutex monitor;&#125;;bounded_buffer buf(2);void sender() &#123; int n = 0; while (n &lt; 100) &#123; buf.send(n); std::cout &lt;&lt; "sent: " &lt;&lt; n &lt;&lt; std::endl; ++n; &#125; buf.send(-1);&#125;void receiver() &#123; int n; do &#123; n = buf.receive(); std::cout &lt;&lt; "received: " &lt;&lt; n &lt;&lt; std::endl; &#125; while (n != -1); // -1 indicates end of buffer&#125;int main()&#123; boost::thread thrd1(&amp;sender); boost::thread thrd2(&amp;receiver); thrd1.join(); thrd2.join();&#125; 参考文献 编译64位boost 新手，Visual Studio 2013 配置Boost库。 如何编译和选择，遇到无法打开文件“libboost_thread-vc120-mt-gd-1_58.lib的解决办法 boost官网]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地文件夹上传至github]]></title>
    <url>%2F2016%2F11%2F09%2F00013git%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[本文初衷是想将本地部分文件夹推送到github进行保存共享，折腾一番终于有所斩获，在此笔记以备后来参考。 开发环境 windows 10 git bash 步骤安装完git bash之后，就可以在git bash内进行各种操作。 右键Git Bash Here，你就会发现出现类似于linux的对话框，在这里你可以完全用linux指令来完成各种操作。 本文已经假设你已经安装好git bash，并且完成本地与远程账户的关联，如果还没有完成请右转google。 创建文件夹假设我的根路径在D盘，右键Git Bash Here。在其中输入： 123mkdir abccd abcgit init #这是用来初始化文件夹git 此时你会发现在D:/abc/下出现.git文件夹，这是用来与github关联的。 创建测试文件1234mkdir dirtouch aaatouch dir/aaagit add --all 添加远程Git1git remote add origin https://github.com/maxiaoyuelun/abc.git 假设你已经创建好远程名叫abc的仓库了，并且假设你在仓库你添加了README.md文件。 远程与本地合并12git commit -m 'merge'git pull origin master 至此你会在本地文件夹下发现多了README.md文件。 上传本地文件12git commit -m 'upload'git push -u origin master 在浏览器中打开就可以看到已经将本地文件夹内的内容上传至github中了。 在进行push和pull之前，必须进行commit，否则会有error。 删除文件1234git rm aaagit statusgit commit -m 'del aaa'git push -u origin master 其他对于文件的操作可在参考文献中寻找。 参考文献 Pro Git Git教程]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5.1开发博客系列一]]></title>
    <url>%2F2016%2F11%2F09%2F00016Laravel5-1%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B8%80%2F</url>
    <content type="text"><![CDATA[开发工具WampServer、PHPStorm、浏览器 开发前设置修改hosts文件打开“我的电脑”，进入 C:\Windows\System32\drivers\etc 目录，然后打开 hosts 文件，在最下面添加一行代码：127.0.0.1 maxiaoyuelun.cn，之后保存退出（可能需要管理员权限）。 启用WampServer虚拟域名功能进入 C:\wamp\bin\apache\apache2.4.9\conf 目录，打开apache配置文件 httpd.conf ，在里面搜索 httpd-vhosts.conf ，会找到下面这样一行：#Include conf/extra/httpd-vhosts.conf把最前面的 # 去掉（没有 # 的话直接进行下一步），保存并退出。 添加虚拟域名进入 C:\wamp\bin\apache\apache2.4.9\conf\extra 目录，打开 httpd-vhosts.conf文件，添加下面的代码： &lt;VirtualHost *:80&gt; ServerAdmin webmaster@laravel.dev DocumentRoot &quot;d:/wamp/www/laravel5/public&quot; ServerName laravel.dev ErrorLog &quot;logs/laravel.dev-error.log&quot; CustomLog &quot;logs/laravel.dev-access.log&quot; common &lt;/VirtualHost&gt; 至此，已经启用虚拟域名并添加好了虚拟域名，重启apache服务，在浏览器输入http://laravel.dev/，可以看到已经可以正常访问本地的Laravel 5了。 开发必要资源添加make:view参考artisan-view进行添加 添加AdminLTE在此之前需安装好bower进入C:\wamp\www\Laravel\public目录中，右击运行Use Composer Here，添加如下代码：bower install admin-lte参考文献：Integrate AdminLTE with Laravel 5 至此，初步准备阶段完成。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫抓取大伟吉他谱]]></title>
    <url>%2F2016%2F11%2F09%2F00026Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%A4%A7%E4%BC%9F%E5%90%89%E4%BB%96%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[喜欢用最近开始，最近由于个人需要，利用爬虫爬了一些东西，不得不说python是一大利器，只要你熟练之后，就可以随意创造你想要的大部分东西。插播点牢骚话，最近看网上的某些言论，实在是不敢苟同，说到创新，就似乎要打碎一切东西，从头再来，我所理解的创新是站在别人的基础上再做出自己的东西。首先，就需要对自己的领域熟悉，然后基于特定的需要，借用某种技术来实现目的。实际上，大部分的创新都是基于某种应用需求，当然前瞻性的理论创新也很重要，这里说的不是简单的一元论。 这篇博文是用python来爬取大伟吉他教室谱子的例程，在此笔记，加深印象。 环境windows 10，pycharm，anaconda，scrapy，google chrome 前言本文因为有特定的爬取目的，所以在很多步骤上就有了简化的处理。在开始前，需要利用chrome浏览器的调试功能找到需要爬取内容的位置：就是xpath位置，然后再进行编码测试。 步骤创建项目scrapy startproject tutorial 创建spiderscrapy genspider guitar guitar.com 代码编写上面两部就创建了guitar.py文件。 打开guitar.py文件，所示如下： 123456789101112import scrapyclass GuitarSpider(scrapy.Spider): name = "guitar" allowed_domains = ["guitar.com"] start_urls = ( 'http://www.guitar.com/', ) def parse(self, response): pass 添加代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-import scrapyimport requestsimport reclass GuitarSpider(scrapy.Spider): name = "guitar" allowed_domains = ["guitar.com"] start_urls = ( 'http://www.daweijita.com/59492.html', ) def parse(self, response): print "=================2==================" print response.headers for sel1 in response.xpath('//*[@id="main-content"]/div[2]/div[2]/div/div[1]'): for sel in sel1.xpath('.//a/@href').re(r'.*.gif$'): print "====" print sel print re.match(r'.*fufei.*',sel) if re.match(r'.*fufei.*',sel) is not None: print "$$$$$$$$$$$$$$$$$$$$$" s=sel.split('/') s2=s[-1].split('_') print s2 for num in range(1,5): s3=u'tab_'+s2[1]+u'_'+s2[2]+u'_'+u'%d' % num +u'.gif' print s3 s4=s[:-1]+[s3] print s4 s5=s4[0]+u'//'+s4[2]+u'/'+s4[3]+u'/'+s4[4]+u'/'+s4[5] local_filename = s3 r = requests.get(s5, stream=True) print r.status_code if r.status_code==200: with open(local_filename, 'wb') as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() else: local_filename = sel.split('/')[-1] r = requests.get(sel, stream=True) with open(local_filename, 'wb') as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() print "====" print "=================2==================" 在此就算简单完成了爬取工作。 小结多次测试之后，其实可以发现，该网站中的图片都是以这样的形式命名： tab_演唱者_歌曲名_数字.gif 也就是说，修改上面代码中的start_urls，定位到需要爬取的网站，可以爬取大部分的歌曲，但是如果碰到部分不一样的格式，则需要自己手动调试。 那么可以先定位到全站教学资源列表爬取歌曲以及演唱者，根据中英文适当转化为拼音，记录到items中保存，然后可以提取items中的信息进行组合来爬取所有曲谱，这在下面的文章中会完善。 参考文档 python菜鸟教程 scrapy中文文档 大伟吉他教室]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protobuf安装使用指南]]></title>
    <url>%2F2016%2F11%2F09%2F00028Protobuf%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[网址 https://github.com/google/protobuf/ 开发环境 Windows 10 企业版 64 位（10.0，版本14393） Visual Studio 2013 Git-2.10.1-64-bit.exe cmake-3.6.2-win64-x64.msi 安装步骤下载在官网下载protubuf，我将其下载解压到D:\Science\Google下 创建和编译在开始菜单找到Visual Studio Tools，点击。 在出现的文件中，双击VS2013 x64 本机工具命令提示。 切换路径到D:\Science\Google下。 在windows下切换路径直接使用D:回车即可，不需要cd命令。 之后按照教程 https://github.com/google/protobuf/blob/master/cmake/README.md 输入如下指令。 123456789mkdir installcd protobuf-mastergit clone -b release-1.7.0 https://github.com/google/googlemock.git gmockcd gmokegit clone -b release-1.7.0 https://github.com/google/googletest.git gtest 至此，安装成功gmoke。 下面进行编译，输入如下指令。 123456789cd cmakemkdir build &amp; cd buildmkdir solution &amp; cd solutioncmake -G "Visual Studio 12 2013 Win64" ^ -DCMAKE_INSTALL_PREFIX=../../../../install ^ ../.. 将会在solution文件夹下创建protobuf.sln。 生成双击打开protobuf.sln。 在生成工具下打开批生成，选中INSTALL Debug，关闭选项卡。 之后生成解决方案，静待几分钟之后，生成成功，发现在D:\Science\Google\install下出现需要的bin、include、lib等文件夹。 Release生成同理。 至此，install文件夹如下所示。 12345678910111213141516171819├─bin├─cmake├─include│ └─google│ └─protobuf│ ├─compiler│ │ ├─cpp│ │ ├─csharp│ │ ├─java│ │ ├─javanano│ │ ├─js│ │ ├─objectivec│ │ ├─php│ │ ├─python│ │ └─ruby│ ├─io│ ├─stubs│ └─util└─lib 上面的树状是用命令tree生成。 使用protobuf在此初步试用protobuf。 https://developers.google.com/protocol-buffers/ 中给出了使用指南。 本文简单给出一个例子，具体使用请查看手册。 为简单起见，在D:\Science\Google\install\bin下创建person.proto文件。 12345678910package Im;message helloworld&#123; requiredint32 id=1; requiredstring str=2; optionalint32 opt=3;&#125; 使用protoc.exe生成.h和.cc文件。 1protoc --cpp_out=D:\Science\Google\install\bin person.proto 即在D:\Science\Google\install\bin文件夹下生成person.pb.h和person.pb.cc文件。 打开visual studio 2013，创建空项目Person_。 新建main.cpp。在其中输入： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include "person.pb.h"using namespace std;int main()&#123; lm::helloworld msg1; msg1.set_id(100); msg1.set_str("200"); msg1.set_opt(50); cout &lt;&lt; msg1.id() &lt;&lt; endl; cout &lt;&lt; msg1.str() &lt;&lt; endl; cout &lt;&lt; msg1.opt() &lt;&lt; endl; cin.get(); return 0;&#125; 将person.pb.h和person.pb.cc文件拷贝到和main.cpp同样的路径下，并将这两个文件添加到工程中。 之后需要打开工程属性选项卡。 选择VC++目录。在包含目录中添加D:\Science\Google\install\include，在库目录中添加D:\Science\Google\install\lib。 选择链接器&gt;输入。在附加依赖项中添加libprotobufd.lib、libprotobuf-lited.lib、libprotocd.lib。 选择C/C++&gt;代码生成。将运行库中的多线程调试DLL(/MDd)替换为多线程调试(/MTd)。 至此可以编译生成。 如下所示 12310020050 至此，整个安装教程结束。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++输出到txt日志]]></title>
    <url>%2F2016%2F11%2F09%2F00007C%2B%2B%E8%BE%93%E5%87%BA%E5%88%B0txt%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[关于C++中使用fstream输出到文件中的部分操作 在编写程序的时候，常常需要将日志输出到类似txt的文件中，这时需要自己编写相关的代码。当用搜索引擎在网上进行搜索时，大多数给予的是有关C的代码，而对于C++的今天，何不用C++来简单实现这些功能呢？作为时代的进步，简化也就意味着高效。这以我在项目中的部分类似代码作为展示，请各位不吝赐教！抱拳！(用引用作为前言是不是不太好…) 工具： Visual Studio 2013 通常都会在工程中加入头文件#include 在这里是将日志输出到txt文件中。 例一 这是将数字输出到txt文件中，可供各位看官复制粘贴。 1234567891011void WriteToTxt(float value)&#123; ofstream outfile; outfile.open("D:\\log.txt", ios_base::app); if (outfile.is_open())&#123; outfile &lt;&lt; value &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "不能打开文件" &lt;&lt; endl; &#125;&#125; 例二 这是将文字输出到txt文件中，可供各位看官复制粘贴。 1234567891011void WriteToTxt(string s)&#123; ofstream outfile; outfile.open("D:\\log.txt", ios_base::app); if (outfile.is_open())&#123; outfile &lt;&lt; s &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "不能打开文件" &lt;&lt; endl; &#125;&#125; 例三 这是将文字和数字输出到txt文件中，可供各位看官复制粘贴。 12345678910void WriteToTxt(string s,float value)&#123; ofstream outfile; outfile.open("D:\\log.txt", ios_base::app); if (outfile.is_open())&#123; outfile &lt;&lt; s &lt;&lt; "="&lt;&lt;value&lt;&lt;endl; &#125; else&#123; cout &lt;&lt; "不能打开文件" &lt;&lt; endl; &#125;&#125; 鉴于以上组合，相信各位看官了解了如何利用C++进行文字的输出，输入请待下回分解。 关于C++中使用SYSTEMTIME获取当前时间的部分操作 在输出日志的时候，通常需要记录日志输出的发生时间，这就需要程序员自己调用内置函数。也许看官看到这已经发现这是有关调试的文章。好吧！我承认了！调试是软件开发过程中不可或缺的步骤，很重要！ 工具： Visual Studio 2013 通常都会在工程中加入头文件#include 在这里是将时间输出到txt文件中。 例子 这里只是简单实现，需要更好的看官可自行设计。 12345678910111213void GetTime()&#123; SYSTEMTIME sys; GetLocalTime(&amp;sys); ofstream outfile; outfile.open("D:\\log.txt", ios_base::app); if (outfile.is_open())&#123; outfile &lt;&lt; sys.wYear &lt;&lt; "/" &lt;&lt; sys.wMonth &lt;&lt; "/" &lt;&lt; sys.wDay &lt;&lt; " " &lt;&lt; sys.wHour &lt;&lt; "：" &lt;&lt; sys.wMinute &lt;&lt; "：" &lt;&lt; sys.wSecond &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "不能打开文件" &lt;&lt; endl; &#125; &#125; 到这里，本节基本结束了，至于函数中各个参数什么意思，相信搜索引擎会帮你的忙的。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA均值滤波]]></title>
    <url>%2F2016%2F11%2F09%2F00009CUDA%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[cuda进行均值滤波，主要blockIdx、blockDim、threadIdx等知识点。 main.h123#include&lt;time.h&gt;//时间相关头文件，可用其中函数计算图像处理速度 #include &lt;iostream&gt;#define datasize 80000 main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;opencv2\opencv.hpp&gt;#include "main.h"using namespace std;using namespace cv;extern "C" int runtest_img(int* host_a, int* host_b, int h, int w);int main()&#123; cout &lt;&lt; "Hello OpenCV CUDA" &lt;&lt; endl; Mat img = imread("me.jpg"); if (img.empty())&#123; cout &lt;&lt; "No \"me.jpg\"" &lt;&lt; endl; return -1; &#125; Mat gray_img; cvtColor(img, gray_img, CV_RGB2GRAY); imshow("Gray Image", gray_img); int rows = gray_img.rows; int cols = gray_img.cols; int channels = gray_img.channels(); cout &lt;&lt; "rows : " &lt;&lt; rows &lt;&lt; endl; cout &lt;&lt; "cols : " &lt;&lt; cols &lt;&lt; endl; cout &lt;&lt; "channels : " &lt;&lt; channels &lt;&lt; endl; int* host_img = new int[rows*cols]; int* host_output_img = new int[rows*cols]; for (int i = 0; i &lt; rows; i++)&#123; uchar* data = gray_img.ptr&lt;uchar&gt;(i); for (int j = 0; j &lt; cols ; j++)&#123; host_img[i*cols+j] = data[j]; &#125; &#125; cout &lt;&lt; host_img[(rows - 1)*cols + cols - 1] &lt;&lt; endl; long now1 = clock();//存储图像处理开始时间 runtest_img(host_img, host_output_img, rows, cols); printf("GPU运行时间为：%dms\n", int(((double)(clock() - now1)) / CLOCKS_PER_SEC * 1000));//输出GPU处理时间 Mat mean_filter_img(Size(cols, rows), CV_8U); for (int i = 0; i &lt; rows; i++)&#123; uchar* data = mean_filter_img.ptr&lt;uchar&gt;(i); for (int j = 0; j &lt; cols; j++)&#123; data[j]=host_output_img[i*cols + j]; &#125; &#125; imshow("Mean Filter Image", mean_filter_img); cvWaitKey(); return 0;&#125; kernel.cu123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include "cuda_runtime.h"#include "device_launch_parameters.h"#include "main.h"inline void checkCudaErrors(cudaError err)//错误处理函数&#123; if (cudaSuccess != err) &#123; fprintf(stderr, "CUDA Runtime API error: %s.\n", cudaGetErrorString(err)); return; &#125;&#125;__global__ void meanFilter(int *a, int *b, int h,int w)//处理核函数&#123; int tid = blockIdx.x*blockDim.x + threadIdx.x; int nx = blockIdx.x; int ny = threadIdx.x; if (nx &gt; 0 &amp;&amp; nx &lt; h-1 &amp;&amp; ny&gt;0 &amp;&amp; ny &lt; w-1)&#123; b[tid] = int((a[(blockIdx.x - 1)*blockDim.x + threadIdx.x - 1] + a[(blockIdx.x - 1)*blockDim.x + threadIdx.x +1] + a[(blockIdx.x +1)*blockDim.x + threadIdx.x - 1] + a[(blockIdx.x +1)*blockDim.x + threadIdx.x + 1]) / 4); &#125; //b[tid] = a[tid];&#125; extern "C" int runtest_img(int* host_a, int* host_b, int h, int w)&#123; int num = 0; cudaDeviceProp prop; checkCudaErrors(cudaGetDeviceCount(&amp;num)); for (int i = 0; i&lt;num; i++) &#123; cudaGetDeviceProperties(&amp;prop, i); &#125; int *dev_a, *dev_b; //int *dev_h, *dev_w; checkCudaErrors(cudaMalloc((void**)&amp;dev_a, sizeof(int)* h*w));//分配显卡内存 checkCudaErrors(cudaMalloc((void**)&amp;dev_b, sizeof(int)* h*w)); //checkCudaErrors(cudaMalloc((void**)&amp;dev_h, sizeof(int)));//分配显卡内存 //checkCudaErrors(cudaMalloc((void**)&amp;dev_w, sizeof(int))); checkCudaErrors(cudaMemcpy(dev_a, host_a, sizeof(int)* h*w, cudaMemcpyHostToDevice));//将主机待处理数据内存块复制到显卡内存中 checkCudaErrors(cudaMemcpy(dev_b, host_b, sizeof(int)* h*w, cudaMemcpyHostToDevice)); //checkCudaErrors(cudaMemcpy(dev_h, &amp;h, sizeof(int), cudaMemcpyHostToDevice));//将主机待处理数据内存块复制到显卡内存中 //checkCudaErrors(cudaMemcpy(dev_w, &amp;w, sizeof(int), cudaMemcpyHostToDevice)); meanFilter &lt;&lt;&lt;h, w &gt;&gt;&gt;(dev_a, dev_b, h,w);//调用显卡处理数据 checkCudaErrors(cudaMemcpy(host_b, dev_b, sizeof(int)* h*w, cudaMemcpyDeviceToHost));//将显卡处理完数据拷回来 cudaFree(dev_a);//清理显卡内存 cudaFree(dev_b); /*cudaFree(dev_h); cudaFree(dev_w);*/ return 0;&#125;]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c++</tag>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo静态站点搭建]]></title>
    <url>%2F2016%2F11%2F09%2F00005Hexo%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开发工具Windows，Notepad++，Node 搭建步骤安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中尚未安装所需要的程序，请自行安装。 其次需要创建Github Pages。至于如何创建，可自行谷歌，如博主有时间再更。 安装Hexo使用Git Bash输入： 1npm install -g hexo-cli 安装完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件目录如下： 12345678.├── _config.yml #网站配置信息，您可以在此配置大部分的参数。├── package.json #应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。├── scaffolds #模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source #资源文件夹是存放用户资源的地方。| ├── _drafts| └── _posts└── themes #主题 文件夹。Hexo 会根据主题来生成静态页面。 安装Next主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 在终端窗口下，定位到 Hexo 站点目录themes下。使用 Git Bash代码： 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 1theme: next 验证主题hexo自带服务器，输入： 1hexo server 即可在浏览器中查看。 Hexo部署Git命令123hexo cleanhexo ghexo d 其余部分可参考给出的参考文献，至于在Github Pages中使用自己的域名，需要在Repository中部署CNAME文件。 参考文档Hexo快速、简洁且高效的博客框架 Next精于心，简于形 hexo你的博客 知乎：如何搭建个人独立博客？]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab坐标系疑云]]></title>
    <url>%2F2015%2F12%2F20%2F00029matlab%E5%9D%90%E6%A0%87%E7%B3%BB%E7%96%91%E4%BA%91%2F</url>
    <content type="text"><![CDATA[编程中总会被matlab的奇怪坐标系坐标搞晕，在此笔记。 如上图所示，即是matlab图像格式，假设图像用I表示，那么在x轴100和y轴50处，读取图像的像素为I(50,100)，此即为matlab的坐标系格式。一般在figure中点击某点显示像素坐标，显示的是x轴和y轴的坐标，但是编写代码的时候就要反过来，注意注意。 另外，matlab的坐标系是从1开始的，而不是从0开始。]]></content>
      <categories>
        <category>技术堆栈</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F01%2F01%2F00000hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
