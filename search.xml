<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>李航统计学习截图</title>
      <link href="/2018/05/04/%E6%9D%8E%E8%88%AA%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE/"/>
      <url>/2018/05/04/%E6%9D%8E%E8%88%AA%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%88%AA%E5%9B%BE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p><img src="http://o7cub0jo9.bkt.clouddn.com/LiHang_MachineLearning.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>opencv调试</title>
      <link href="/2018/05/04/opencv%E8%B0%83%E8%AF%95/"/>
      <url>/2018/05/04/opencv%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>下载Image Watch插件，点击安装。</li><li>添加断点。</li><li>打开视图&gt;&gt;其他窗口&gt;&gt;Image Watch。</li><li>点击Local就可以实时查看图像的像素值，便于调试。</li></ol><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><a href="http://docs.opencv.org/doc/tutorials/introduction/windows_visual_studio_image_watch/windows_visual_studio_image_watch.html#windows-visual-studio-image-watch" target="_blank" rel="noopener">windows-visual-studio-image-watch</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visual studio </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客与工具推荐推荐</title>
      <link href="/2018/04/28/%E5%8D%9A%E5%AE%A2%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/04/28/%E5%8D%9A%E5%AE%A2%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文主要推荐一些博客链接和工具链接，以便查找，如果需要详细说明，会单开一篇来介绍相应的工具。</p></blockquote><a id="more"></a><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><ul><li><a href="https://github.com/stanzhai/be-a-professional-programmer" target="_blank" rel="noopener">be-a-professional-programmer</a></li></ul>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>创建碎碎念</title>
      <link href="/2018/04/26/%E5%88%9B%E5%BB%BA%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2018/04/26/%E5%88%9B%E5%BB%BA%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>创建碎碎念页面</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page murmurs</span><br></pre></td></tr></table></figure><p>在<code>next/source/css/_variables/base.styl</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*首先，我们要创建一个容器class*/</span><br><span class="line">.times &#123;display:block;margin:20px 0;&#125;</span><br><span class="line">/*利用ul标签的特性，设置外边框左移25px，左边边框是2px粗的实心线，颜色一般要浅一点*/</span><br><span class="line">.times ul &#123;margin-right:5px;margin-left:10px;border-left:1px solid #ddd;list-style-type:none;&#125;</span><br><span class="line">/*一般情况，通过li标签控制圆点回到时间线上，然后控制要出现的文字大小和是否粗体*/</span><br><span class="line">.times ul li &#123;width:100%;margin-left:-26px;line-height:20px;font-weight:narmal;&#125;</span><br><span class="line">.times ul li p &#123;margin-top:10px &#125;</span><br><span class="line">/*设置span标签的属性，让它来做时间显示，加一点边距，使时间显示离时间线远一点*/</span><br><span class="line">.times ul li span &#123;padding-left:7px;font-size:15px;line-height:20px;color:#555;margin-down:50px;&#125;</span><br><span class="line">/*注意这一行，前面的li标签后面加了一个:hover伪属性，意思是鼠标移上来，激活后面的属性，这样可以设置鼠标移动到整个时间范围的时候，时间点和时间显示会变色*/</span><br><span class="line">.times ul li:hover p &#123;border-bottom: 1px solid #000000;&#125;</span><br></pre></td></tr></table></figure><p>在<code>source/murmurs/index.md</code>中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;times&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;span&gt;2018-01-01&lt;/span&gt;&lt;p&gt;这里是2018年哟&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;span&gt;2017-01-01&lt;/span&gt;&lt;p&gt;这里是2017年哟&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;span&gt;2016-01-01&lt;/span&gt;&lt;p&gt;这里是2016年哟&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>至此，初步碎碎念完成。</p>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自动生成favcion</title>
      <link href="/2018/04/26/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90favcion/"/>
      <url>/2018/04/26/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90favcion/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>链接在此：<a href="https://www.favicon-generator.org/" target="_blank" rel="noopener">favicon-generator</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>下载旧版本VS</title>
      <link href="/2018/04/24/%E4%B8%8B%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%ACVS/"/>
      <url>/2018/04/24/%E4%B8%8B%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%ACVS/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>链接在此：<a href="https://www.visualstudio.com/zh-hans/vs/older-downloads/" target="_blank" rel="noopener">仍想使用较旧的版本？</a></p><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>自己编写CNN框架之零</title>
      <link href="/2018/04/19/%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99CNN%E6%A1%86%E6%9E%B6%E4%B9%8B%E9%9B%B6/"/>
      <url>/2018/04/19/%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99CNN%E6%A1%86%E6%9E%B6%E4%B9%8B%E9%9B%B6/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>终于下定决心自己编写CNN框架了，立FLAG了！！！</p></blockquote><p>参考链接：</p><ul><li><a href="http://hongbomin.com/2016/11/12/easycnn-design-history/" target="_blank" rel="noopener">EasyCNN的设计实现</a></li><li><a href="https://github.com/xylcbd/EasyCNN" target="_blank" rel="noopener">EasyCNN</a></li><li><a href="http://hongbomin.com/2018/03/03/zuo-si-de-hou-xu/" target="_blank" rel="noopener">Flag实现：C++从零开始开发深度学习框架</a></li><li><a href="https://github.com/PrincetonVision/marvin" target="_blank" rel="noopener">marvin</a></li><li><a href="http://marvin.is/" target="_blank" rel="noopener">marvin官网</a></li><li><a href="https://github.com/tiny-dnn/tiny-dnn" target="_blank" rel="noopener">tiny-dnn</a></li><li><a href="https://github.com/pjreddie/darknet" target="_blank" rel="noopener">darknet</a></li><li><a href="https://github.com/attractivechaos/kann" target="_blank" rel="noopener">kann</a></li></ul><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CUDA匹配SM和COMPUTE</title>
      <link href="/2018/04/18/CUDA%E5%8C%B9%E9%85%8DSM%E5%92%8CCOMPUTE/"/>
      <url>/2018/04/18/CUDA%E5%8C%B9%E9%85%8DSM%E5%92%8CCOMPUTE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>链接在此：<a href="https://github.com/tpruvot/ccminer/wiki/Compatibility" target="_blank" rel="noopener">Compatibility</a></p><p>Supported SM and Gencode variations<br>Below are the supported sm variations and sample cards from that generation</p><a id="more"></a><h3 id="Supported-on-CUDA-7-and-later"><a href="#Supported-on-CUDA-7-and-later" class="headerlink" title="Supported on CUDA 7 and later"></a>Supported on CUDA 7 and later</h3><p>####Fermi (CUDA 3.2 and later, deprecated from CUDA 9):</p><ul><li>SM20 or SM_20, compute_30 – Older cards such as GeForce 400, 500, 600, GT-630<br>####Kepler (CUDA 5 and later):</li><li>SM30 or SM_30, compute_30 – Kepler architecture (generic – Tesla K40/K80, GeForce 700, GT-730)<br>Adds support for unified memory programming</li><li>SM35 or SM_35, compute_35 – More specific Tesla K40<br>Adds support for dynamic parallelism. Shows no real benefit over SM30 in my experience.</li><li>SM37 or SM_37, compute_37 – More specific Tesla K80<br>Adds a few more registers. Shows no real benefit over SM30 in my experience<h4 id="Maxwell-CUDA-6-and-later"><a href="#Maxwell-CUDA-6-and-later" class="headerlink" title="Maxwell (CUDA 6 and later):"></a>Maxwell (CUDA 6 and later):</h4></li><li>SM50 or SM_50, compute_50 – Tesla/Quadro M series</li><li>SM52 or SM_52, compute_52 – Quadro M6000 , GeForce 900, GTX-970, GTX-980, GTX Titan X</li><li>SM53 or SM_53, compute_53 – Tegra (Jetson) TX1 / Tegra X1<h4 id="Pascal-CUDA-8-and-later"><a href="#Pascal-CUDA-8-and-later" class="headerlink" title="Pascal (CUDA 8 and later)"></a>Pascal (CUDA 8 and later)</h4></li><li>SM60 or SM_60, compute_60 – GP100/Tesla P100 – DGX-1 (Generic Pascal)</li><li>SM61 or <strong>SM_61, compute_61</strong> – GTX 1080, <strong>GTX 1070</strong>, GTX 1060, GTX 1050, GTX 1030, Titan Xp, Tesla P40, Tesla P4</li><li>SM62 or SM_62, compute_62 – Drive-PX2, Tegra (Jetson) TX2, Denver-based GPU<h4 id="Volta-CUDA-9-and-later"><a href="#Volta-CUDA-9-and-later" class="headerlink" title="Volta (CUDA 9 and later)"></a>Volta (CUDA 9 and later)</h4></li><li>SM70 or SM_70, compute_70 – Tesla V100</li><li>SM71 or SM_71, compute_71 – probably not implemented</li><li>SM72 or SM_72, compute_72 – currently unknown</li></ul>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next添加相册gallery</title>
      <link href="/2018/04/17/next%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8Cgallery/"/>
      <url>/2018/04/17/next%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8Cgallery/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>链接在此：<a href="https://github.com/iissnan/hexo-theme-next/pull/1989/files" target="_blank" rel="noopener">详细</a></p><a id="more"></a><p>主要作了如下修改：</p><h3 id="next-config-yml"><a href="#next-config-yml" class="headerlink" title="/next/_config.yml"></a>/next/_config.yml</h3><p>添加新版本的fancybox</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  # Internal path prefix. Please do not edit it.</span><br><span class="line">  _internal: lib</span><br><span class="line"></span><br><span class="line">  # Internal version: 2.1.3</span><br><span class="line">  jquery:</span><br><span class="line"></span><br><span class="line">  # Internal version: 2.1.5</span><br><span class="line">  # See: http://fancyapps.com/fancybox/</span><br><span class="line">  fancybox: https://cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js</span><br><span class="line">  fancybox_css: https://cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css</span><br></pre></td></tr></table></figure><h3 id="next-layout-macro-post-swig"><a href="#next-layout-macro-post-swig" class="headerlink" title="/next/layout/_macro/post.swig"></a>/next/layout/_macro/post.swig</h3><p>找到如下代码修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;# Gallery support #&#125;</span><br><span class="line">&#123;% if post.photos and post.photos.length %&#125;</span><br><span class="line">&lt;div class=&quot;post-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt;</span><br><span class="line">  &#123;% set COLUMN_NUMBER = 3 %&#125;</span><br><span class="line">  &#123;% for photo in post.photos %&#125;</span><br><span class="line">    &#123;% if loop.index0 % COLUMN_NUMBER === 0 %&#125;&lt;div class=&quot;post-gallery-row&quot;&gt;&#123;% endif %&#125;</span><br><span class="line">    &#123;###原始代码开始</span><br><span class="line">      &lt;a class=&quot;post-gallery-img fancybox&quot;</span><br><span class="line">         href=&quot;&#123;&#123; url_for(photo) &#125;&#125;&quot; rel=&quot;gallery_&#123;&#123; post._id &#125;&#125;&quot;</span><br><span class="line">    原始代码结束###&#125;</span><br><span class="line">      &lt;a class=&quot;post-gallery-img&quot; data-fancybox=&quot;gallery_&#123;&#123; post._id &#125;&#125;&quot;</span><br><span class="line">         href=&quot;&#123;&#123; url_for(photo) &#125;&#125;!gumini&quot;</span><br><span class="line">         itemscope itemtype=&quot;http://schema.org/ImageObject&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;&#123;&#123; url_for(photo) &#125;&#125;!guresize&quot; itemprop=&quot;contentUrl&quot;/&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &#123;% if loop.index0 % COLUMN_NUMBER === 2 %&#125;&lt;/div&gt;&#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;# Append end tag for `post-gallery-row` when (photos size mod COLUMN_NUMBER) is less than COLUMN_NUMBER #&#125;</span><br><span class="line">  &#123;% if post.photos.length % COLUMN_NUMBER &gt; 0 %&#125;&lt;/div&gt;&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><h3 id="next-source-js-src-utils-js"><a href="#next-source-js-src-utils-js" class="headerlink" title="/next/source/js/src/utils.js"></a>/next/source/js/src/utils.js</h3><p>找到如下代码修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Wrap images with fancybox support.</span><br><span class="line">*/</span><br><span class="line">wrapImageWithFancyBox: function () &#123;</span><br><span class="line">$(&apos;.content img&apos;)</span><br><span class="line">  .not(&apos;[hidden]&apos;)</span><br><span class="line">  .not(&apos;.group-picture img, .post-gallery img&apos;)</span><br><span class="line">  .each(function () &#123;</span><br><span class="line">    var $image = $(this);</span><br><span class="line">      /*var imageTitle = $image.attr(&apos;title&apos;);原始*/</span><br><span class="line">      var $imageWrapLink = $image.parent(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">      if ($imageWrapLink.size() &lt; 1) &#123;</span><br><span class="line">          var imageLink = ($image.attr(&apos;data-original&apos;)) ? this.getAttribute(&apos;data-original&apos;) : this.getAttribute(&apos;src&apos;);</span><br><span class="line">        $imageWrapLink = $image.wrap(&apos;&lt;a href=&quot;&apos; + imageLink + &apos;&quot;&gt;&lt;/a&gt;&apos;).parent(&apos;a&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // $imageWrapLink.addClass(&apos;fancybox fancybox.image&apos;);</span><br><span class="line">      // $imageWrapLink.attr(&apos;rel&apos;, &apos;group&apos;);</span><br><span class="line">      //</span><br><span class="line">      // if (imageTitle) &#123;</span><br><span class="line">      //   $imageWrapLink.append(&apos;&lt;p class=&quot;image-caption&quot;&gt;&apos; + imageTitle + &apos;&lt;/p&gt;&apos;);</span><br><span class="line">      //</span><br><span class="line">      //   //make sure img title tag will show correctly in fancybox</span><br><span class="line">      //   $imageWrapLink.attr(&apos;title&apos;, imageTitle);</span><br><span class="line">      if (!$imageWrapLink.attr(&apos;data-fancybox&apos;)) &#123;</span><br><span class="line">          $imageWrapLink.attr(&apos;data-fancybox&apos;, &apos;group&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  // $(&apos;.fancybox&apos;).fancybox(&#123;</span><br><span class="line">  //   helpers: &#123;</span><br><span class="line">  //     overlay: &#123;</span><br><span class="line">  //       locked: false</span><br><span class="line">  //     &#125;</span><br><span class="line">  //   &#125;</span><br><span class="line">  $(&apos;[data-fancybox]&apos;).fancybox(&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>至此修改初步完成，后续如果需要添加，再按照上文给出的链接进行修改，本文到这一步已经够了，后面考虑自动加载云端图片文件！！！<br>🚩🚩🚩</p>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo主题开发经验之谈</title>
      <link href="/2018/04/17/hexo%E4%B8%BB%E9%A2%98%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
      <url>/2018/04/17/hexo%E4%B8%BB%E9%A2%98%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><a href="https://molunerfinn.com/make-a-hexo-theme/#%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">hexo主题开发经验之谈</a></p><p><a href="http://chensd.com/2016-06/hexo-theme-guide.html" target="_blank" rel="noopener">hexo主题开发指南</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Intellij_idea激活</title>
      <link href="/2018/04/17/Intellij-idea%E6%BF%80%E6%B4%BB/"/>
      <url>/2018/04/17/Intellij-idea%E6%BF%80%E6%B4%BB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>链接在此：<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA 注册码</a></p><p>学生可免费申请使用：<a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">学生授权申请方式</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij Idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo主题prince</title>
      <link href="/2018/04/16/hexo%E4%B8%BB%E9%A2%98prince/"/>
      <url>/2018/04/16/hexo%E4%B8%BB%E9%A2%98prince/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>推荐一个hexo主题</p><p>链接在此：<a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank" rel="noopener">hexo-theme-prince</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo文章推荐</title>
      <link href="/2018/04/16/hexo%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/04/16/hexo%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>hexo跨博客文章推荐插件</p><p>链接在此：<a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">hexo-recommended-posts</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next豆瓣插件</title>
      <link href="/2018/04/16/next%E8%B1%86%E7%93%A3%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/04/16/next%E8%B1%86%E7%93%A3%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>推荐一个使用插件将豆瓣电影、读书和游戏自动部署到自己的github博客上。</p><p>链接在此：<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">hexo-douban</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows安装pytorch</title>
      <link href="/2018/04/05/windows%E5%AE%89%E8%A3%85pytorch/"/>
      <url>/2018/04/05/windows%E5%AE%89%E8%A3%85pytorch/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>江湖传言，tensorflow适合工业，pytorch适合科研，所以，来一波呗</p><a id="more"></a><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://blog.csdn.net/xiangxianghehe/article/details/78736482" target="_blank" rel="noopener">Windows下安装PyTorch0.3.0</a></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Love Like Magic</title>
      <link href="/2018/03/27/Love-Like-Magic/"/>
      <url>/2018/03/27/Love-Like-Magic/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>翻到这么首歌，还不错！！！</p></blockquote><a id="more"></a><!--<iframe width="816" height="623" src="https://static.hdslb.com/miniloader.swf?aid=2956284&p=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>-->]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 张国荣 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>朝鲜战争基本常识问答</title>
      <link href="/2018/03/26/%E6%9C%9D%E9%B2%9C%E6%88%98%E4%BA%89%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94/"/>
      <url>/2018/03/26/%E6%9C%9D%E9%B2%9C%E6%88%98%E4%BA%89%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h4 id="一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？"><a href="#一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？" class="headerlink" title="一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？"></a>一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？</h4><p>答：非也！三八线是1945年8月由美国提出，以朝鲜国土北纬三十八度线作为美、苏两国对日军事行动和受降范围的临时分界线，三八线以北为苏军接受日军投降区，以南为美军受降区。三八线是一条受降临时分界线，仅此而已。说这条线是“国际公认”的朝鲜南北的政治分治线，没有任何国际法依据，而且不为朝鲜半岛南北双方政权所承认。</p><p>换言之，三八线具有约束苏美军队的意义，却没有约束朝鲜半岛南北双方的意义。中国领导人决策出兵参战的前提是“美国军队越过三八线”，而不是“韩国军队越过三八线”，这是原因之一。而美国军队率先越过三八线，是打破这个约束的始作俑者。</p><a id="more"></a><h4 id="二、朝鲜战争是北方侵略了南方吗？"><a href="#二、朝鲜战争是北方侵略了南方吗？" class="headerlink" title="二、朝鲜战争是北方侵略了南方吗？"></a>二、朝鲜战争是北方侵略了南方吗？</h4><p>答：朝鲜战争是一场以民族统一为目的的内战，没有“侵略”不“侵略”之分。正如中国国共内战既不能说国民党侵略了共产党，也不能说共产党侵略了国民党，美国内战既不能说南方侵略了北方，也不能说北方侵略了南方一样。美国军队直接介入朝鲜内战，才是名符其实的“侵略”行为。</p><h4 id="三、联合国是否有权利干预朝鲜内战？"><a href="#三、联合国是否有权利干预朝鲜内战？" class="headerlink" title="三、联合国是否有权利干预朝鲜内战？"></a>三、联合国是否有权利干预朝鲜内战？</h4><p>答：没有权利。联合国是一个国际组织，不是“世界政府”。与一个国家的政府有着本质的区别，它没有干预一个国家内部事务权利和依据。实际上，《联合国宪章》就明确规定：“不得干涉本质上属于任何国家内部管辖之事件”。联合国安理会关于武装干预朝鲜的决议是在安理会常任理事国有缺席，而美国军队已经先斩后奏率先介入的情况下作出的，开了一个毫无道理的先例，是一个非法决议。所以从朝鲜战争以后，再也没有“联合国军”名义的军事行动，就是这种方式已为历史进程所否定的反证。</p><p>尤其需要特别说明的是，朝鲜南北方政权都没有加入联合国，都不是联合国成员国，联合国出兵干预，不伦不类，无根无基，没有任何法理依据，本身就是对《联合国宪章》的粗暴践踏。</p><h4 id="四、“联合国军”是一支维持和平部队吗？"><a href="#四、“联合国军”是一支维持和平部队吗？" class="headerlink" title="四、“联合国军”是一支维持和平部队吗？"></a>四、“联合国军”是一支维持和平部队吗？</h4><p>答：不是！“联合国维持和平行动”的概念产生于朝鲜战争之后，而且有其特定涵义和规范。联合国成立之时，就设有军事观察员，并逐步形成了维和部队，在1956年建立第一支联合国维和部队时，联合国秘书长哈马舍尔德曾经提出了著名的维和三原则：</p><p>第一，维和行动不得妨碍有关当事国之权利、要求和立场，需保持中立，不得偏袒冲突中的任何一方；</p><p>第二，维和行动必须征得有关各方的一致同意才能实施；</p><p>第三，维和部队只携带轻武器，只有自卫时方可使用武力。</p><p>人们把这三项原则概括为中立的原则、同意的原则和自卫的原则，并称之为哈马舍尔德三原则。哈马合尔德三原则是联合国传统维和行动的基本准则。80年代未期以前的维和行动，都是以哈马舍尔德三原则为基本依据的。哈马吉尔德三原则对联合国近四十年的维和行动具有重要的指导意义。秘书长啥马舍尔德之所以就联合国维和行动提出这三项基本原则，主要是因为联合国建立时制定的《联合国宪章》没有关于维和行动的规定。以哈马舍尔德原则为基础，传统维和行动大体遵循以下一些基本原则：</p><p>1.维和行动由联合国安理会授权和组织．特殊情况下由联合国大会组织，具体由秘书长控制和指挥。</p><p>2.维和行动必须征得冲突各方政府以及直接有关的各方的同意。具体讲，维和部队的规模、进驻的起始和结束时间、进驻的地域等部必须征得有关各方的一致同意特别是进驻国的同意。</p><p>3.维和部队的军事人员由会员国自愿提供。军事观察员不携带武器、维和部队携带轻型防御性武器。</p><p>4.维和部队除自卫外，不得使用武力。</p><p>5.严守中立。不能支待一方反对另一方。</p><p>6.不得干涉驻在国内部事务，不能介入内部冲突。</p><p>“联合国军”的决策和行动不符合其中任何一条。</p><h4 id="五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？"><a href="#五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？" class="headerlink" title="五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？"></a>五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？</h4><p>答：中国有句老话：察其言，观其行。美国军队事实上已经侵犯了中国领土（台湾），介入了中国内战（出兵台湾即介入中国内战），而且其地面武装力量已经越过三八线直趋中国国门，“联合国军”总司令已经提出：“无论如何，如果我们不去利用鸭绿江的自然防御功能，那么这种西部低洼，东中部崎岖的地形是不适于我们的防御体系的。这条江是整个朝鲜绝无仅有的天然屏障，但如果仅仅依赖于此作为唯一的天然防线，则无论是军事还是政治的防御能力都不足以维护韩国的领土完整。……只是占领鸭绿江以南地区旋即停止推进，我们根本就不可能找到一个可有效控制所有通向北朝鲜的路径的位置”。</p><p>而同时期，美国空军的炸弹已经落到中国的城市和乡村。这已经不是意图而是实实在在的事实，这在任何一个国家包括美利坚合众国自己，都绝不会视为一种友好表示而只能认为是不怀好意的侵略行动。</p><p>美国前国务卿亨利·基辛格先生也曾在其著作《大外交》中指出：“毛泽东有理由认为，如果他不在朝鲜阻挡美国，他或许会在中国领土上与美军交战。最起码，他没有理由去作出相反的结论。”</p><p>1989年5月5日，美国军事历史学家约翰·托兰（著有《漫长的战斗》）在中国人民解放军军事科学院与他的中国同行们交流时说：“中国出兵朝鲜是出于国家利益的考虑，是不得已的。如果苏联打到墨西哥，那么美国在5分钟之内就会决定出兵。”</p><h4 id="六、中国军队出兵援朝的决策真正原因是什么？"><a href="#六、中国军队出兵援朝的决策真正原因是什么？" class="headerlink" title="六、中国军队出兵援朝的决策真正原因是什么？"></a>六、中国军队出兵援朝的决策真正原因是什么？</h4><p>答：保家卫国！中国人民志愿军入朝参战，是在中国领土主权受到侵犯，“联合国军”打到鸭绿江边，战火已烧到中国边境城市的情况下发生的，是侵略凶焰已经直接威胁到我们的国家安全环境的情况下发生的，是在中国政府再三警告言之有预有理有节先礼后兵而侵略者仍然置若罔闻肆无忌惮得寸进尺一意孤行的情况下发生的。严肃一点的美国学者或军人──既或是与中国军队交过手的美国军人，都不否认中国军队出兵援朝的合理性。</p><p>其次，对盟友和战友危难之际履行一个社会主义大国的国际主义义务也是一个重要原因，弱者对付强者最有效的武器就是自身的团结与互助，一个负责任的社会主义大国首先应该对自己的战友和盟友负责！受人涓埃之恩，必当涌泉相报，这是中华民族代代传承的道义火矩和优良传统，中朝两国人民在过去反对帝国主义侵略的共同斗争曾经相濡以沫相互支援共挽民族危亡，中国人民革命斗争的旗帜也浸染着朝鲜志士的鲜血，共同的境遇共同的命运使中朝两大民族同病相怜，共同的利益共同的愿望使中朝两国人民生死相依。可以说，没有任何两个毗邻民族能够比中朝两大民族更能深刻体验和感受唇亡齿寒之迫，户破堂危之急。勿需对历史作太久远的回顾，灭亡了朝鲜的日本得寸进尺染指中国最终迫使中华民族发出“最后的吼声”，对中国人民就足具史鉴来者之功效。</p><h4 id="七、中国军队出兵援朝延缓了解放台湾吗？"><a href="#七、中国军队出兵援朝延缓了解放台湾吗？" class="headerlink" title="七、中国军队出兵援朝延缓了解放台湾吗？"></a>七、中国军队出兵援朝延缓了解放台湾吗？</h4><p>答：这种说法颠倒了因果关系，中国军队出兵援朝是在美国军队进占台湾之后，阻碍中国人民完成祖国统一大业的是美国军队。这个因果关系应该不难分清。</p><h4 id="八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？"><a href="#八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？" class="headerlink" title="八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？"></a>八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？</h4><p>答：没有道理。打个比方，你向银行货款购房，银行是否因此就要对你终生的行为和经济状况负责？你购了房，银行得了利，你后来又把房卖了，银行是否必须为你的卖房行为负责？或者再打个比方，你见义勇为救了一个人，是否意味着你必须对此人此后所有行为负责？更何况，朝鲜民主主义人民共和国在安全环境受到了严重威胁，生存环境受到了严重制约的情况下，取得举世瞩目的建设成就，朝鲜人民既或在经济上遭受了严重困难的日子里仍然享受着令世人羡慕的各种基本福利制度，劳动群众的基本生存权利得到了相当切实有效的保障，这也是不容忽视的事实！</p><h4 id="九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？"><a href="#九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？" class="headerlink" title="九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？"></a>九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？</h4><p>答：没有道理。</p><p>第一，来而不往非礼也，寇能往，我亦能往！</p><p>第二，除恶务尽，第二次世界大战中，苏美英军队直捣柏林为中国军队作出了极好的榜样。至于没有达到这个目的，那是中国军队本事不够，家伙也不行，与该不该打过去没有关系！</p><p> 第三，三八线的本质涵义是只有约束美苏的意义，而无约束其它人的意义。</p><h4 id="十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。"><a href="#十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。" class="headerlink" title="十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。"></a>十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。</h4><p>答：此问与第七问一样，属因果颠倒。再者，战争胜利鼓舞了人民斗志，在抗美援朝战争期间，中国完成了国民经济恢复，在近代史上，第一次将军费降到了国家财政支出的一半以下，同时还完成了清匪反霸，消灭百万国民党残余部队，进军西藏完成祖国大陆统一的壮举。应该说抗美援朝促进了新中国的建设。至于对外开放交流，抗美援朝战争为三十年后的改革开放奠定了安全环境。没有志愿军将士用枪炮与霸权实现的交流，就没有后来在平等基础上的和平对话。没有“打”开路，就没有“和”临头！对强权者，敢战，方能言和！</p><h4 id="十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？"><a href="#十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？" class="headerlink" title="十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？"></a>十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？</h4><p>答：没有！德国是第二次世界大战的战败国，不光要享受盟国分区占领的待遇，还要接受盟国的强行管制。1945年6月5日，苏美英法在柏林签署了击败德国、对德分区占领和管制德国的三个宣言，决定了德国彻底的非武装化和非军事化的问题，明确了盟国有权在德国任何部分或全部驻扎军队及设置民事机构，行使最高权力。同是也明确了盟国可以采取他们认为对于和平与安全所需要的步骤。</p><p>而朝鲜是日本帝国主义的殖民地，是帝国主义侵略战争的受害者而不是加害者，朝鲜人民在反法西斯战争胜利后理应获得独立自由和解放——这也是开罗宣言中包括美国在内的各大国为之作出的承诺，而不是占领、约束和强行管制，更不是再次受到侵略战争的戗害！</p><h4 id="十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？"><a href="#十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？" class="headerlink" title="十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？"></a>十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？</h4><p>答：这是一个低智商问题，与当今时髦的市场经济理念格格不入——这与做生意的道理一样，大本钱挣大钱，小本钱挣小钱，不能因为有大本钱的挣了大钱，只有小本钱的连小钱也不挣了——更何况挣来的还未必是小钱。比如第二次世界大战中国出了大力，占的便宜不大，甚至还被人出卖权益，而美国人却占了大便宜，那么是否可以认为中国抗战也是错误的？</p><h4 id="十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？"><a href="#十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？" class="headerlink" title="十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？"></a>十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？</h4><p>答：又是一个低智商问题。谁规定了别人打我头我也只能打他头的道理？德国轰炸英国的脑袋伦敦，邱吉尔却在打量人家“柔软的下腹部”。同理，美国人卡中国人脖子，中国人就朝踢美国人的裤裆狠命一脚——如此而已！</p><h4 id="十四、有人占了中国的外蒙古，中国为什么不出兵？"><a href="#十四、有人占了中国的外蒙古，中国为什么不出兵？" class="headerlink" title="十四、有人占了中国的外蒙古，中国为什么不出兵？"></a>十四、有人占了中国的外蒙古，中国为什么不出兵？</h4><p>答：新中国接过的是国民党反动政府的破产家业，同时也承担了国民党反动政府留下的历史债务，而且也尽其可能清理得足够干净了。新中国必须为已经取得的国家利益以及能够争取到的国家权益承担全责，世人没有理由要求他们能够清偿所有的历史债务——尤其是扔下这个破产家业再也不承但任何实际责任的前朝败家子！</p><h4 id="十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！"><a href="#十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！" class="headerlink" title="十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！"></a>十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！</h4><p>答：不胜其理！即或此说前提成立，推论仍属荒谬。评价战争胜负的首要前提是战争的目的达到与否及达到的程度，而不仅仅是人头账。苏德战争德军伤亡低于苏军，是否可以认为德军是胜利者？越南战争越南军民伤亡200～300万，美军伤亡30余万，美国人是否敢说自己是胜利者？</p><p>另外，中朝军队面对的是整个“联合国军”和韩军，做算术题时忽略这些被加数，是一种难以原谅的选择性遗忘！</p><h4 id="十六、毛泽东送儿子上前线是镀金。"><a href="#十六、毛泽东送儿子上前线是镀金。" class="headerlink" title="十六、毛泽东送儿子上前线是镀金。"></a>十六、毛泽东送儿子上前线是镀金。</h4><p>答：既然这是个天大的好事儿，将来再有战争或抗洪救灾之类的好事情时，建议首先安排出此语者自己或其儿女到炮火下或洪水中去镀它一金，或烈火焚身，或洪水没顶？新中国决定出兵入朝参战时，连许多身经百战的将帅都没有把握一定胜利，新中国领导人甚至还准备应付美国军队进入中国——“就当中国革命晚胜利几年”！如果有人硬要说毛泽东此时送子上前线是去“镀金”，那不是卯足了劲儿在夸毛泽东料事如神，硬把毛泽东再往神坛上推么？</p><p>再者，如果毛泽东不送儿子上前线呢？你是否能够接受而不再赘言？你又会不会诅咒毛泽东让别人的孩子当炮灰，自家儿子在家躲清闲？横竖毛泽东都是一肚子私欲？而毛岸英就因为有毛泽东这个老子，横竖都该死，——哪怕他是为国捐躯？</p><p>这还有理可讲么？不是天赋人权么？不是上帝面前人人平等么？哪儿去啦？</p><h4 id="十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！"><a href="#十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！" class="headerlink" title="十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！"></a>十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！</h4><p>答：这是幼儿智力问题且有睁眼瞎之嫌！美利坚合众国正规军劈头盖脑挨了一顶臭揍，明知出招者乃货真价实训练有素的中国正规八路，却仍然忍气吞声不敢堂而皇之宣战接招，不光是胆小，且已气短。至于中国人为何使用志愿军名义，那是中国人民高兴中国人民愿意，中国人民乐意在没有官方名义的前提下充分表达自己的“自由意志”。</p><h4 id="十八、中国军队有苏联撑腰，胜之不武！"><a href="#十八、中国军队有苏联撑腰，胜之不武！" class="headerlink" title="十八、中国军队有苏联撑腰，胜之不武！"></a>十八、中国军队有苏联撑腰，胜之不武！</h4><p>答：中国军队将美国军队从鸭绿江赶回三八线，基本上凭的是手中的“万国牌武器”。苏式武器是运动战后期四五次战役才开始陆续装备部队，苏联空军只掩护清川江以北部分交通线，且大规模参战是在五一年夏季以后，而此时战场大格局已经奠定。</p><p>另外，国民党军队有美国家伙撑腰还有力量优势，仍然败到了台湾？是不是败之很武？</p><p>顺便说一句，美国军队有联合国旗号壮胆，却被迫与人议和，与之对等议和者还是一个根本不被联合国承认的国家，实在是和之无脸！</p><h4 id="十九、中国军队打人海战术，胜之不武！"><a href="#十九、中国军队打人海战术，胜之不武！" class="headerlink" title="十九、中国军队打人海战术，胜之不武！"></a>十九、中国军队打人海战术，胜之不武！</h4><p>答：战争是一种资源较量。各打各的资源，穷人的资源是人，富人的资源是钱──钱能买来“火海战术”。中国军队在“火海战术”下还能集中和机动优势兵力打歼灭战，是战争指导艺术高超的体现。中国军队战略上是“人海战术”，战术上是“小兵群战术”，对此，前美第八集团军司令官马克斯韦尔·泰勒将军对中国军队有极高评价。</p><h4 id="二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。"><a href="#二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。" class="headerlink" title="二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。"></a>二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。</h4><p>答：同意！所以说“好战必亡”的道理应该多讲给战争能力极其强大而自身受战争戗害极少的国家听。“忘战必倾”的道理应该多讲给战争能力不够强大且自身受战争戗害极多的国家听。具体地说，军事机器最强大而自身受战争戗害极少的美利坚合众国不应津津乐道过去的战争，而要多听听“好战必亡”的道理；军事机器不够强大且自身受战争戗害太多的中华人民共和国需要多多回顾过去的战争，且须多念念“忘战必倾”的道理。这样才有可能避免战争再起。 </p><h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h4><p>朝鲜战争：1950年6月—1953年7月，是<a href="http://baike.baidu.com/view/119146.htm" target="_blank" rel="noopener">朝鲜半岛</a>上的朝韩之间的民族内战。</p><p>抗美援朝：1950年10月—1953年7月，是中国人民支援朝鲜人民抗击美国侵略的群众性运动。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说话</title>
      <link href="/2018/03/25/%E8%AF%B4%E8%AF%9D/"/>
      <url>/2018/03/25/%E8%AF%B4%E8%AF%9D/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Welcome to my blog, enter password to read. "/> <label for="pass"> Welcome to my blog, enter password to read. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19hA3bBt+ltn41XiFiHQVovLpSE2L/tiOFfkyICXIgH4Jvpk+dj+eIqh10RKxKdC4kRmUl3HubiVhe0L8yGKcmawJ5fnZhZ4thUNRXDfrUVOnIW/I0qNwK/AjG/ZcahZmWZEPsDjI9QVvOtNgb37IVj3ReYDotPqQDIMYlRWKP32CblFdUSpYOQrj3m1IqN0RIhrzxxeis4VnEzkQJBmhoc1z2rjBKhoqdR9tHcw7FMzLOvgS2hOl3Uuet/yKobKTEHDtC3FnfLNmWgxisysRx9jZc764JhW5PThUYDkO9dqtbv7qTez6uFHWtanlad3Kp65OMrdRIgD0Y5Ms+uvhSBadz7Q6hCW4po3SMpNfmy4wtKt2XQUBDERQ5VYyvSfSDxaWuuvp5HIv31fghnLebqoCGwAAJGyAuJ7DTkxFP3bAqtAzTY0v/ejJWRKz36hSFpiHMpUgk9GCZi5M5BqRsvR2hkbo38glNQZhWZkunWjKJ7peV5z1JAmRUyouuE4NAlJWgu3nSfdrDoxv1ghqNvXEXIWgOYA5BnfJf3MwkBmC8VsLuCoLTCy2MFM4z8uhepKQFmYNYiTUxHH8bdWzjK5ZNAt069BVWtt8J/zG0mVVG4exsLrUUeilyp1Gucr02vBPixa6/uNCnYJWOErarkrrHi1TumbT5X0M2DERcXgxXOxj2UESj/izvxQECyUl//Oe3qxM2AjkH7IK4tDkX/i8IkhLGKQI1/qmVUKPVI/Eb366VjEyy8CkheN6ENYbzeOop63dkDh7y1sQkKu+NhQGZ1v/YrAIsp+2D55n9s/xSKgQauGxM3rUDrYgQbUnhx1q7sErBMOf9eTUO+NDur7YeyCN8PqawsaK9cuoZrlvRE8QC1qgd0e0QvzZPOjGZkKOo+kuXOeQsfeJvcRb7gDrkgGCj4igsJCHIlnw/1esX3LtkSU6wXsIGYcGO2YklWRVLA2e7w5JS82cxy5X8X/F0NwPHxIJHvRSaVkj8eLHT7GCKpVE211uegEdeZ6I3WOibcfyomkb/SWoPFYZoyeUn1vh4dMhw/fS9CZFHUhxA1QTeyACYwCsa+TLXNbDcz27L7+8/wDdC9GUm3VPea7h8XK4Y+vEFDy5+/tFybOOHW5d+8/2KPWSqONYNFLfAW1QEOjcPqurjbNbZo/Maw2Gw9wtm5yuCVqKpipwx0fIAzwofBxOc0eXkfrysKkC7e+PTjC/snkbDST/9rkh5V8NCyoD8GT+abAeW84nXe0KbcOI4XSYKMbDuKPTjQw8DfpJf03o0d+0evpuyegg3SKFQPrPXyANeBADgtGK0/FrDHKl3z+Kt+ylP6dTS0ODL7M0/uIXdYnuQZmbY3UYjb18++xRFp6rM6VEEsl+B5WLpnrBr9AKINonO+7twBZpCXlO4gbSGsIVwrGBQPLF+ajAyn2qBNUWMdRHcoF4W0GQCjouJQ3AL1FAM2bOFPNMgP39tmQyKDluhCbuXOGf0+hi85+2QCPiBjlQlPMhtOmU6xa+zJQW33DRudIvO8dibhMD9Xytdt1rOMjVQDFowxGUmo0WjaN5W9zfqN21B05kq8mL2Ejqd2OzLB55luCGthiSZg/W1Ye5qv+wOMFkDbCvNaEvIR+R+vl8E0VB5WV1hMN1tgnt3xxC3kPzem0xpPOwuPn3LzbQjrZpy4eLxbc27EUUUN5S3YVjMk937/GUzYMsYY4YhjsTJ4WP24u++cfBIGVdiR5BHR9dtLRvDnzgxBvdDTkJ+rjjQrZTE+uHSdlq9+HLCLsPQyMetdip0wfHfOy8v93OkUNaTLqj3yJXBoiZ/z4NVwW3r6YPbyaWjG8ZXxn83Ne4O6dyTFiAdc9C/ZajqNy8zkf2A4t9XzCDAHrSAY+Qa9OikwbzGH6cjbRGSkgdQkExvguNW52Mfa1MlOpcPMcUkY5/zxRC+QaCP9G2lDWPTPWe/D60Tlug4pFjH02ccodAwInA/6fCPOfjGOIv2wmQAh6plVOKpgxwbhUdzi5/eZn12jNs54+X7k6CLr1j3hKgcVFYklvzsi3zOx1qJaMlibhEPno4/2vbbkSfM2gwNn70FjWhapU267vsAH9UCTF2eDvP1juSvv0dylMajqDvjBX2ebIVcSwu1+G0kY59Z9TTYUJNMIoWbzfDm0b0zQuf/E0d87P2lMhRn0A6sOB4RXZNHrLtUjo7zK9sPGusJ4THNp7uxBqPyvcFAqmB0TxAQW+MnZHLpSBCY3AA9DRMn9w9r269l9QL4ycpl2EQiZNNmwBkKuTDIQpFyTZ+C2wj2AxdRfCKuqwPA/oY1ewgwSQ0/nK/sEdHl5XLtdM9AsK3gKYp1NwgfF3uImQ7g7VDn5L3DKVh42mzE1jBujL58ENUqUeods1XFE0x5joaEvSir1LsloBKyI5Mc7hbYDd642h0q6xhMxkcBLyCfB+rWtGmKrykT1uoEuaLrjdaR78Z2epvvzRqKbQHjZvp4hDaE1NENC1PvC9AtIgP6DGG6t3kQxz+7V4pX5nu5+VTs9D1bjdQJm3wBegzfkrtpIFSjDzIbFLFnWaqGR9dQearp748c9XU5qYS42EjU4JOKgj4utuup/OxPNDG2QCFvGUaa1GQHR6FU4qEKPTTEd1hTlGVnPVD7XzD85M3ETLbOLg5rSlx0qworMFSgB3UAoN8Meyv688unICHef9awFJtSaLIrzTflJL+aFNxQWzduhybRhVF4cNO2u1RE1ibqOKIev+LSVRsqwYDb7oZj7wrK8LwEyyrw6Q9TOz9O0lwwZUMPhyPcoYsYli7WDS6+sTZm5HsY2f13laxYXJXkE0K7TCQ96BpRTVxO2KijgXE3tKPZkqDtE9WRnSPbsgI2glmu6nUuU7SWEe3xZE5HTQQtfKHlTXCltj9Yq/9OVXf69wb73EdeCPPZblyGT/4kGKaJ9ChRvQxfWkrI8HtQxq4e9zVGmJNP4fqbaw0ROb1IWZuo/tV7jq60rSej33UVO5vHR8F+otRXlkVWIE3OwrZjXOwTxzPukpAhAgIXnmehva0s5x5b2RH4wgp5EBY35M3geUxIY9b1gmNhA9X9eF/pifxgOvPIjukP0cdNUemDh9/jg3cIofSXw8QqoQMDBW+j56R6xYxhGj/oHI+uc6VGALbx50lcGuTKVuqMf9NsL2Sa9g/KW4moEP0k6h2yYSJImR+F1lRS/3Al3rgW2R/hSzntHnQN2kpG8i5yOWfkvftDDh64nDWIxJGJ57CY4++EUuz6eo0FonG2arQxuyPq9LN4LFu2GKD29Vn2Oj56W/wVFhuzhesCcB/woAuS/mGfeZvdBa8pokJGN7awexe1yj3BeXoNkaWFTtYCAGxeVSoSYmape/KHGZm3fBx6HC41z51kvjKlBXbRNmSAxoOCdiawGO5CwSlnAWfwtPf4wmPvprxnUyRh6wXTkWlgGw9snXW+haC1+mo4VPQKXPB1Rq5p/zEgMT6Na5kwdqm3I37LbV1oRDRXQ4Bz1CJ+WzGjz0tiDaM+xLJjzD12wmMxOk4si06n8Blvjk/Gt8CLbQfMxnDZPuoQAZ5SOeIoS0NeaH3pJqW+eyZX8EgiJbl8YtQYiMgoBhR2Acn+DbLm4p3BlcwPIBm97/uVxufOaj35kDSGQsqqJUtk863BLEUMnosP0i4HHvgZ4XACnjg4= </div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>强制删除工具Geek Uninstaller</title>
      <link href="/2018/03/22/%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%B7%A5%E5%85%B7Geek-Uninstaller/"/>
      <url>/2018/03/22/%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%B7%A5%E5%85%B7Geek-Uninstaller/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>介绍一个强力删除windows软件的小工具，只有2M大小。<a href="https://geekuninstaller.com/" target="_blank" rel="noopener">官方网址在此</a></p><p>经测试，QQ拼音输入法还是不能完全删除，这锅得QQ来背。太流氓！！！不过这款软件还是很好用！</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/31299448" target="_blank" rel="noopener">2M强力“卸载神器”，从此对流氓软件说“不”</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jackie Chan 成龙</title>
      <link href="/2018/03/19/Jackie-Chan-%E6%88%90%E9%BE%99/"/>
      <url>/2018/03/19/Jackie-Chan-%E6%88%90%E9%BE%99/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>想开篇来聊一聊成龙。</p><p>读了这么多书，总想着写东西首先得规划怎么写，采用什么框架写，才不至于流水账形式。</p><p>对于成龙来说，看着他的电影长大，喜欢李连杰的飘逸，可惜李连杰老了，再不复当年之勇，光环慢慢退却；而成龙，还时常活跃在视线中，他还是那个能打能给人带来欢乐的影人，虽然偶尔也发现他也是个六十多岁的老头了，但对他的欣赏仍旧没有改变，反倒随着时间的推移，越来越爱。为了了解他，特地去知乎上搜了：如何评价成龙？从众网友的文字中不难发现，大家都很爱成龙，他超越了同时代的其他影人，成为了旗帜，成了龙。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="86" src="//music.163.com/outchain/player?type=2&id=64266&auto=0&height=66"></iframe><p>这首歌，是我比较喜欢的大哥的一首歌，歌词平淡，很生活化。其实在众多华语音乐人来说，成龙的标签很明显，这跟他的从师经历有很大的关系。师从京剧名家，京剧表演已经深深烙印在他的灵魂里，无论拍戏还是唱歌，都能发现京剧对他的影响，他很好的把传统与现代结合，独树一帜。</p><!--<iframe width="480" height="320" src="https://static.hdslb.com/miniloader.swf?aid=103632&p=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><iframe height="300" width="100%" src="http://player.youku.com/embed/XNjQwOTM0ODIw" frameborder="0" 'allowfullscreen'=""></iframe><blockquote><p><del>这个B站链接有问题，可以直接点进去观看。</del>终于可以了，用swf格式，就可以内嵌播放了。</p></blockquote><p>这部电影揭示了成家班的特效制作，作为影人，成龙将成家班做到了专业化，这也是他走出去回来给自己带来的变化。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成龙 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一人之下</title>
      <link href="/2018/03/16/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B/"/>
      <url>/2018/03/16/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>国漫崛起时，最近被一部国漫《一人之下》实力圈粉，尤其喜欢剧内的各种方言配音，当然少不了各种人物角色歌曲，下面即是网易云的链接：</p><a id="more"></a><h3 id="诸葛青"><a href="#诸葛青" class="headerlink" title="诸葛青"></a>诸葛青</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=537196363&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一人之下 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>女朋友要带回家</title>
      <link href="/2018/01/14/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E8%A6%81%E5%B8%A6%E5%9B%9E%E5%AE%B6/"/>
      <url>/2018/01/14/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E8%A6%81%E5%B8%A6%E5%9B%9E%E5%AE%B6/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>这是昨晚翻B站突然听到的很老的歌，谭杰希的《女朋友要带回家》，还是一个小女生唱的，以前自己玩尤克里里也唱过，那还是刚学那会，现在这么老，唱这么苏的歌有点不好意思唱了，所以每次尽量选择励志的歌来学习，学了好久，至今还是扫弦君。。。大半夜听这么苏的歌很想拿起吉他啊。。。</p></blockquote><a id="more"></a><iframe width="100%" height="300" src="http://player.youku.com/embed/XMTMxNjI3OTky" frameborder="0" 'allowfullscreen'=""></iframe><!--<iframe width="840" height="473"  src='http://player.youku.com/embed/XMTMxNjI3OTky' frameborder=0 'allowfullscreen'></iframe>-->]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谭杰希 </tag>
            
            <tag> 郑湫泓 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RNN生成古诗</title>
      <link href="/2018/01/07/RNN%E7%94%9F%E6%88%90%E5%8F%A4%E8%AF%97/"/>
      <url>/2018/01/07/RNN%E7%94%9F%E6%88%90%E5%8F%A4%E8%AF%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>利用RNN生成古诗，看看生成的样子。</p></blockquote><p>隐室令帆出水令，猎人宜道意初干。</p><p>鸣波太众岚彩禁，易郭香鸣栈堕风。</p><p>风竹出茏寒透匣，碧榛终乱异宫祠。</p><p>迷坛金石人难到，骏退多候快逐连。</p><p>千里战旗亭万匝，望烟川色耀光辉。</p><p>异人不敢传秘著，形骸情无念太平。</p><a id="more"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/wzyonggege/RNN_poetry_generator" target="_blank" rel="noopener"></a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="https://LorrinWWW.github.io/posts/[2017.12.10]Entity-resolution/">实体解析 Entity resolution</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于微博图床</title>
      <link href="/2018/01/06/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/"/>
      <url>/2018/01/06/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天发现，上传到微博上的照片，即使客户端删除之后，服务器中还保存副本，链接依然有效，所以考虑到安全问题，有关个人信息的图片还是不要上传到微博上。</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微博 </tag>
            
            <tag> WeiBO </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>晚婚</title>
      <link href="/2017/12/29/%E6%99%9A%E5%A9%9A/"/>
      <url>/2017/12/29/%E6%99%9A%E5%A9%9A/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>突然听到李宗盛的《晚婚》，感觉比江蕙的更好听，唱出了那种岁月沉淀，饱含沧桑。以前很喜欢李宗盛的歌，基本去KTV必点他的歌，这首歌也让我单曲循环了好久，此刻就在。</p></blockquote><a id="more"></a><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/253A015C7271945908E10EBCE654E07D.mp4?sc=e224b9162c5d2a93&br=778&vid=2844070&aid=311&area=HT&vst=2" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/253A015C7271945908E10EBCE654E07D.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>大叔说：我从来不想独身，却有预感晚婚。快30的年头，这已经不是预感了。少不听李宗盛，听了他这么多年，越来越觉得他的词不经岁月打磨，很难到这个境界。他唱歌带吟带唱，像独白、诉说，又或低吟。往往令人情不自禁，所以，今天分享这首，听歌的人每个人感受都不一样，歌者需要的就是拨动人的心弦。</p><p>岁月如歌，年华残酷。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://www.davidfnck.com/marketing/ad_new-balance_jonathan-lee.html/">广告的事｜New Balance X 李宗盛「每一步都算数」</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李宗盛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>摄影笔记手机摄影入门</title>
      <link href="/2017/12/22/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/"/>
      <url>/2017/12/22/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>这是摘选自摄影笔记的内容，在自己的博客中留存。</p></blockquote><a id="more"></a><p><a href="http://www.sybj.com/may.php?c=deLovely&amp;a=courseTable&amp;t=1&amp;name=phone" target="_blank" rel="noopener">手机摄影入门</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/04/07/摄影杂货铺/">摄影杂货铺</a></li><li><a href="http://www.davidfnck.com/talkshow/obama_top_100_best_photos.html/">创业前辈｜Barack Obama's Top 100 best photos</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>月供是怎么回事</title>
      <link href="/2017/12/06/%E8%BD%AC%E6%9C%88%E4%BE%9B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
      <url>/2017/12/06/%E8%BD%AC%E6%9C%88%E4%BE%9B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>买房、买车，人生大事，抛开全款，你了解月供几何？</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://mp.weixin.qq.com/s/9qQ21OFThBqAIQuUsYdbvA" target="_blank" rel="noopener">月供是怎么回事？</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转傅立叶白话分析</title>
      <link href="/2017/12/05/%E8%BD%AC%E5%82%85%E7%AB%8B%E5%8F%B6%E7%99%BD%E8%AF%9D%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/05/%E8%BD%AC%E5%82%85%E7%AB%8B%E5%8F%B6%E7%99%BD%E8%AF%9D%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文以简明的语言向读者阐述了傅立叶分析的基本原理，适合入门。</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程（完整版）更新于2014.06.06</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 傅立叶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转从LeNet到DenseNet</title>
      <link href="/2017/12/05/%E8%BD%AC%E4%BB%8ELeNet%E5%88%B0DenseNet/"/>
      <url>/2017/12/05/%E8%BD%AC%E4%BB%8ELeNet%E5%88%B0DenseNet/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文详细介绍了CNN各网络的发展史，值得一读。</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/31006686" target="_blank" rel="noopener">从LeNet-5到DenseNet</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>南京美食记</title>
      <link href="/2017/12/05/%E5%8D%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E8%AE%B0/"/>
      <url>/2017/12/05/%E5%8D%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>平时无聊，总想着去哪吃，会看到一些网友推荐，过后再想吃的时候又忘了，所以，特开此文广记南京美食，采取完成任务列表模式，当然，现在一家都没吃过，开篇啦！！！</p></blockquote><a id="more"></a><h3 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/Itdw09JSwujCypXSE3eOww" target="_blank" rel="noopener">尤广记牛杂王</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/808T4rVTkiLkiMCkzab8GQ" target="_blank" rel="noopener">大蔬无界</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/SyTjL5Y3UnqwGS43CL-BYw" target="_blank" rel="noopener">泽锅草原牛肉火锅</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://mp.weixin.qq.com/s/I_ogU9vOY7N89OTUeJoZAg" target="_blank" rel="noopener">米桃餐厅</a></li></ul><h3 id="饮品"><a href="#饮品" class="headerlink" title="饮品"></a>饮品</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/OUpX8a5XAmSS4YvdD2h57Q" target="_blank" rel="noopener">甜荟</a></li><li style="list-style: none"><input type="checkbox"> ​</li></ul>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
            <tag> 南京 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛排常识</title>
      <link href="/2017/12/04/%E7%89%9B%E6%8E%92%E5%B8%B8%E8%AF%86/"/>
      <url>/2017/12/04/%E7%89%9B%E6%8E%92%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>常听别人说起某某某牛排，那么各种牛排的区别是什么，本博文假他人之手娓娓道来。</p></blockquote><a id="more"></a><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm520zsoqsj30hj0bn7lp.jpg" alt=""></p><p><strong>先来一张我大蔚蓝海岸尼斯柠檬节的神牛镇题</strong></p><p>法国人虽然没有西班牙人对牛如此有感情把牛当成<strong>国家图腾</strong>（法兰西喜欢大公鸡+ +), 但是对于个个吃货的法国来说牛排和牛肉简直就是人生活下去的动力之一。所以在吃牛上法国的讲究都是世界牛肉研究的领头羊。在做牛排这事上还是得看法国人的，所以基本牛肉在牛身上的位置专业单词都是法语基础，英语的单词都是直接引用<strong>法语词汇换成英语发音</strong>而已。下文有些<strong>专业单词</strong>我就直接用法语写了。</p><p>只是牛排的话<strong>小牛肉veau </strong>是最好的牛排食材既兼顾<strong>鲜嫩多汁</strong>而且肉的<strong>弹性</strong>也非常<strong>完美</strong>，但是牛肉的做法十分复杂，根据肉质不同用法也不尽相同。</p><p>在硕士一年级<strong>修味嗅觉分析</strong>的时候专门研究过牛排的口感和味道不同，还写了<strong>一篇论文</strong>。</p><p>把当时的论文用图先放出来，文字的话看完<strong>今晚的世界杯</strong>翻译过来 : D</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm5210k0inj30j20c74a4.jpg" alt=""></p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm52117b7fj30j10d04bo.jpg" alt=""></p><p>世界杯看完了，意大利万岁，我又赢了一顿日本料理 : D</p><p>在讨论<strong>味道</strong>的时候不先讨论<strong>牛的品种和产地</strong>都是耍<strong>流氓</strong>，我的论文第一部分就是对各个<strong>AOC产地保护</strong>的<strong>法国牛</strong>种的讨论和确定它们各自的特点。</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5211tcf8j30a70f7ju9.jpg" alt=""></p><p>这些都是被<strong>欧盟承认</strong>的法国产区保护的独特牛种，其中最后一种白色的<strong>charolaise 白牛</strong>肉质最为鲜美，在广阔的<strong>特种牧草放牧</strong>长大，并且本身肉质就以肉内<strong>血脂细腻</strong>出名。是在世界范围内都是很出名不可多得的<strong>高大上牛肉</strong>。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5212fksrj30dx0afk1f.jpg" alt=""></p><p>好漂亮的牛牛，么么嗒 :》</p><p>其他的高品质牛肉还有人尽皆知的<strong>日本和牛，澳洲牛肉，匈牙利牛肉</strong>等等，这些牛肉某些部位脂肪肌肉比例搭配完美直接sashimi 是最好的选择，<strong>牛排浪费了</strong>。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm52132qhfj30fm0cgwq0.jpg" alt=""></p><p>比如这道<strong>法国牛肉名菜</strong>：<strong>tartare du boeuf</strong>。 也是被各种<strong>排名</strong>文章和传说中的<strong>仰望星空派</strong>一样放在绝对不要点的外国菜里面，排名还<strong>挺高</strong>。</p><p>有一次在巴黎歌剧院附近的HIPOPOTAMUS 吃饭，旁边两个中国情侣游客看到法国人点的这个，立马眼睛瞪得牛大<strong>开始议论</strong>：哎呀，妈呀，生肉哎，那个中国人能吃这个呀！话音还没落，服务员就给我上了一道<strong>一样的</strong>，他俩的表情别说多精彩了 : p</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5213q4ukj308r05wae9.jpg" alt=""></p><p>法国的tartare du boeuf 做法<strong>不够细腻</strong>，牛肉块比较大，主要靠搭配不同的SAUCE来调味。而意大利的做法更加适合想要品尝一下牛肉原味而又不是吃肉老饕的人，用剁碎的牛肉搭配各种香草，味道很好，比更加出名的意大利生牛肉切片CARPACIO 更有肉质风味。（有点像生吃牛肉饺子馅:》)</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5214ftaxj30ee09uk11.jpg" alt=""></p><p>回到正题讨论牛排的不同部位口感：</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm52159ob9j30ey0hr7b0.jpg" alt=""></p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm52169e7hj30hx06laml.jpg" alt=""></p><p>一只牛可以吃的部位不要太多，我们得确定牛身上那些<strong>部分</strong>是可以<strong>煎牛排</strong>的：从表中我们可以看到3，4，5，7，9,20,21,22,23,24 这几个部位都是用来做煎牛排的，那么这些部位叫什么名字呢？</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm5216zsuzj30i10dl1dd.jpg" alt=""></p><p><strong>部位三entrecôte</strong> 是肋排，是最经典的煎牛排部位。 肋排肋排必然是排骨肉啦。 跟猪肉一样，肋排口感不够细腻，但是咬头很好，很咬口，而且不会有含牛筋那种藕断丝连嚼不烂的感觉。 最重要的是肋排一般比较<strong>便宜</strong>比较<strong>大块</strong>，饭店里动辄350G 或者500G的大肋排，适合我这种<strong>食肉动物</strong>。</p><p><strong>部位五六七</strong>味道相近，但<strong>等级不同</strong></p><p>部位六就是传说中的<strong>菲利（法语filet）</strong>牛排，是牛排中最顶级的部位。腰内肉部分<strong>牛腰肉</strong>（英语tenderloin），最嫩处切出，是牛脊上的肉，形状头大尾小，脂肪含量少，适合三分熟，吸吮<strong>甜美的肉汁</strong>，<strong>肉质鲜嫩</strong>，菲力牛排包裹在牛腹腔中，所以肌肉都没运动到，故肌肉纤维不粗。是牛排中单价最高的。</p><p>五七两个部分比较复杂，<strong>5 faux filet</strong> 就是接近于菲利牛排的牛胸脊肉部分，口感与菲利牛排类似，但是<strong>鲜嫩度</strong>较低，弹性较好和肉质稍稍<strong>偏硬</strong>但不会让人觉得咀嚼困难。</p><p>这两个部分在美国英国等地叫法不同，或者翻译成沙朗牛排或者西冷牛排。<br>沙朗牛排在美国指牛后腰脊柱两侧的肉，肉质细嫩，价格高。其中顶部（top sirloin）的肉质最好，价格最高，一般会标明。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5217op46j30e708i40l.jpg" alt=""></p><p>沙朗牛排在英国、香港等地指牛胸脊肉部分，肉质细嫩度次于菲利牛排，售价也较低于菲力牛排，上端部分的西冷牛排较为鲜嫩，售价亦稍高。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5218fllsj30dy08mjvw.jpg" alt=""></p><p>filet 菲利是除了小牛肉这种高级食材外做牛排最好最高价的部位，基本都是各个牛排屋的拿手绝活。</p><p>二十，二十一两个部位比较相近常常放到一起讨论，这两个部位是牛肉中<strong>最少见</strong>的部分。基本不会在大的超市里销售，肉店老板会<strong>留给识货</strong>或相熟的大厨朋友。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm52194xivj30gr0drh1p.jpg" alt=""></p><p>ONGLET是<strong>膈柱肌肉</strong>， 可以做牛排，但是一定要避免过度煎烤。因为肌肉纤维较长，如果全熟会导致牛排过硬难以切割，更别说下口了。</p><p>HAMPE 是靠近大腿内侧的<strong>腹部肉</strong>， 一般情况下<strong>不会直接</strong>煎成牛排，因为肌肉纤维太长外表看起来都很明显。 但这个部位可以做成最好的steak haché <strong>碎肉牛排</strong>，不会因为肉质过软导致剁碎后牛肉失去<strong>弹性</strong>。碎肉牛排就是一般汉堡包会使用的牛排。是不是高档汉堡就看其中的肉排是不是HAMPE做的就可以了。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm5219xjcaj30dd08l473.jpg" alt=""></p><p>这两个部位一般是被认为最接近下水的牛肉，所以不是牛肉老饕根本不会关注这两个部位的口感。</p><p><strong>23，24 bavette </strong>是牛的<strong>腰腹部细肉</strong>， bavette à l’échalote 是一道用小洋葱做的传统法国名菜。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521ai6dwj30i40e1dwj.jpg" alt=""></p><p>这个部位牛排做法比较<strong>奇特</strong>，厨师用非常热的手在肉的两端各放几分钟，牛排的内心必须是全生的。因为这个部分筋非常多，如果烤熟就太过难咬。但如果做的适当，可以说是牛身上味道最丰富的一个部位。</p><p><strong>24 flanchet是腹肉，相当</strong>少见用来做牛排的一个部分。因为作为牛身体<strong>脂肪</strong>最多的部位，应该说油脂能增加牛排香味。可是此处油脂含量过高，导致牛排煎起来较生会油腻，煎熟又会导致牛排肉质因为煎烤时间过长而过老难以下口，所以通常是做牛排牛肉中最后一个选择。</p><p><strong>2 basses cotes 牛上脑</strong> 或者翻译成牛眼肉，也是我个人最喜欢的一个部位。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521b4lykj30bs076tfq.jpg" alt=""></p><p>不光是做牛排，就算是中国的传统火锅，牛上脑也是最棒的<strong>刷锅肉材</strong>！ 肉质绵软细腻，肥瘦相宜，如若切片生吃，可算是慢慢在口中融化的感觉异常美妙。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm521br0v6j30bw07t47i.jpg" alt=""></p><p> 普罗旺斯的AIX 我住的城市里有一家韩国烧烤，提供<strong>匈牙利牛上脑</strong>烧烤，每次去朋友们都是烟熏火绕异常热闹，而只有我自己慢慢品味上脑在口中融化纠缠的感觉。每次被人笑话把韩餐吃成<strong>日料</strong> : )</p><p>大家下次在高档火锅店确定是<strong>内蒙牛肉</strong>的上脑薄切片肉可以试试用清淡调料<strong>腌制</strong>一下，然后<strong>生食</strong>，享受如同<strong>西班牙火腿</strong>的如丝织般的性感。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521cgftyj30fm0c2tjg.jpg" alt=""></p><p>如果用牛上脑做牛排，比较适合的是5成熟。外表的虽然已熟透，但下口没有阻碍感，内部的汁水会浸满过舌，<strong>略微甜甜</strong>又不腥腻，咀嚼起来丝毫不用力，微微咬动已经<strong>满口肉香</strong>。有点像吃鲑鱼子寿司挤破鱼子的快感。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521d76yaj30hz0cbgyz.jpg" alt=""></p><p>而相较于菲利（filet）牛上脑<strong>体积</strong>比较大，价格并不昂贵，是非常具有<strong>性价比</strong>的牛排部位。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.zhihu.com/question/20467087/answer/26828813" target="_blank" rel="noopener">不同部位的牛肉有什么区别，做出的牛排口感有何差异？ - 晨曦的回答 - 知乎</a></li></ol>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛排 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种咖啡种类区别</title>
      <link href="/2017/12/04/%E5%90%84%E7%A7%8D%E5%92%96%E5%95%A1%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/12/04/%E5%90%84%E7%A7%8D%E5%92%96%E5%95%A1%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>平时听说各种咖啡，还有各种区别，听起来头大，在此笔记。</p></blockquote><a id="more"></a><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbk3yj20c80a1aa5.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbfugj20c80adt8u.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbokoj20c80a5q34.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbffvj20c80at3yl.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpa4xcj20c80a874e.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpb5gxj20c809swek.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpcq2oj20c80au3yo.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpd4nbj20c80abmx9.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpdwl4j20c80atjrh.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本地编辑markdown工具Typora</title>
      <link href="/2017/12/04/%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91markdown%E5%B7%A5%E5%85%B7Typora/"/>
      <url>/2017/12/04/%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91markdown%E5%B7%A5%E5%85%B7Typora/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>推荐一个本地编辑markdown的工具，在各平台下都有版本。</p></blockquote><p>官方网址为：<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows绝赞应用</title>
      <link href="/2017/12/04/windows%E7%BB%9D%E8%B5%9E%E5%BA%94%E7%94%A8/"/>
      <url>/2017/12/04/windows%E7%BB%9D%E8%B5%9E%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>「Windows 绝赞应用」项目由 @<a href="https://link.zhihu.com/?target=https%3A//github.com/EMLVIRUS" target="_blank" rel="noopener">EMLVIRUS</a> 发起，旨在帮用户提供优秀的 Windows 应用以免除繁琐的搜寻工作。<strong>我们姑且可以将其理解为一份人工维护的优质 Windows 应用推荐榜单</strong>，前往 <a href="https://link.zhihu.com/?target=https%3A//emlvirus.gitbooks.io/windows-apps-that-amaze-us/content/" target="_blank" rel="noopener">该项目的 GitBook 页面</a> 即可在线进行阅读和索引。</p><p><a href="https://amazing-apps.gitbooks.io/windows-apps-that-amaze-us/content/zh-CN/" target="_blank" rel="noopener">Windows绝赞应用</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="http://gubangzhong.cn/2016/11/16/女人如政治/">女人如政治</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一千年以后</title>
      <link href="/2017/11/26/%E4%B8%80%E5%8D%83%E5%B9%B4%E4%BB%A5%E5%90%8E/"/>
      <url>/2017/11/26/%E4%B8%80%E5%8D%83%E5%B9%B4%E4%BB%A5%E5%90%8E/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>感叹养猪家音乐越来越办不下去了，现在基本是企鹅一家独大，好多养猪家的歌曲现在都听不了了，于是悄悄下了企鹅家的QQ音乐，其实现在对企鹅家的东西不是太排斥，尽管年少曾骂过。企鹅家的音乐有个不好的地方，就是我不方便在自己的网页中嵌入代码。不像养猪家那么人性化，比如，我今天听到一千年之后，就想在自己的网页中嵌入这段音乐，可惜只有链接。这时候又念叨养猪家的东西好啊！！！</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="86" src="//music.163.com/outchain/player?type=2&id=26305531&auto=0&height=66"></iframe><p>越老越怀念以前，可能是单身或者在学校的时间久了，有太多的时间迷茫和感伤，所以就听歌吧！！！</p><p>不知道一年之后的自己是什么样子，也许也许，板凳坐久了总想出去看看，想多了也就看淡了，现在少年老成的词也许已经不合适了，人到中年了哈！！！</p>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些资料翻译收集</title>
      <link href="/2017/11/25/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E7%BF%BB%E8%AF%91%E6%94%B6%E9%9B%86/"/>
      <url>/2017/11/25/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E7%BF%BB%E8%AF%91%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://zhuanlan.zhihu.com/p/31363259" target="_blank" rel="noopener">Scikit-Learn 中文文档第一期校验完成，邀请你来参与维护，一起走的更远 | ApacheCN</a><br>2.<a href=""></a><br>3.<a href=""></a><br>4.<a href=""></a><br>5.<a href=""></a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2018/01/07/RNN生成古诗/">RNN生成古诗</a></li><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> 转载 </tag>
            
            <tag> scikit-learn </tag>
            
            <tag> elastic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在python下利用opencv读取图片</title>
      <link href="/2017/11/23/%E5%9C%A8python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/"/>
      <url>/2017/11/23/%E5%9C%A8python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'filename'</span>)</span><br><span class="line">print(type(img))</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'window_name'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">'window_name'</span>)</span><br></pre></td></tr></table></figure><p>注意opencv读出来的img格式直接是numpy.ndarray格式，可以用numpy直接操作。</p><p>参考资料1不是用opencv读取图像的，可以尝试看看，以供学习。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.cnblogs.com/yinxiangnan-charles/p/5928689.html" target="_blank" rel="noopener">python 读取并显示图片的两种方法</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> opencv </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10安装django错误集</title>
      <link href="/2017/11/20/win10%E5%AE%89%E8%A3%85django%E9%94%99%E8%AF%AF%E9%9B%86/"/>
      <url>/2017/11/20/win10%E5%AE%89%E8%A3%85django%E9%94%99%E8%AF%AF%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在cmd中创建第一个项目吧。</p><p>django-admin startproject mysite(千万不要使用django-admin.py startproject mysite这样老是打开django-admin.py文件，仅纪念踩过的坑)</p><p>cd mysite,运行python manage.py runserver,打开浏览器输入<a href="http://127.0.0.1:8000/,下面就开始开发你的网站吧" target="_blank" rel="noopener">http://127.0.0.1:8000/,下面就开始开发你的网站吧</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://blog.csdn.net/uuyytg/article/details/76036557" target="_blank" rel="noopener">window10下安装Django</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转PyQt5教程</title>
      <link href="/2017/11/20/%E8%BD%ACPyQt5%E6%95%99%E7%A8%8B/"/>
      <url>/2017/11/20/%E8%BD%ACPyQt5%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.cnblogs.com/archisama/tag/PyQt5/" target="_blank" rel="noopener">PyQt5</a></li></ol><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 转载 </tag>
            
            <tag> PyQt5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彻底卸载VisualStudio</title>
      <link href="/2017/11/20/%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVisualStudio/"/>
      <url>/2017/11/20/%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVisualStudio/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有个插件叫TotalUninstaller，启用这个插件就可以完全删除visual studio的版本！在此mark，在我的百度网盘里有留存！</p><a id="more"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://jingyan.baidu.com/article/72ee561a560958e16138dfda.html" target="_blank" rel="noopener">教你彻底卸载Visual Studio 2015</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转：目标检测系列博客</title>
      <link href="/2017/11/20/%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/11/20/%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="晓雷机器学习笔记"><a href="#晓雷机器学习笔记" class="headerlink" title="晓雷机器学习笔记"></a>晓雷机器学习笔记</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/23006190?refer=xiaoleimlnote" target="_blank" rel="noopener">RCNN-将CNN引入目标检测的开山之作</a></li><li><a href="https://zhuanlan.zhihu.com/p/24774302?refer=xiaoleimlnote" target="_blank" rel="noopener">SPPNet-引入空间金字塔池化改进RCNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24780395?refer=xiaoleimlnote" target="_blank" rel="noopener">Fast R-CNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24916624?refer=xiaoleimlnote" target="_blank" rel="noopener">Faster R-CNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24916786?refer=xiaoleimlnote" target="_blank" rel="noopener">图解YOLO</a></li><li><a href="https://zhuanlan.zhihu.com/p/24954433?refer=xiaoleimlnote" target="_blank" rel="noopener">SSD</a></li><li><a href="https://zhuanlan.zhihu.com/p/25167153?refer=xiaoleimlnote" target="_blank" rel="noopener">YOLO2 </a></li></ol><h3 id="Learning-Machine"><a href="#Learning-Machine" class="headerlink" title="Learning Machine"></a>Learning Machine</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/28585873" target="_blank" rel="noopener">keras版faster-rcnn算法详解(1.RPN计算)</a></li><li><a href="https://zhuanlan.zhihu.com/p/29400164" target="_blank" rel="noopener">keras版faster-rcnn算法详解(2.roi计算及其他)</a></li></ol><h3 id="机器学习随笔"><a href="#机器学习随笔" class="headerlink" title="机器学习随笔"></a>机器学习随笔</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">Faster R-CNN</a></li></ol><h3 id="刘航呈"><a href="#刘航呈" class="headerlink" title="刘航呈"></a>刘航呈</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/30316608" target="_blank" rel="noopener">R-CNN学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/30368989" target="_blank" rel="noopener">Fast R-CNN学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/30720870" target="_blank" rel="noopener">Faster R-CNN学习总结</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己动手做聊天机器人</title>
      <link href="/2017/07/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2017/07/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ol><li><a href="http://www.shareditor.com/bloglistbytag/?tagname=%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA" target="_blank" rel="noopener">自己动手做聊天机器人</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RNN资料收集</title>
      <link href="/2017/07/22/RNN%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>/2017/07/22/RNN%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ol><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></li><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-2-implementing-a-language-model-rnn-with-python-numpy-and-theano/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 2 – Implementing a RNN with Python, Numpy and Theano</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ol><a id="more"></a><p>另外WILDML的一些博客：</p><ol><li><a href="http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/" target="_blank" rel="noopener">Implementing a Neural Network from Scratch in Python – An Introduction</a></li><li><a href="http://www.wildml.com/2015/09/speeding-up-your-neural-network-with-theano-and-the-gpu/" target="_blank" rel="noopener">Speeding up your Neural Network with Theano and the GPU</a></li><li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">Understanding Convolutional Neural Networks for NLP</a></li><li><a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="noopener">Implementing a CNN for Text Classification in TensorFlow</a></li><li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">Attention and Memory in Deep Learning and NLP</a></li><li><a href="http://www.wildml.com/2016/04/deep-learning-for-chatbots-part-1-introduction/" target="_blank" rel="noopener">Deep Learning for Chatbots, Part 1 – Introduction</a></li><li><a href="http://www.wildml.com/2016/07/deep-learning-for-chatbots-2-retrieval-based-model-tensorflow/" target="_blank" rel="noopener">Deep Learning for Chatbots, Part 2 – Implementing a Retrieval-Based Model in Tensorflow</a></li><li><a href="http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/" target="_blank" rel="noopener">RNNs in Tensorflow, a Practical Guide and Undocumented Features</a></li><li><a href="http://www.wildml.com/2016/10/learning-reinforcement-learning/" target="_blank" rel="noopener">Learning Reinforcement Learning (with Code, Exercises and Solutions)</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安装latex</title>
      <link href="/2017/07/22/%E5%AE%89%E8%A3%85latex/"/>
      <url>/2017/07/22/%E5%AE%89%E8%A3%85latex/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文主要记录下安装使用latex的两个软件：</p><ol><li><a href="https://miktex.org/" target="_blank" rel="noopener">miktex</a></li><li><a href="http://www.xm1math.net/texmaker/" target="_blank" rel="noopener">texmaker</a></li></ol><p>首先安装miktex，然后再安装texmaker。</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/u013063099/article/details/51926023" target="_blank" rel="noopener">Miktex 2.9+Texmaker 4.4.1安装及中英PDF生成过程</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://LorrinWWW.github.io/posts/hexo-with-latex/">解决hexo使用公式冲突问题 hexo with latex</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如果我爱你</title>
      <link href="/2017/07/21/%E5%A6%82%E6%9E%9C%E6%88%91%E7%88%B1%E4%BD%A0/"/>
      <url>/2017/07/21/%E5%A6%82%E6%9E%9C%E6%88%91%E7%88%B1%E4%BD%A0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近新上的剧《春风十里》的主题曲，最近越来越喜欢周冬雨了。以前不待见这么个演员，从老谋子选角山楂树开始，觉得老谋子怎么选了个这么样的女演员，长得不怎么好看，眼镜如此之小。现如今再看，真为当时的自己感到羞愧，如此以貌取人。近段时间，从《七月与安生》到《喜欢你》，本来我不喜欢的电影，愣是凭着周冬雨的戏让我坚持看了下来，从此开始喜欢上这个有点神经再细看又如此美丽的演员。新剧《春风十里》估计符合她这几部剧一贯的风格，调皮、青涩、生动，只她演过的那几部戏，就深深吸引了我。这是她和张一山为《春风十里》而唱的主题曲，尽管唱功不是那么完美，但是由这两人唱出来平添了许多的韵味，有初恋的那种单纯，有春风化雨的细腻，有怦然心跳的悸动。如果我爱你……</p><a id="more"></a><!--网易云音乐<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=489998494&auto=0&height=66"></iframe>--><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/E62E015D3ECA5CF4408B7E2AB8AE5F6A.mp4?sc=281fab630288fdbe&br=774&vid=2910410&aid=14997&area=ML&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/E62E015D3ECA5CF4408B7E2AB8AE5F6A.mp4?sc=281fab630288fdbe&br=774&vid=2910410&aid=14997&area=ML&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周冬雨 </tag>
            
            <tag> 张一山 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Matlab常用函数及技巧</title>
      <link href="/2017/07/17/Matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%8A%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/07/17/Matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%8A%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文记录常用matlab函数以及技巧，不定时更新。</p></blockquote><a id="more"></a><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>TBD</p><h3 id="strrep"><a href="#strrep" class="headerlink" title="strrep"></a>strrep</h3><p>TBD</p><h3 id="imwrite"><a href="#imwrite" class="headerlink" title="imwrite"></a>imwrite</h3><p>imwrite(参数变量,’保存名称.保存格式’);</p><p>如果参数变量是double类型的，在保存的时候切记将参数变量除以参数变量的动态范围以归一化到[0,1]，这样才能正确保存为bmp或者jpg等格式。</p><h3 id="var-cov"><a href="#var-cov" class="headerlink" title="var/cov"></a>var/cov</h3><p>方差/协方差</p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>dir(路径);</p><p>遍历变量路径下的文件和文件夹</p><h4 id="isdir"><a href="#isdir" class="headerlink" title="isdir"></a>isdir</h4><p>判断dir得到的struct是否是文件夹</p><h3 id="fread-fopen-fclose"><a href="#fread-fopen-fclose" class="headerlink" title="fread/fopen/fclose"></a>fread/fopen/fclose</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fid = fopen(路径);</span><br><span class="line"><span class="keyword">if</span> fid &gt; <span class="number">0</span></span><br><span class="line">data = fread(fid,[高 宽],存储格式);</span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error(<span class="string">'文件未能打开'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="fullfile"><a href="#fullfile" class="headerlink" title="fullfile"></a>fullfile</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fullfile(变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>,变量<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&gt; &gt; 变量<span class="number">1</span>/变量<span class="number">2</span>/变量<span class="number">3</span>/变量<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">strcat(变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>,变量<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&gt; &gt; 变量<span class="number">1</span>变量<span class="number">2</span>变量<span class="number">3</span>变量<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="num2str"><a href="#num2str" class="headerlink" title="num2str"></a>num2str</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">num2str(变量,<span class="string">'%04d'</span>) <span class="comment">% 整数补充到4位，不足前面加零</span></span><br><span class="line"></span><br><span class="line">num2str(<span class="number">2</span>,<span class="string">'%04d'</span>)</span><br><span class="line"></span><br><span class="line">&gt; &gt; <span class="number">0002</span></span><br></pre></td></tr></table></figure><h3 id="ginput"><a href="#ginput" class="headerlink" title="ginput"></a>ginput</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[x y] = ginput(<span class="number">2</span>);<span class="comment">% 手动在图上选取2个点</span></span><br></pre></td></tr></table></figure><h3 id="corr"><a href="#corr" class="headerlink" title="corr"></a>corr</h3><p>计算矩阵列向量相关系数函数</p><h3 id="movefile-copyfile"><a href="#movefile-copyfile" class="headerlink" title="movefile/copyfile"></a>movefile/copyfile</h3><p>移动文件/复制文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/watkinsong/article/details/38535595" target="_blank" rel="noopener">matlab imwrite 保存图像详解</a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010q68.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）-（一）</a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010twg.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）-（二）_函数var </a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010twv.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）（三）_函数cov</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>protobuf生成c++代码详解(初稿)</title>
      <link href="/2017/07/13/protobuf%E7%94%9F%E6%88%90cplusplus%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/07/13/protobuf%E7%94%9F%E6%88%90cplusplus%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文翻译自<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="noopener">C++ Generated Code</a></p></blockquote><a id="more"></a><p>本文描述了<code>protocol</code>缓冲编译器为指定的<code>protocol</code>定义生成的<code>C++</code>代码。<code>proto2</code>和<code>proto3</code>生成代码之间的任何区别都会突出显示。请注意，这些差异在生成代码中，而不在<code>base classes/interfaces</code>，这两个版本的<code>base classes/interfaces</code>都相同。在阅读本文档之前，您应该阅读proto2语言指南和/或proto3语言指南。</p><h3 id="Compiler-Invocation"><a href="#Compiler-Invocation" class="headerlink" title="Compiler Invocation"></a>Compiler Invocation</h3><p><code>protocol</code>缓冲区编译器在使用<code>--cpp_out=</code>命令行时生成<code>C++</code>输出。该<code>--cpp_out=</code>选项的参数是编译器生成<code>C++</code>代码输出的目录。编译器为每个<code>.proto</code>文件输入创建头文件和实现文件。输出文件的名称通过获取<code>.proto</code>文件的名称并进行两次更改来实现：</p><ul><li>源文件扩展名<code>.proto</code>被替换为<code>.pb.h</code>或<code>.pb.cc</code>，即为头或实现文件。</li><li><code>proto</code>路径（用<code>--proto_path=</code>或<code>-I</code>命令行标志指定）被输出路径（用<code>--cpp_out=</code>标志指定）替换。</li></ul><p>假设你调用编译器如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto</span><br></pre></td></tr></table></figure><p>编译器将读取这些文件<code>src/foo.proto</code>和<code>src/bar/baz.proto</code>，产生四个输出文件：<code>build/gen/foo.pb.h</code>，<code>build/gen/foo.pb.cc</code>，<code>build/gen/bar/baz.pb.h</code>，<code>build/gen/bar/baz.pb.cc</code>。编译器根据需要自动创建目录将<code>build/gen/bar</code>，但不会创建<code>build</code>或<code>build/gen</code>，它们必须已经存在（即需要自己创建）。</p><h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h3><p>如果<code>.proto</code>文件包含一个<code>package</code>声明，则文件的全部内容将被放置在相应的<code>C++</code>命名空间中。例如，给出<code>package</code>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br></pre></td></tr></table></figure><p>文件中的所有声明将在<code>foo::bar</code>命名空间中。</p><h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>给出一个简单的消息声明：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><code>protocol</code>缓冲区编译器生成一个由<code>google::protobuf::Message</code>公开派生的类<code>Foo</code>。这个类是一个具体的类，没有纯虚函数等待实现。根据优化模式，<code>Message</code>中的虚函数但不是纯虚函数可以被<code>Foo</code>覆盖也可以不被覆盖。默认情况下，<code>Foo</code>以最大速度实现所有函数的专门版本。但是，如果<code>.proto</code>文件包含该行：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure><p>那么<code>Foo</code>将仅覆盖功能所需的最小的一组方法，并依赖其余的基于反射的实现。这显著减少了生成的代码，但也降低了性能。或者，如果<code>.proto</code>文件包含：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = LITE_RUNTIME;</span><br></pre></td></tr></table></figure><p>那么<code>Foo</code>将包括所有方法的快速实现，将实现该<code>google::protobuf::MessageLite</code>接口，该接口只包含<code>Message</code>方法的子集。特别地，它不支持描述符或映射。但是，在这种模式下，生成的代码只需要链接<code>libprotobuf-lite.so</code>（<code>libprotobuf-lite.lib</code>在<code>Windows</code>上），而不是<code>libprotobuf.so</code>（<code>libprotobuf.lib</code>）。<code>lite</code>库比完整的库小得多，更适合资源有限的系统，如手机。</p><p>你不能创建自己的<code>Foo</code>子类。如果您将此类子类化并覆盖虚函数，则覆盖可能会被忽略，因为许多生成的方法调用都将被去虚拟化以提高性能。</p><p><code>Message</code>接口定义了检查、处理、读取或写入整个<code>message</code>的方法，包括解析和序列化到二进制字符串。除了这些方法，<code>Foo</code>类还定义了以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo()：默认构造函数。</span><br><span class="line">~Foo()：默认析构函数。</span><br><span class="line">Foo(<span class="keyword">const</span> Foo&amp; other)：拷贝构造函数。</span><br><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; other)：赋值运算。</span><br><span class="line"><span class="keyword">void</span> Swap(Foo* other)：用另一个消息交换内容。</span><br><span class="line"><span class="keyword">const</span> UnknownFieldSet&amp; unknown_fields() <span class="keyword">const</span>：返回解析此消息时遇到的一组未知字段。</span><br><span class="line">UnknownFieldSet* mutable_unknown_fields()：返回指向解析此消息时遇到的未知字段的可变集的指针。</span><br></pre></td></tr></table></figure><p>该类还定义了以下静态方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Descriptor* <span class="title">descriptor</span><span class="params">()</span></span></span><br><span class="line">- 返回类型的描述符。这包含有关类型的信息，包括它的字段和它们的类型。这可以用映射以编程方式检查字段。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Foo&amp; <span class="title">default_instance</span><span class="params">()</span></span></span><br><span class="line">- 返回一个const单例实例Foo与新构造的实例相同Foo（所有单个字段未设置，所有重复字段都为空）。请注意，消息的默认实例可以被用作工厂通过调用其New()方法。</span><br></pre></td></tr></table></figure><p><code>message</code>可以在另一个<code>message</code>中声明。例如：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123; message Bar &#123; &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>在这种情况下，编译器生成两个类：<code>Foo</code>和<code>Foo_Bar</code>。另外，编译器会在<code>Foo</code>类下生成一个<code>typedef</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Foo_Bar Bar;</span><br></pre></td></tr></table></figure><p>这意味着您可以使用嵌套类型的类，就像它是嵌套类<code>Foo::Bar</code>一样。但是，请注意，<code>C++</code>不允许向前声明嵌套类型。如果要在另一个文件中转发声明并使用该声明，则必须将其标识为<code>Foo_Bar</code>。</p><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><p>除了上一节中描述的方法之外，<code>protocol</code>缓冲区编译器为<code>.proto</code>文件中的消息中定义的每个字段生成一组访问方法。</p><p>除了访问器方法之外，编译器还会为包含其字段编号的每个字段生成一个整数常量。常数名称是字母<code>k</code>，后跟字段名称转换为驼峰法，后跟<code>FieldNumber</code>。例如，给定该字段<code>optional int32 foo_bar = 5;</code>;编译器将生成常量<code>static const int kFooBarFieldNumber = 5;</code>。</p><p>对于返回<code>const</code>引用的字段访问器，当对消息进行下一个修改访问时，该引用可能会无效。这包括调用任何<code>const</code>字段的任何非访问者，通过其他方法（例如，使用该消息作为参数）调用<code>const</code>继承<code>Message</code>或修改消息的任何非方法<code>Swap()</code>。相应地，如果在此期间没有对消息进行任何修改访问，返回引用的地址只能在访问器的不同调用中保持相同。</p><p>对于返回指针的字段访问器，当对消息进行下一个修改或不修改访问时，该指针可能无效。这包括，不管<code>const</code>是什么，调用任何字段的任何访问者，<code>Message</code>通过其他方式调用继承或访问消息的任何方法（例如，通过使用复制构造函数复制消息）。相应地，返回的指针的值不能保证在访问器的两个不同调用中是相同的。</p><h4 id="Singular-Numeric-Fields-proto2"><a href="#Singular-Numeric-Fields-proto2" class="headerlink" title="Singular Numeric Fields (proto2)"></a>Singular Numeric Fields (proto2)</h4><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line">int32 foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line">void set_foo(int32 value)：设置字段的值。调用后，has_foo()将返回true并foo()返回value。</span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br></pre></td></tr></table></figure><p>对于其他数字字段类型（包括<code>bool</code>），<code>int32</code>将根据标量值类型表替换为相应的<code>C++</code>类型。</p><h4 id="Singular-Numeric-Fields-proto3"><a href="#Singular-Numeric-Fields-proto3" class="headerlink" title="Singular Numeric Fields (proto3)"></a>Singular Numeric Fields (proto3)</h4><p>对于此字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 foo() const：返回字段的当前值。如果未设置该字段，则返回0。</span><br><span class="line">void set_foo(int32 value)：设置字段的值。调用后，foo()会返回value。</span><br><span class="line">void clear_foo()：清除字段的值。调用这个之后，foo()会返回0。</span><br></pre></td></tr></table></figure><p>对于其他数字字段类型（包括<code>bool</code>），<code>int32</code>将根据标量值类型表替换为相应的<code>C++</code>类型。</p><h4 id="Singular-String-Fields-proto2"><a href="#Singular-String-Fields-proto2" class="headerlink" title="Singular String Fields (proto2)"></a>Singular String Fields (proto2)</h4><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：</span><br><span class="line">返回<span class="literal">true</span>是否设置了该字段。</span><br><span class="line"></span><br><span class="line">const string&amp; foo() const：</span><br><span class="line">返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：</span><br><span class="line">设置字段的值。调用后，has_foo()将返回<span class="literal">true</span>并foo()返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">使用C风格的以null结尾的字符串设置字段的值。调用后，has_foo()将返回<span class="literal">true</span>并foo()返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">返回指向可变<span class="built_in">string</span>对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空（而不是默认值）。调用它后，has_foo()将返回<span class="literal">true</span>并foo()返回任何写入给定字符串的值。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">将<span class="built_in">string</span>对象设置为字段，并释放前一个字段值（如果存在）。如果<span class="built_in">string</span>指针不是<span class="literal">NULL</span>，消息将获取所分配的<span class="built_in">string</span>对象的所有权并has_foo()返回<span class="literal">true</span>。否则，如果value是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">释放字段的所有权并返回<span class="built_in">string</span>对象的指针。调用该<span class="built_in">string</span>函数后，调用者将获取已分配对象的所有权，has_foo()将返回<span class="literal">false</span>，并foo()返回默认值。</span><br></pre></td></tr></table></figure><h4 id="Singular-String-Fields-proto3"><a href="#Singular-String-Fields-proto3" class="headerlink" title="Singular String Fields (proto3)"></a>Singular String Fields (proto3)</h4><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; foo() const：返回字段的当前值。如果未设置该字段，则返回空字符串/空字节。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：设置字段的值。调用后，foo()会返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">使用C风格的以null结尾的字符串设置字段的值。调用后，foo()会返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">返回指向可变<span class="built_in">string</span>对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空。调用它之后，foo()将返回写入给定字符串的任何值。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。</span><br><span class="line">调用这个之后，foo()将返回空字符串/空字节。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">将<span class="built_in">string</span>对象设置为字段，并释放前一个字段值（如果存在）。如果<span class="built_in">string</span>指针不是<span class="literal">NULL</span>，该消息将占用所分配<span class="built_in">string</span>对象的所有权。否则，如果value是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">释放字段的所有权并返回<span class="built_in">string</span>对象的指针。调用该方法后，调用者将获取已分配<span class="built_in">string</span>对象的所有权，并foo()返回空字符串/空字节。</span><br></pre></td></tr></table></figure><h4 id="Singular-Enum-Fields-proto2"><a href="#Singular-Enum-Fields-proto2" class="headerlink" title="Singular Enum Fields (proto2)"></a>Singular Enum Fields (proto2)</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> Bar foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line"></span><br><span class="line">Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：设置字段的值。</span><br><span class="line">调用后，has_foo()将返回<span class="literal">true</span>并foo()返回value。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br></pre></td></tr></table></figure><h4 id="Singular-Enum-Fields-proto3"><a href="#Singular-Enum-Fields-proto3" class="headerlink" title="Singular Enum Fields (proto3)"></a>Singular Enum Fields (proto3)</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值（0）。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：设置字段的值。打电话后，foo()会返回value。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用该命令后，foo()将返回默认值。</span><br></pre></td></tr></table></figure></p><h4 id="Singular-Embedded-Message-Fields"><a href="#Singular-Embedded-Message-Fields" class="headerlink" title="Singular Embedded Message Fields"></a>Singular Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proto2</span></span><br><span class="line"><span class="keyword">optional</span> Bar foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proto3</span></span><br><span class="line">Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo() const：</span><br><span class="line">返回字段的当前值。如果未设置该字段，则返回一个不设置Bar其字段（可能Bar::default_instance()）的字段。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo()：</span><br><span class="line">返回指向可变Bar对象的指针，该对象存储字段的值。如果在调用之前没有设置该字段，则返回Bar的字段将不会设置任何字段（即它将与新分配的相同Bar）。调用这个之后，has_foo()将返回<span class="literal">true</span>并foo()返回对同一个实例的引用Bar。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">清除字段的值。调用它后，has_foo()将返回<span class="literal">false</span>并foo()返回默认值。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(Bar* bar)：</span><br><span class="line">将Bar对象设置为字段，并释放前一个字段值（如果存在）。如果Bar指针不是<span class="literal">NULL</span>，消息将获取所分配的Bar对象的所有权并has_foo()返回<span class="literal">true</span>。否则，如果Bar是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">Bar* release_foo()：</span><br><span class="line">释放字段的所有权并返回Bar对象的指针。调用该Bar函数后，调用者将获取已分配对象的所有权，has_foo()将返回<span class="literal">false</span>，并foo()返回默认值。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Numeric-Fields"><a href="#Repeated-Numeric-Fields" class="headerlink" title="Repeated Numeric Fields"></a>Repeated Numeric Fields</h4><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">int32 foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, int32 value)：设置给定基于零的索引的元素的值。</span><br><span class="line"></span><br><span class="line">void add_foo(int32 value)：用给定的值追加一个新元素到该字段。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedField&lt;int32&gt;&amp; foo() <span class="keyword">const</span>：</span><br><span class="line">返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedField&lt;int32&gt;* mutable_foo()：</span><br><span class="line">返回指向RepeatedField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。对于其他数字字段类型（包括<span class="keyword">bool</span>），int32将根据标量值类型表替换为相应的C ++类型。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-String-Fields"><a href="#Repeated-String-Fields" class="headerlink" title="Repeated String Fields"></a>Repeated String Fields</h4><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">const string&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const string&amp; value)：设置给定基于零的索引的元素的值。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const char* value)：使用C风格的以null结尾的字符串来设置给定基于零的索引处的元素的值。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo(int index)：返回一个指向可变string对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void add_foo(const string&amp; value)：用给定的值追加一个新元素到该字段。</span><br><span class="line"></span><br><span class="line">void add_foo(const char* value)：使用C风格的以null结尾的字符串向字段添加一个新元素。</span><br><span class="line"></span><br><span class="line">void add_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* add_foo()：添加一个新的空字符串元素并返回一个指针。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedPtrField&lt;<span class="built_in">string</span>&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedPtrField&lt;<span class="built_in">string</span>&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Enum-Fields"><a href="#Repeated-Enum-Fields" class="headerlink" title="Repeated Enum Fields"></a>Repeated Enum Fields</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">Bar foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, Bar value)：设置给定基于零的索引的元素的值。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void add_foo(Bar value)：用给定的值追加一个新元素到该字段。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedField&lt;<span class="keyword">int</span>&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedField&lt;<span class="keyword">int</span>&gt;* mutable_foo()：返回指向RepeatedField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Embedded-Message-Fields"><a href="#Repeated-Embedded-Message-Fields" class="headerlink" title="Repeated Embedded Message Fields"></a>Repeated Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo(int index)：返回一个指向可变Bar对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">Bar* add_foo()：添加一个新元素并返回一个指针。返回的Bar将不会设置任何字段（即它将与新分配的相同Bar）。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedPtrField&lt;Bar&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedPtrField&lt;Bar&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure><h4 id="Oneof-Numeric-Fields"><a href="#Oneof-Numeric-Fields" class="headerlink" title="Oneof Numeric Fields"></a>Oneof Numeric Fields</h4><p>对于这个oneof字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">int32 foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(int32 value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value，并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果不是，情况不会改变kFoo。</span><br><span class="line">- 如果一个情况是kFoo，清除字段的值和一个<span class="keyword">case</span>。has_foo()（仅限proto2）将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><p>对于其他数字字段类型（包括bool）， int32将根据标量值类型表替换为相应的C ++类型。</p><h4 id="Oneof-String-Fields"><a href="#Oneof-String-Fields" class="headerlink" title="Oneof String Fields"></a>Oneof String Fields</h4><p>对于任何这些oneof字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">const string&amp; foo() const：如果一种情况，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原始<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 使用C风格的空值终止的字符串设置字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原始<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- kFoo将一个<span class="keyword">case</span>设置为并返回一个指向可变字符串对象的指针，该对象存储字段的值。如果一个情况不在kFoo调用之前，则返回的字符串将为空（而不是默认值）。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回任何写入给定字符串的值，oneof_name_case()并返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是kFoo，任何事情都不会改变。</span><br><span class="line">- 如果一个案例是kFoo，释放字段并清除一个<span class="keyword">case</span>。has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">- 电话clear_oneof_name()。</span><br><span class="line">- 如果字符串指针不是<span class="literal">NULL</span>：将字符串对象设置为字段并将其设置为一个kFoo。该消息将获取已分配的字符串对象的所有权，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>并oneof_name_case()返回kFoo。</span><br><span class="line">- 如果字符串指针是<span class="literal">NULL</span>，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">- <span class="literal">NULL</span>如果一个情况不是返回kFoo。</span><br><span class="line">- 清除一个情况，释放该字段的所有权并返回字符串对象的指针。调用这个之后，调用者占用所分配的字符串对象，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><h4 id="Oneof-Enum-Fields"><a href="#Oneof-Enum-Fields" class="headerlink" title="Oneof Enum Fields"></a>Oneof Enum Fields</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于oneof字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof oneof_name &#123;</span><br><span class="line">    Bar foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">Bar foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line">- 在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是，任何事情都不会改变kFoo。</span><br><span class="line">- 如果一个案例是kFoo，清除字段的值和一个<span class="keyword">case</span>。has_foo()（仅限proto2）将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure><h4 id="Oneof-Embedded-Message-Fields"><a href="#Oneof-Embedded-Message-Fields" class="headerlink" title="Oneof Embedded Message Fields"></a>Oneof Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于oneof字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof oneof_name &#123;</span><br><span class="line">    Bar foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：如果一个case返回true kFoo。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回Bar::default_instance()。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo()：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- kFoo将一个情况设置为并返回一个指向可变的Bar对象的指针，该对象存储该字段的值。如果一个情况不在kFoo调用之前，则返回的栏将不会设置任何字段（即它将与新分配的Bar相同）。</span><br><span class="line">- 调用这个之后，has_foo()会返回<span class="literal">true</span>，foo()将返回一个引用到同一个实例Bar并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是，任何事情都不会改变kFoo。</span><br><span class="line">- 如果一个情况相等kFoo，则释放该字段并清除该情况。has_foo()将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(Bar* bar)：</span><br><span class="line">- 电话clear_oneof_name()。</span><br><span class="line">- 如果Bar指针不是<span class="literal">NULL</span>：将Bar对象设置为字段并将其设置为一个kFoo。该消息占用所分配的Bar对象，has_foo（）将返回<span class="literal">true</span>，而oneof_name_case（）将返回kFoo。</span><br><span class="line">- 如果指针是<span class="literal">NULL</span>，has_foo()将返回<span class="literal">false</span>并oneof_name_case()返回ONEOF_NAME_NOT_SET。（行为就像调用clear_oneof_name()）</span><br><span class="line"></span><br><span class="line">Bar* release_foo()：</span><br><span class="line">- <span class="literal">NULL</span>如果一个情况不是返回kFoo。</span><br><span class="line">- 如果一种情况是kFoo，清除一种情况，释放该字段的所有权并返回该Bar对象的指针。调用这个之后，调用者占用所分配的Bar对象，has_foo()将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><h4 id="Map-Fields"><a href="#Map-Fields" class="headerlink" title="Map Fields"></a>Map Fields</h4><p>对于此Map字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">int32</span>, <span class="built_in">int32</span>&gt; weight = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> google::protobuf::Map&lt;int32, int32&gt;&amp; weight();：返回一个不可变的Map。</span><br><span class="line">google::protobuf::Map&lt;int32, int32&gt;* mutable_weight();：返回一个可变的Map。</span><br></pre></td></tr></table></figure></p><p>一个<code>google::protobuf::Map</code>是用于存储映射字段的协议缓冲区中使用的特殊容器类型。从下面的界面可以看出，它使用常用的子集<code>std::map</code>和<code>std::unordered_map</code>方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt; &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">  <span class="comment">// Member types</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> ... value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterators</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> Key&amp; key);</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">at</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lookup</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; value);</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>);</span></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp; Key)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy</span></span><br><span class="line">  Map(<span class="keyword">const</span> Map&amp; other);</span><br><span class="line">  Map&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Map&amp; other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加数据的最简单的方法是使用普通的地图语法，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ProtoName&gt; my_enclosing_proto(<span class="keyword">new</span> ProtoName);</span><br><span class="line">(*my_enclosing_proto-&gt;mutable_weight())[my_key] = my_value;</span><br></pre></td></tr></table></figure><p><code>pair&lt;iterator, bool&gt; insert(const value_type&amp; value)</code>将隐含地导致<code>value_type</code>实例的深层副本。将新值插入到一个最有效的方法<code>google::protobuf::Map</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> Key&amp; key): <span class="built_in">map</span>[new_key] = new_mapped;</span><br></pre></td></tr></table></figure><p>使用<code>google::protobuf::Map</code>标准<code>Map</code></p><p><code>google::protobuf::Map</code>支持相同的迭代器<code>API</code>的<code>std::map</code>和<code>std::unordered_map</code>。如果您不想<code>google::protobuf::Map</code>直接使用，可以<code>google::protobuf::Map</code>通过执行以下操作转换为标准<code>Map</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;int32, int32&gt; standard_map(message.weight().begin(),</span><br><span class="line">                                    message.weight().end());</span><br></pre></td></tr></table></figure><p>请注意，这将使整个Map的深层副本。</p><p>您还可以<code>google::protobuf::Map</code>按照以下方式从标准映射构建一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google::protobuf::Map&lt;int32, int32&gt; weight(standard_map.begin(), standard_map.end());</span><br></pre></td></tr></table></figure><p>解析未知值</p><p>在线上，<code>.proto</code>映射等效于每个<code>key/value</code>对的映射条目消息，而映射本身是映射条目的重复字段。像普通消息类型一样，解析的映射条目消息可能具有未知字段：例如，<code>int64</code>定义为映射的映射中的类型字段<code>map&lt;int32, string&gt;</code>。</p><p>如果Map条目消息的有线格式中有未知字段，则它们将被丢弃。</p><p>如果Map条目消息的有线格式中有一个未知的枚举值，那么它在<code>proto2</code>和<code>proto3</code>中的处理方式不同。在<code>proto2</code>中，将整个map条目消息放入包含消息的未知字段集中。在<code>proto3</code>中，它被放入一个映射字段，就像它是一个已知的枚举值一样。</p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>给出一个<code>Any</code>这样的字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">  google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们生成的代码中，该<code>details</code>字段的<code>getter</code>返回一个实例<code>google::protobuf::Any</code>。这提供了以下特殊方法来打包和解压缩Any的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Packs the given message into this Any using the default type URL</span></span><br><span class="line">  <span class="comment">// prefix “type.googleapis.com”.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PackFrom</span><span class="params">(<span class="keyword">const</span> google::protobuf::Message&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packs the given message into this Any using the given type URL</span></span><br><span class="line">  <span class="comment">// prefix.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PackFrom</span><span class="params">(<span class="keyword">const</span> google::protobuf::Message&amp; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; type_url_prefix)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unpacks this Any to a Message. Returns false if this Any</span></span><br><span class="line">  <span class="comment">// represents a different protobuf type or parsing fails.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">UnpackTo</span><span class="params">(google::protobuf::Message* message)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if this Any represents the given protobuf type.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">Is</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><p>给定一个这样的定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">int32</span> foo_int = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">string</span> foo_string = <span class="number">9</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下<code>C++</code>枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum OneofNameCase &#123;</span><br><span class="line">  kFooInt = 4,</span><br><span class="line">  kFooString = 9,</span><br><span class="line">  ONEOF_NAME_NOT_SET = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，它会产生这种方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneofNameCase oneof_name_case() const：返回指定哪个字段被设置的枚举。ONEOF_NAME_NOT_SET如果没有设置它们返回。</span><br></pre></td></tr></table></figure></p><p>编译器还生成以下私有方法，它在一个字段访问器中使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clear_oneof_name()：如果一个字段集使用一个指针（Message或String），并设置一个case，则释放该对象ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure><h3 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h3><p>给定一个枚举定义，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Foo &#123;</span><br><span class="line">  VALUE_A = 0;</span><br><span class="line">  VALUE_B = 5;</span><br><span class="line">  VALUE_C = 1234;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议缓冲区编译器将生成一个<code>Foo</code>使用相同值进行调用的<code>C++</code>枚举类型。此外，编译器将生成以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const EnumDescriptor* Foo_descriptor()：返回类型的描述符，其中包含有关此枚举类型定义的值的信息。</span><br><span class="line"></span><br><span class="line">bool Foo_IsValid(int value)：true如果给定的数值与其中一个Foo定义的值匹配，则返回。在上面的例子中，true如果输入为0,5或1234 ，则返回。</span><br><span class="line"></span><br><span class="line">const string&amp; Foo_Name(int value)：</span><br><span class="line">返回给定数值的名称。如果不存在这样的值，则返回一个空字符串。如果多个值具有此数字，则返回第一个定义的值。在上面的例子中，Foo_Name(<span class="number">5</span>)会返回<span class="string">"VALUE_B"</span>。</span><br><span class="line"></span><br><span class="line">bool Foo_Parse(const string&amp; name, Foo* value)：</span><br><span class="line">如果name是此枚举的有效值名称，则将该值分配value并返回<span class="literal">true</span>。否则返回<span class="literal">false</span>。在上面的例子中，Foo_Parse(<span class="string">"VALUE_C"</span>, &amp;someFoo)将返回<span class="literal">true</span>并设置someFoo为<span class="number">1234</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo Foo_MIN：枚举的最小有效值（示例中为VALUE_A）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo Foo_MAX：枚举的最大有效值（在示例中为VALUE_C）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Foo_ARRAYSIZE：总是定义为Foo_MAX + <span class="number">1</span>。</span><br></pre></td></tr></table></figure><blockquote><p>将整数转换为proto2枚举时要小心。 如果将整数转换为proto2枚举值，则该整数必须是枚举以外的有效值之一，否则结果可能未定义。如果有疑问，请使用生成的Foo_IsValid()函数来测试该转换是否有效。将proto2消息的枚举类型字段设置为无效值可能会导致断言失败。如果在解析proto2消息时读取一个无效的枚举值，它将被视为未知字段。这些语义在proto3中已经改变了。只要适用于int32，就可以将任何整数转换为proto3枚举值。在解析proto3消息并由枚举字段访问器返回时，也将保留无效的枚举值。</p><p>在switch语句中使用proto3枚举时要小心。Proto3枚举是打开的枚举类型，可能的值超出了指定符号的范围。在解析proto3消息并由枚举字段访问器返回时，将不会识别到枚举值。在没有默认情况下的proto3枚举上的switch语句将无法捕获所有情况，即使列出了所有已知字段。这可能会导致意外的行为，包括数据损坏和运行时崩溃。始终添加默认情况，或者Foo_IsValid(int)在交换机外部显式调用以处理未知的枚举值。</p></blockquote><p>您可以在消息类型中定义一个枚举。在这种情况下，协议缓冲区编译器会生成代码，使得它看起来是枚举类型本身被声明为嵌套在消息的类中。在Foo_descriptor()与Foo_IsValid()函数声明为静态方法。实际上，枚举类型本身及其值在全局范围内被声明为具有变量名称，并且通过typedef和一系列常量定义导入到类的范围内。这只是为了避免声明排序的问题。不要依赖于被破坏的顶级名称; 假装枚举真的嵌套在消息类中。</p><h3 id="Extensions-proto2-only"><a href="#Extensions-proto2-only" class="headerlink" title="Extensions (proto2 only)"></a>Extensions (proto2 only)</h3><p>给定一个扩展范围的消息：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  extensions 100 to 199;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该协议缓冲编译器将产生一些额外的方法<code>Foo</code>： <code>HasExtension()</code>，<code>ExtensionSize()</code>，<code>ClearExtension()</code>，<code>GetExtension()</code>，<code>SetExtension()</code>，<code>MutableExtension()</code>，<code>AddExtension()</code>，<code>SetAllocatedExtension()</code>和<code>ReleaseExtension()</code>。作为其第一参数，这些方法中的每一个都采用标识扩展字段的扩展标识符（如下所述）。剩余的参数和返回值与对于与扩展标识符相同类型的普通（非扩展）字段生成的相应存取器方法的参数和返回值完全相同。（<code>GetExtension()</code>对应于没有特殊前缀的访问器）</p><p>给定一个扩展定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> repeated_bar = <span class="number">124</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单个扩展字段<code>bar</code>，协议缓冲区编译器生成一个调用的扩展标识符 <code>bar</code>，您可以使用它们<code>Foo</code>的扩展访问器来访问此扩展，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">assert(!foo.HasExtension(bar));</span><br><span class="line">foo.SetExtension(bar, <span class="number">1</span>);</span><br><span class="line">assert(foo.HasExtension(bar));</span><br><span class="line">assert(foo.GetExtension(bar) == <span class="number">1</span>);</span><br><span class="line">foo.ClearExtension(bar);</span><br><span class="line">assert(!foo.HasExtension(bar));</span><br></pre></td></tr></table></figure><p>类似地，对于重复的扩展字段<code>repeated_bar</code>，编译器生成一个调用的扩展标识符<code>repeated_bar</code>，您也可以使用Foo扩展名的扩展名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSize; ++i) &#123;</span><br><span class="line">  foo.AddExtension(repeated_bar, i)</span><br><span class="line">&#125;</span><br><span class="line">assert(foo.ExtensionSize(repeated_bar) == kSize)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSize; ++i) &#123;</span><br><span class="line">  assert(foo.GetExtension(repeated_bar, i) == i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（扩展名标识符的确切实现是复杂的，涉及神奇使用模板 - 但是，您不需要担心扩展名标识符如何使用它们。）</p><p>扩展可以被声明为嵌套在另一种类型之内。例如，一个常见的模式是做这样的事情：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional Baz foo_ext = 124;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，扩展名标识符<code>foo_ext</code>被声明嵌套在里面<code>Baz</code>。可以使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">Baz* baz = foo.MutableExtension(Baz::foo_ext);</span><br><span class="line">FillInMyBaz(baz);</span><br></pre></td></tr></table></figure><h3 id="Arena-Allocation"><a href="#Arena-Allocation" class="headerlink" title="Arena Allocation"></a>Arena Allocation</h3><p>Arena分配<br>是一个仅<code>C++</code>功能，可帮助您优化内存使用情况，并在使用协议缓冲区时提高性能。在您<code>.proto</code>的<code>C++</code>生成的代码中添加额外的代码来使用Arena分配。您可以在“Arena分配指南”中了解有关竞技场分配<code>API</code>的更多信息。</p><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>如果<code>.proto</code>文件包含以下行：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>然后，协议缓冲区编译器将根据本节中所述的文件中找到的服务定义生成代码。然而，所生成的代码可能是不期望的，因为它不与任何特定的<code>RPC</code>系统相关联，并且因此需要针对一个系统进行编码的更多级别的间接代码。如果您不希望生成此代码，请将此行添加到文件中：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果不给出上述任何一行，则该选项默认 <code>false</code>为通用服务已被弃用。（请注意，在2.4.0之前，该选项默认为<code>true</code>）</p><p>基于<code>.proto</code>语言服务定义的RPC系统应该提供插件来为系统生成代码。这些插件可能要求抽象服务被禁用，以便它们可以生成自己的同名的类。插件是新版本2.3.0（2010年1月）。</p><p>本节的其余部分描述了启用抽象服务时协议缓冲区编译器生成的内容。</p><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><p>给定服务定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service Foo &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">Bar</span><span class="params">(FooRequest)</span> <span class="title">returns</span><span class="params">(FooResponse)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议缓冲区编译器将生成一个类Foo来表示此服务。 Foo将为服务定义中定义的每个方法设置虚拟方法。在这种情况下，该方法Bar定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bar</span><span class="params">(RpcController* controller, <span class="keyword">const</span> FooRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                 FooResponse* response, Closure* done)</span></span>;</span><br></pre></td></tr></table></figure><p>参数等同于参数<code>Service::CallMethod()</code>，除了<code>method</code>参数是隐含的，<code>request</code>和<code>response</code>指定其确切类型。</p><p>这些生成的方法是虚的，但不是纯虚的。默认实现只需调用一个<code>controller-&gt;SetFailed()</code>错误消息，指示该方法未实现，然后调用回调<code>done</code>。实现自己的服务时，您必须对此生成的服务进行子类化，并根据需要实现其方法。</p><p>Foo子类Service接口。协议缓冲区编译器自动生成方法的实现Service如下：</p><ul><li>GetDescriptor：返回服务的ServiceDescriptor。</li><li>CallMethod：根据提供的方法描述符确定正在调用哪个方法，并直接调用它，将请求和响应消息对象降级到正确的类型。</li><li>GetRequestPrototype和GetResponsePrototype：返回给定方法的正确类型的请求或响应的默认实例。</li></ul><p>还会生成以下静态方法：</p><ul><li><code>static ServiceDescriptor descriptor()</code>：返回类型的描述符，其中包含有关此服务具有哪些方法及其输入和输出类型的信息。</li></ul><h4 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h4><p>协议缓冲区编译器还生成每个服务接口的“stub”实现，由客户端希望向执行服务的服务器发送请求使用。对于Foo服务（上），<code>Foo_Stub</code>将定义存根实现。与嵌套消息类型一样，使用<code>typedef Foo_Stub</code>也可以被称为<code>Foo::Stub</code>。</p><p>Foo_Stub是一个子类Foo也实现了以下方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo_Stub(RpcChannel* channel)：构造在给定通道上发送请求的新存根。</span><br><span class="line">Foo_Stub(RpcChannel* channel, ChannelOwnership ownership)：构造一个新的存根，在给定的通道上发送请求，并且可能拥有该通道。如果ownership是，Service::STUB_OWNS_CHANNEL当存根对象被删除时，它也会删除该通道。</span><br><span class="line">RpcChannel* channel()：返回此存根的通道，传递给构造函数。</span><br></pre></td></tr></table></figure></p><p>存根附加地将每个服务的方法实现为通道周围的包装器。调用一种方法简单地调用<code>channel-&gt;CallMethod()</code>。</p><p>协议缓冲库不包括RPC实现。但是，它包括将生成的服务类连接到您选择的任意任意RPC实现所需的所有工具。您只需要提供RpcChannel和的实现RpcController。有关service.h详细信息，请参阅文档。</p><h3 id="Plugin-Insertion-Points"><a href="#Plugin-Insertion-Points" class="headerlink" title="Plugin Insertion Points"></a>Plugin Insertion Points</h3><p>要扩展C ++代码生成器的输出的代码生成器插件可以使用给定的插入点名称插入以下类型的代码。除非另有说明，否则每个插入点都显示在.pb.cc文件和.pb.h文件中。</p><ul><li>includes：包含指令。</li><li>namespace_scope：属于文件包/命名空间但不在任何特定类中的声明。出现在所有其他命名空间范围代码之后。</li><li>global_scope：属于文件命名空间之外的顶层的声明。出现在文件的最后端。</li><li>class_scope:TYPENAME：属于消息类的成员声明。 TYPENAME是完整的原名，例如package.MessageType。在课后所有其他公开声明后出现。此插入点仅显示在.pb.h文件中。</li></ul><blockquote><p>不要生成依赖于标准代码生成器声明的私有类成员的代码，因为这些实现细节可能会在将来版本的协议缓冲区中更改。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> protobuf </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批处理git命令</title>
      <link href="/2017/07/13/%E6%89%B9%E5%A4%84%E7%90%86git%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/07/13/%E6%89%B9%E5%A4%84%E7%90%86git%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>每次更新博客，都需要输入大量指令来同步github，那么是否可以批处理这些命令使之自动之行？</p><p>当然可以。</p><a id="more"></a><p>比如，我在hexo文件夹下有hexo博客文件，那么我只需在此创建upload.sh文件并输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">git status</span><br><span class="line">git add -A</span><br><span class="line">git add -u</span><br><span class="line">git commit -m <span class="string">"Update at <span class="variable">$(date)</span>"</span></span><br><span class="line">git push origin master:mydesktop</span><br></pre></td></tr></table></figure><p>创建好之后，在git bash中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./upload.sh</span><br></pre></td></tr></table></figure><p>就会自动执行这一系列指令，省去了好多麻烦，敲一下，等待、喝杯咖啡、去个洗手间！！！</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="http://gubangzhong.cn/2016/11/09/git本地文件夹上传至github/">git本地文件夹上传至github</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows右键cmd</title>
      <link href="/2017/07/13/windows%E5%8F%B3%E9%94%AEcmd/"/>
      <url>/2017/07/13/windows%E5%8F%B3%E9%94%AEcmd/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在使用windows操作系统的时候，常常需要win+R打开cmd窗口，在此特记简单快捷方法如下：</p><p>按住shift键在指定文件夹下右击鼠标出现“在此处打开命令窗口(W)”，点击此，就会在指定文件夹下打开cmd。</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/28/Windows快捷键/">Windows文本快捷键</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>glog初步体验</title>
      <link href="/2017/07/13/glog%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/"/>
      <url>/2017/07/13/glog%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>最近看caffe源码，希望对源码中的每个知识点都吃透，遇到不会的记录。今天仅记录glog的一段测试代码，详细TBD。</p></blockquote><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog\logging.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">google::InitGoogleLogging(<span class="string">""</span>);</span><br><span class="line">google::SetLogDestination(google::GLOG_INFO, <span class="string">"./myInfo"</span>);</span><br><span class="line">LOG(INFO) &lt;&lt; <span class="string">"This is a message!"</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">CHECK_GT(a, <span class="number">3</span>) &lt;&lt; <span class="string">"a is little than 3!"</span>;</span><br><span class="line">google::ShutdownGoogleLogging();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Protobuf安装使用指南/">Protobuf安装使用指南</a></li><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> glog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类之虚函数,纯虚函数和普通函数</title>
      <link href="/2017/07/07/%E7%B1%BB%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2017/07/07/%E7%B1%BB%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本篇文章主要介绍了C++中的普通成员函数、虚函数以及纯虚函数,非常的详细，有需要的朋友可以参考下。</p></blockquote><p>普通成员函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数；</p><p>虚函数为了重载和多态的需要，在基类中定义的，即便定义为空；</p><p>纯虚函数是在基类中声明的虚函数，它可以再基类中有定义，且派生类必须定义自己的实现方法。</p><a id="more"></a><p>假设我们有三个类Person、Teacher、Student它们之间的关系如下：</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/class_virtual_function.png" alt="image"></p><p>类的关系图 </p><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo-1"></a>Demo-1</h3><p>根据这个类图，我们有下面的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OBJEDT_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __OBJEDT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> m_age; <span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age, <span class="keyword">const</span> <span class="built_in">string</span>&amp; title):</span><br><span class="line">        Person(name, age), m_title(title)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"职称："</span> &lt;&lt; m_title &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_title; <span class="comment">//职称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age, <span class="keyword">int</span> studyId): </span><br><span class="line">        Person(name, age), m_studyId(studyId)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"学号："</span> &lt;&lt; m_studyId &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> m_studyId;  <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__OBJEDT_H__</span></span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person* pPerson = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">22</span>);</span><br><span class="line">    Teacher* pTeacher = <span class="keyword">new</span> Teacher(<span class="string">"李四"</span>, <span class="number">35</span>, <span class="string">"副教授"</span>);</span><br><span class="line">    Student* pStudent = <span class="keyword">new</span> Student(<span class="string">"王五"</span>, <span class="number">18</span>, <span class="number">20151653</span>);</span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pPerson;</span><br><span class="line">    <span class="keyword">delete</span> pTeacher;</span><br><span class="line">    <span class="keyword">delete</span> pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br>这里的ShowInfo就是一个普通的函数。pPerson、pTeacher和pStudent三个对象调用ShowInfo分别展示自己的信息。<br>我们知道：父类的指针是可以指向子类的对象的。我们把上面的测试代码稍微改一下： </p></blockquote><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo-2"></a>Demo-2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18</span><br></pre></td></tr></table></figure><p>这时，pTeacher和pStudent只输出了姓名和年龄，并没有输出子类所具有的特性(职称和学号)。</p><p>这应该不是你期望的结果，你可能期望pTeacher和pStudent输出老师和学生的完整信息，这时就需要用虚函数。</p><p>虚函数</p><p>我们把Person中的ShowInfo成员改成虚函数(在前面加上virtual)，代码如下： </p><h3 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo-3"></a>Demo-3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual void ShowInfo()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    string m_name; //姓名</span><br><span class="line">    int m_age; //年龄</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行上面[Demo-2]中的测试代码，得到我们想到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><blockquote><p>虚函数用法要点：</p><ol><li>虚函数的声明方式：virtual RETURN_TYPE functionName(ARGS 参数列表);</li><li>虚函数作用：现实C++中的多态，进行动态绑定(父类指针可指向子类的对象)，直到运行时才知道要调用哪个版本(哪个类定义)的函数；</li><li>我们必要对虚函数进行定义；</li><li>一旦父类的成员函数声明virtual，其子类的函数不管有没有声明为virtual，都是虚函数；</li><li>如果虚函数使用默认实参，父类和子类定义的默认实参最好一致。</li></ol></blockquote><h3 id="Demo-4"><a href="#Demo-4" class="headerlink" title="Demo-4"></a>Demo-4</h3><p>针对第4点说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual void ShowInfo()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string GetName(); //正确，普通函数如果不被使用，可以只有声明没有定义</span><br><span class="line">    virtual int GetAge(); //错误，虚函数必须要有定义，即使是一个空实现,因为编译器无法确定会使用哪个函数</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    string m_name; //姓名</span><br><span class="line">    int m_age; //年龄</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Demo-5"><a href="#Demo-5" class="headerlink" title="Demo-5"></a>Demo-5</h3><p>针对第5点进行说明：<br>设计我们的类如下定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 0)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Teacher : public Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 1)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : public Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 2)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>测试1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Teacher* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Student* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;SetAge();</span><br><span class="line">    pTeacher-&gt;SetAge();</span><br><span class="line">    pStudent-&gt;SetAge();</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：0</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：1 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：2 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><p>测试2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;SetAge();</span><br><span class="line">    pTeacher-&gt;SetAge();</span><br><span class="line">    pStudent-&gt;SetAge();</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：0</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：0 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：0 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><p>纯虚函数<br>在上面的例子中，我们假设所有的人都要工作，但不同的人工作的方式不同。</p><p>于是我们就要强制要求继承自Person的子类都要有工作的方法，这就需要纯虚函数。</p><p>定义如下： </p><h3 id="Demo-6"><a href="#Demo-6" class="headerlink" title="Demo-6"></a>Demo-6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork() = 0;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但此时我们编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br></pre></td></tr></table></figure><p>这句话时会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2259: ‘Person&apos; : cannot instantiate abstract class</span><br></pre></td></tr></table></figure></p><p>这是因为我们并没有为Person实现DoWork方法，而包含纯虚函数的类是一个抽象的类，抽象类不能被实例化。</p><p>于是我们在子类中对它实现如下： </p><h3 id="Demo-7"><a href="#Demo-7" class="headerlink" title="Demo-7"></a>Demo-7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Teacher : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;教书...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;学习...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没用DoWork方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pTeacher-&gt;DoWork();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;DoWork();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">教书…</span><br><span class="line">学习…</span><br></pre></td></tr></table></figure><p>纯虚函数用法要点：</p><p>纯虚函数的声明方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual RETURN_TYPE functionName(ARGS 参数列表) = 0;</span><br></pre></td></tr></table></figure></p><p>含有纯虚函数的类是一个抽象的类，抽象类不能被实例化。</p><p>包含纯虚函数的抽象类常用来当作对外的接口，说明这个类有什么功能，而没有具体的实现，基体的实现交由子类完成。</p><p>通过以上对普通成员函数、虚函数以及纯虚函数的介绍，希望可以对大家有所帮助。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>原文链接<a href="http://www.jb51.net/article/69811.htm" target="_blank" rel="noopener">C++之普通成员函数、虚函数以及纯虚函数的区别与用法要点</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>白衬衫</title>
      <link href="/2017/07/06/%E7%99%BD%E8%A1%AC%E8%A1%AB/"/>
      <url>/2017/07/06/%E7%99%BD%E8%A1%AC%E8%A1%AB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>袁野夕的《白衬衫》</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=478057166&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 袁野夕 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VS创建动态链接库DLL</title>
      <link href="/2017/07/06/VS%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/"/>
      <url>/2017/07/06/VS%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>官网链接：<a href="https://msdn.microsoft.com/zh-cn/library/ms235636.aspx" target="_blank" rel="noopener">演练：创建和使用动态链接库 (C++)</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visual studio </tag>
            
            <tag> dll </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>matlab中的P代码</title>
      <link href="/2017/06/23/matlab%E4%B8%AD%E7%9A%84P%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/06/23/matlab%E4%B8%AD%E7%9A%84P%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><p>简单来说就是matlab中的加密代码，比M文件的优先级高，在和M文件同时存在时，优先调用P文件。</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一别经年</title>
      <link href="/2017/06/20/%E4%B8%80%E5%88%AB%E7%BB%8F%E5%B9%B4/"/>
      <url>/2017/06/20/%E4%B8%80%E5%88%AB%E7%BB%8F%E5%B9%B4/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>半夜，被鼻炎折磨，以致于睡不着，辗转反侧，手机本是放下复又拿起。APP翻来覆去，直至终于没啥可看。</p><p>半夜，总是怀念。</p><a id="more"></a><p>这学期没回过家，端午假期，于是早就计划利用假期回一趟。开始一切都好，而后母亲大人告诉我你陪你爸去医院看看，才知道父亲身体出了点状况。人到中年，难免会有这样或那样的病，作为人子而且是独生子女听到这样的话有点慌，毕竟没有经历过。焦躁，无助。正是农忙时，家里早已没有地了，只有屋前屋后的菜地，平时上班的父母还折腾点农作物，恰逢农忙，父亲执意要等农忙之后再去看。其实没啥可忙，就那点地，用我的话说，这还没你们一天的工资多呢。作为从那个年代走过来的父亲，多少会对我的言语反感，其实我也是关心则乱。无奈，本来在家甩手掌柜的我，也操起家伙帮他把作物收上来。用父亲的话说，他不弄，等他做完手术只有我妈一个人弄，她哪弄得过来，上班那么累。父亲还是心疼母亲的。于是执意倔强在手术前把该弄的弄好了。为此，我不得不延长假期。工作日就陪父亲去医院，医生说了手术，意料之中。于是就准备着，其实我也不知道准备什么，第一次经历。尽管医生说小手术，但还是担心，后来看是多余的。第一天手术叫了叔伯过来帮忙看着点，从进手术室开始无奈心慌，母亲也请了假，不知道她当时的心理。一小时过后，医生出来，手术顺利。期间我跑上跑下忙来忙去缓解自己紧张的情绪。后来就是漫长的陪床，也有埋怨父母不早点来看。后来静下来想想，又没多说什么，多说无益。总之，这个假期的经历难忘。父亲第三天就能下地慢慢走动了，于是父母开始催我回学校。用室友的话说，谁不心疼自己的孩子。而怕母亲忙不过来，所以一直待到快出院才回南京。父母年纪越大，开始越像小孩。我们之间的角色开始慢慢对调。这时，才感觉父母老了，头上已经有了白发，岁月无情镌刻了道道皱纹。此时才真正理解朱自清的背影所要表达的情感。</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/beiying_zhuziqing.jpg" alt="背影"></p><p>一别经年，曾是少年。</p><p>快到而立之年的我，难免怅然若失。身边好友一个个成家立业，回头看看自己，还在为自己心中的那点执着奋斗。现在回想，其实读不读这个博士都没有关系，工作只是工作，人还有其他追求。有时我走在路上，透过镜片看人来人往，有时也会想这个合适吗，然后擦肩而过。</p><p>习惯独来独往之后，可以肆无忌惮做想做的事，比如死宅。死宅之后，看了好多电影，弹了好多首歌，最后又吃了好多外卖。于是在体重飙升之后，又急忙开始跑步减肥。美其名曰，锻炼身体。于是开始收集网上的教程，指望能够毕其功于一役。可是，哪有这么美得好事。凡事因果，总有轮回。最近异形上映了，筹划着去看啊，然后瞅着一个人去没意思就没有然后了。有时，也会更新博客，想记录点滴，提笔忘词，遂又作罢，本来生活博客硬是写成了技术札记。也算是小有所得，无心插柳。</p><p>现在应该三更天了吧，鼻炎折磨好多了，明天应该快好了吧，俗话病来如山倒。<br>外面还有三两毕业生在说话，以前的我大概也是这样。一别经年，三号路，下马坊，你曾是少年。</p><p>丁酉丙午戊寅仅此小记聊慰长夜。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>visio安装配套</title>
      <link href="/2017/06/15/visio%E5%AE%89%E8%A3%85%E9%85%8D%E5%A5%97/"/>
      <url>/2017/06/15/visio%E5%AE%89%E8%A3%85%E9%85%8D%E5%A5%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>某由于实验室电脑即将坏掉，赶紧在自己的电脑上装上office套装，奈何以前装了好多次，好多流程还得重复试一遍，特此笔记，原谅老年人的健忘症。</p><p>由于是在学校，很多东西有学校特供版本，免去查找各种破解工具，某在学校微软正版化下载office 2013 professional plus安装后，不知道该装2013 32位还是64位版本，经测试之后，需下载32位版本进行安装。</p><p>好了，装完用学校的激活工具激活就可以开心的写论文了！！！👏👏👏👏👏👏👏👏</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> visio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chrome油猴脚本</title>
      <link href="/2017/06/13/Chrome%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
      <url>/2017/06/13/Chrome%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>跑程序之间，给大家推荐一个小程序，叫<a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">油猴脚本</a>，这是应用在浏览器中的脚本，很方便，安装很简单，在此不作介绍。</p><p>说说优点吧，可以跳过视频广告，可以直接观看VIP视频，还有诸多好处等你发现！！！！！！</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://LorrinWWW.github.io/posts/projet-enjeu-plugin-chrome-101/">Chrome插件开发 - Hello world</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows10安装多版本Python</title>
      <link href="/2017/06/11/Windows10%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACPython/"/>
      <url>/2017/06/11/Windows10%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACPython/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文主要简要记录在同一台windows10系统的电脑上安装多版本python用于科学计算。</p><a id="more"></a><blockquote><p>记录主要服务以后。</p></blockquote><p>由于anaconda集成了大量的python库，所以在此用anaconda代替。</p><p>在<a href="https://www.continuum.io/downloads/" target="_blank" rel="noopener">anaconda官网</a>下载最新的64位版本并安装，直到本文开始，python版本为3.6，注意：在安装过程中勾选上conda添加到系统路径以及python作为系统默认python版本。</p><p>上面这一步很简单，接下来完全是命令行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为python35的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.5.x中的最新版本）</span></span><br><span class="line">conda create -n python35 python=3.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用如下命令安装所有conda包</span></span><br><span class="line">conda create -n python35 python=3.5 anaconda</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装好后，使用activate激活某个环境</span></span><br><span class="line">activate python35 <span class="comment"># for Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想返回默认的python 3.6环境，运行</span></span><br><span class="line">deactivate python35 <span class="comment"># for Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个已有的环境</span></span><br><span class="line">conda remove --name python35 --all</span><br></pre></td></tr></table></figure><p>就是如此简单，如果需要安装2.7版本也一样。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://python.jobbole.com/86236/" target="_blank" rel="noopener">Anaconda使用总结</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/11/23/在python下利用opencv读取图片/">在python下利用opencv读取图片</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>邂逅日本</title>
      <link href="/2017/05/15/%E9%82%82%E9%80%85%E6%97%A5%E6%9C%AC/"/>
      <url>/2017/05/15/%E9%82%82%E9%80%85%E6%97%A5%E6%9C%AC/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><a id="more"></a><p>借开会时机，日本一游。</p><p>历史原因，本人对日本并无好感，总认为是一个无廉耻的民族。经此一游，某些方面改变自己的认识，从短暂的几天经历来说，至少日本人在表面上做的还是值得称赞的。我这里说表面上，因为时间短暂，不敢下最终结论，可能他们仅仅表现在表面上。如《菊与刀》所述，他们的另一面在短暂的时间里并不能完全体会到。</p><p>先这样吧，工作时间到了。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>caffe学习资料收集</title>
      <link href="/2017/04/25/caffe%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>/2017/04/25/caffe%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>一些有关caffe的资料收集，不定期更新！</p></blockquote><a id="more"></a><h3 id="simshang博客"><a href="#simshang博客" class="headerlink" title="simshang博客"></a>simshang博客</h3><ol><li><a href="http://simtalk.cn/2016/11/25/FCN-in-Caffe/" target="_blank" rel="noopener">FCN in Caffe</a></li><li><a href="http://simtalk.cn/2016/11/01/Fully-Convolutional-Networks/" target="_blank" rel="noopener">Fully Convolutional Networks</a></li><li><a href="http://simtalk.cn/2016/10/28/PyCaffe-in-Practice/" target="_blank" rel="noopener">PyCaffe in Practice</a></li></ol><h3 id="caffe如何自定义网络以及自定义层python版"><a href="#caffe如何自定义网络以及自定义层python版" class="headerlink" title="caffe如何自定义网络以及自定义层python版"></a>caffe如何自定义网络以及自定义层python版</h3><ol><li><a href="http://blog.csdn.net/langb2014/article/details/53081911" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（一）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53168473" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（二）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53258721" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（三）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53261179" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（四）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53309618" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（五）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53406491" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（六）</a></li></ol><h3 id="Caffe学习记录"><a href="#Caffe学习记录" class="headerlink" title="Caffe学习记录"></a>Caffe学习记录</h3><ol><li><a href="http://www.cnblogs.com/denny402/p/5041060.html" target="_blank" rel="noopener">caffe windows 学习第一步：编译和安装（vs2012+win 64)</a></li><li><a href="http://www.cnblogs.com/denny402/p/5041122.html" target="_blank" rel="noopener">caffe windows学习：第一个测试程序</a></li><li><a href="http://www.cnblogs.com/denny402/p/5067265.html" target="_blank" rel="noopener">Caffe学习系列(1)：安装配置ubuntu14.04+cuda7.5+caffe+cudnn</a></li><li><a href="http://www.cnblogs.com/denny402/p/5070928.html" target="_blank" rel="noopener">Caffe学习系列(2)：数据层及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5071126.html" target="_blank" rel="noopener">Caffe学习系列(3)：视觉层（Vision Layers)及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5072507.html" target="_blank" rel="noopener">Caffe学习系列(4)：激活层（Activiation Layers)及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5072746.html" target="_blank" rel="noopener">Caffe学习系列(5)：其它常用层及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5073427.html" target="_blank" rel="noopener">Caffe学习系列(6)：Blob,Layer and Net以及对应配置文件的编写</a></li><li><a href="http://www.cnblogs.com/denny402/p/5074049.html" target="_blank" rel="noopener">Caffe学习系列(7)：solver及其配置</a></li><li><a href="http://www.cnblogs.com/denny402/p/5074212.html" target="_blank" rel="noopener">Caffe学习系列(8)：solver优化方法</a></li><li><a href="http://www.cnblogs.com/denny402/p/5075490.html" target="_blank" rel="noopener">Caffe学习系列(9)：运行caffe自带的两个简单例子</a></li><li><a href="http://www.cnblogs.com/denny402/p/5076285.html" target="_blank" rel="noopener">Caffe学习系列(10)：命令行解析</a></li><li><a href="http://www.cnblogs.com/denny402/p/5082341.html" target="_blank" rel="noopener">Caffe学习系列(11)：图像数据转换成db（leveldb/lmdb)文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5083300.html" target="_blank" rel="noopener">Caffe学习系列(12)：训练和测试自己的图片</a></li><li><a href="http://www.cnblogs.com/denny402/p/5088399.html" target="_blank" rel="noopener">Caffe学习系列(13)：数据可视化环境（python接口)配置</a></li><li><a href="http://www.cnblogs.com/denny402/p/5092075.html" target="_blank" rel="noopener">Caffe学习系列(14)：初识数据可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5102328.html" target="_blank" rel="noopener">Caffe学习系列(15)：计算图片数据的均值</a></li><li><a href="http://www.cnblogs.com/denny402/p/5103425.html" target="_blank" rel="noopener">Caffe学习系列(16)：caffemodel可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5105911.html" target="_blank" rel="noopener">Caffe学习系列(17)：模型各层数据和参数可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5106764.html" target="_blank" rel="noopener">Caffe学习系列(18): 绘制网络模型</a></li><li><a href="http://www.cnblogs.com/denny402/p/5110204.html" target="_blank" rel="noopener">Caffe学习系列(19): 绘制loss和accuracy曲线</a></li><li><a href="http://www.cnblogs.com/denny402/p/5111018.html" target="_blank" rel="noopener">Caffe学习系列(20)：用训练好的caffemodel来进行分类</a></li><li><a href="http://www.cnblogs.com/denny402/p/5136155.html" target="_blank" rel="noopener">Caffe学习系列(21)：caffe图形化操作工具digits的安装与运行</a></li><li><a href="http://www.cnblogs.com/denny402/p/5136262.html" target="_blank" rel="noopener">Caffe学习系列(22)：caffe图形化操作工具digits运行实例</a></li><li><a href="http://www.cnblogs.com/denny402/p/5137534.html" target="_blank" rel="noopener">Caffe学习系列(23)：如何将别人训练好的model用到自己的数据上</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679037.html" target="_blank" rel="noopener">caffe的python接口学习（1）：生成配置文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679154.html" target="_blank" rel="noopener">caffe的python接口学习（2）：生成solver文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679204.html" target="_blank" rel="noopener">caffe的python接口学习（3）：训练模型（training)</a></li><li><a href="http://www.cnblogs.com/denny402/p/5684431.html" target="_blank" rel="noopener">caffe的python接口学习（4）：mnist实例—手写数字识别</a></li><li><a href="http://www.cnblogs.com/denny402/p/5685818.html" target="_blank" rel="noopener">caffe的python接口学习（5）：生成deploy文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5685909.html" target="_blank" rel="noopener">caffe的python接口学习（6）：用训练好的模型（caffemodel）来分类新的图片</a></li><li><a href="http://www.cnblogs.com/denny402/p/5686067.html" target="_blank" rel="noopener">caffe的python接口学习（7）：绘制loss和accuracy曲线</a></li><li><a href="http://www.cnblogs.com/denny402/p/5686257.html" target="_blank" rel="noopener">caffe的python接口学习（8）：caffemodel中的参数及特征的抽取</a></li></ol><h3 id="caffe代码阅读"><a href="#caffe代码阅读" class="headerlink" title="caffe代码阅读"></a>caffe代码阅读</h3><ol><li><a href="http://blog.csdn.net/xizero00/article/details/50886829" target="_blank" rel="noopener">caffe代码阅读1：blob的实现细节-2016.3.14</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50889126" target="_blank" rel="noopener">caffe代码阅读2：common的实现细节-2016.3.14</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50901204" target="_blank" rel="noopener">caffe代码阅读3：data_reader、internalthread以及blocking_queue的实现细节-2016.3.15</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50905685" target="_blank" rel="noopener">caffe代码阅读4：DataTransformer以及io的实现细节-2016.3.16</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50914471" target="_blank" rel="noopener">caffe代码阅读5：Layer的实现细节-2016.3.17</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50921692" target="_blank" rel="noopener">caffe代码阅读6：Filler的实现细节-2016.3.18</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50923722" target="_blank" rel="noopener">caffe代码阅读7：LayerRegistry的实现细节-2016.3.18</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50999630" target="_blank" rel="noopener">caffe代码阅读8: Data_layers的实现细节（各个数据读取层的实现细节） 2016.3.25-28</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/51001206" target="_blank" rel="noopener">caffe代码阅读9：SyncedMemory的实现细节-2016.3.28</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/51049858" target="_blank" rel="noopener">caffe代码阅读10：Caffe中卷积的实现细节（涉及到BaseConvolutionLayer、ConvolutionLayer、im2col等）-2016.4.3</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/52228425" target="_blank" rel="noopener">Caffe代码阅读11：absval_layer层的实现</a></li><li><a href="http://blog.csdn.net/u010402786/article/details/51262004" target="_blank" rel="noopener">Caffe各版本与源码全透析</a></li></ol><h3 id="大魔导师：从零开始山寨caffe"><a href="#大魔导师：从零开始山寨caffe" class="headerlink" title="大魔导师：从零开始山寨caffe"></a>大魔导师：从零开始山寨caffe</h3><ol><li><a href="http://www.cnblogs.com/neopenx/p/5187440.html" target="_blank" rel="noopener">从零开始山寨Caffe·零：必先利其器</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5187586.html" target="_blank" rel="noopener">从零开始山寨Caffe·壹：仰望星空与脚踏实地</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5190282.html" target="_blank" rel="noopener">从零开始山寨Caffe·贰：主存模型</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5194224.html" target="_blank" rel="noopener">从零开始山寨Caffe·叁：全局线程管理器</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5200519.html" target="_blank" rel="noopener">从零开始山寨Caffe·肆：线程系统</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5243188.html" target="_blank" rel="noopener">从零开始山寨Caffe·伍：Protocol Buffer简易指南</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5248102.html" target="_blank" rel="noopener">从零开始山寨Caffe·陆：IO系统(一)</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5269852.html" target="_blank" rel="noopener">从零开始山寨Caffe·柒：KV数据库</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5259197.html" target="_blank" rel="noopener">从零开始山寨Caffe·捌：IO系统(二)</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5294682.html" target="_blank" rel="noopener">从零开始山寨Caffe·玖：BlobFlow</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5315945.html" target="_blank" rel="noopener">从零开始山寨Caffe·拾：IO系统(三)</a></li><li><p><a href="http://www.cnblogs.com/neopenx/p/5322722.html" target="_blank" rel="noopener">从零开始山寨Caffe·拾贰：IO系统(四)</a></p></li><li><p><a href="http://blog.csdn.net/dengbingfeng/article/details/51469051" target="_blank" rel="noopener">caffe使用gdb单步调试及源码阅读</a></p></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51089864" target="_blank" rel="noopener">（Caffe，LeNet）IDE单步调试（一）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090114" target="_blank" rel="noopener">（Caffe，LeNet）网络训练流程（二）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090306" target="_blank" rel="noopener">（Caffe，LeNet）初始化训练网络（三）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090698" target="_blank" rel="noopener">（Caffe，LeNet）初始化测试网络（四）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51092906" target="_blank" rel="noopener">（Caffe，LeNet）前向计算（五）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51379395" target="_blank" rel="noopener">（Caffe，LeNet）反向传播（六）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51588773" target="_blank" rel="noopener">（Caffe，LeNet）权值更新（七）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51085654" target="_blank" rel="noopener">（Caffe）基本类Blob，Layer，Net（一）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088173" target="_blank" rel="noopener">（Caffe）基本类Solver、Caffe、Batch（二）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088262" target="_blank" rel="noopener">（Caffe）基本类InternalThread（三）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088361" target="_blank" rel="noopener">（Caffe）基本类DataReader、QueuePair、Body（四）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51699568" target="_blank" rel="noopener">（Caffe）基本类Filter（五）</a></li></ol><h3 id="知乎专栏：黑客与画家"><a href="#知乎专栏：黑客与画家" class="headerlink" title="知乎专栏：黑客与画家"></a>知乎专栏：黑客与画家</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/20377462" target="_blank" rel="noopener">深度学习源码解读-ch0-talk is cheap</a></li><li><a href="https://zhuanlan.zhihu.com/p/20399370" target="_blank" rel="noopener">深度学习源码解读-ch1-JSON is awesome</a></li><li><a href="https://zhuanlan.zhihu.com/p/20456504" target="_blank" rel="noopener">深度学习源码解读-ch3-部署 Caffe 网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/20456649" target="_blank" rel="noopener">深度学习源码解读-ch4-Caffe 中的设计模式</a></li></ol><h3 id="知乎专栏：无痛的机器学习"><a href="#知乎专栏：无痛的机器学习" class="headerlink" title="知乎专栏：无痛的机器学习"></a>知乎专栏：无痛的机器学习</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/21796890" target="_blank" rel="noopener">Caffe代码阅读——层次结构</a></li><li><a href="https://zhuanlan.zhihu.com/p/21875025" target="_blank" rel="noopener">Caffe源码阅读——Net组装</a></li><li><a href="https://zhuanlan.zhihu.com/p/21800004" target="_blank" rel="noopener">Caffe代码阅读——Solver</a></li><li><a href="https://zhuanlan.zhihu.com/p/22404295" target="_blank" rel="noopener">Caffe源码阅读——DataLayer&amp;Data Transformer</a></li></ol><h3 id="知乎专栏：晓雷机器学习笔记"><a href="#知乎专栏：晓雷机器学习笔记" class="headerlink" title="知乎专栏：晓雷机器学习笔记"></a>知乎专栏：晓雷机器学习笔记</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/25127756" target="_blank" rel="noopener">caffe源码解析-开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/25094900" target="_blank" rel="noopener">caffe源码解析-命令行接口</a></li><li><a href="https://zhuanlan.zhihu.com/p/25102232" target="_blank" rel="noopener">caffe源码解析-solver_factory</a></li></ol><h3 id="Caffe-Source-Code-Analysis"><a href="#Caffe-Source-Code-Analysis" class="headerlink" title="Caffe Source Code Analysis"></a><a href="https://buptldy.github.io/2016/10/09/2016-10-09-Caffe_Code/" target="_blank" rel="noopener">Caffe Source Code Analysis</a></h3><h3 id="CSDN博客：joshua-1988"><a href="#CSDN博客：joshua-1988" class="headerlink" title="CSDN博客：joshua_1988"></a>CSDN博客：<a href="http://blog.csdn.net/joshua_1988" target="_blank" rel="noopener">joshua_1988</a></h3><ol><li><a href="http://blog.csdn.net/joshua_1988/article/details/45036993" target="_blank" rel="noopener">VS2013配置Caffe卷积神经网络工具（64位Windows 7）——准备依赖库</a></li><li><a href="http://blog.csdn.net/joshua_1988/article/details/45048871" target="_blank" rel="noopener">VS2013配置Caffe卷积神经网络工具（64位Windows 7）——建立工程</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世界末日</title>
      <link href="/2017/04/22/%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5/"/>
      <url>/2017/04/22/%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>翻微博突然听见这首歌，有点感慨。网易没有外链，找了个视频。</p></blockquote><a id="more"></a><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=v0108qjz2c7&tiny=0&auto=0" allowfullscreen></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周杰伦 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>电脑崩了之后hexo的处置</title>
      <link href="/2017/04/21/%E7%94%B5%E8%84%91%E5%B4%A9%E4%BA%86%E4%B9%8B%E5%90%8Ehexo%E7%9A%84%E5%A4%84%E7%BD%AE/"/>
      <url>/2017/04/21/%E7%94%B5%E8%84%91%E5%B4%A9%E4%BA%86%E4%B9%8B%E5%90%8Ehexo%E7%9A%84%E5%A4%84%E7%BD%AE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>电脑崩溃之后，要重新更新博客是个麻烦的事，以下是个人的历程，现记录下来。</p></blockquote><a id="more"></a><p>既然电脑崩溃了，那么第一步是重新安装git和node.js。</p><p>之后初始化git，设置ssh并添加到github中。</p><p>另寻地方，新建文件夹Hexo。</p><p>右击git bash here。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>将以前保存在github中的源文件下载下来，复制到Hexo文件夹中。</p><p>接下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">npm install hexo-util --save</span><br></pre></td></tr></table></figure><p>这样就可以进行上传到github pages中了。</p><p>至于上传源码到github中，我的处置方法是删除原来的源码repo并新建一个repo，然后先将Hexo：git init，再将其上传到repo中。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你给我听好</title>
      <link href="/2017/04/21/%E4%BD%A0%E7%BB%99%E6%88%91%E5%90%AC%E5%A5%BD/"/>
      <url>/2017/04/21/%E4%BD%A0%E7%BB%99%E6%88%91%E5%90%AC%E5%A5%BD/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>陈奕迅的《你给我听好》。</p></blockquote><a id="more"></a><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/E5E20145DA11F0AC988D737DC01D85CB.flv?sc=916382da26ce80fb&br=769&vid=2047605&aid=157&area=HT&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/E5E20145DA11F0AC988D737DC01D85CB.flv?sc=916382da26ce80fb&br=769&vid=2047605&aid=157&area=HT&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 陈奕迅 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观眉山论剑</title>
      <link href="/2017/04/16/%E8%A7%82%E7%9C%89%E5%B1%B1%E8%AE%BA%E5%89%91/"/>
      <url>/2017/04/16/%E8%A7%82%E7%9C%89%E5%B1%B1%E8%AE%BA%E5%89%91/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>腾讯观视频工作室出品的《眉山论剑》，很好的时事讲坛类节目，对自己是一个启迪。小时候自己什么都不懂，长大了之后目空一切，以为自己什么都懂，再到现在又发现自己还是什么都不懂。除了自己的专业知识以外，政治博弈这个知识在我这还是空白，也许这个节目能给自己和困惑的你一点启发。庆幸中国有如此一批超级大脑，才能为祖国人民创造如此安定的生活环境。他们用自己的大脑解析外国的阴谋阳谋，学以致用，这一点值得我辈学习。尤其想到节目中陈平研究员提到现在的媒体经济学者，估计就是大多数人，很容易被所谓新闻欺骗，联想到共产党人需要辩证的看待事情这一马克思原理，深有感触。以前的知识并没有白学，只是没有好好利用，活读书。再联想到有句话“半部论语治天下”，其实，人是真正活学了论语，而不是死靠论语来治理天下。回到起点来说，要活读书，化为己用，才能透过现象看到本质。</p><a id="more"></a> <p> 在此给出眉山论剑的视频链接，以供读者观看。</p><ol><li><a href="http://v.qq.com/page/f/k/t/f0392qlc5kt.html" target="_blank" rel="noopener">眉山论剑1：听其言不如观其行</a></li><li><a href="http://v.qq.com/page/j/g/8/j0392rsk4g8.html" target="_blank" rel="noopener">眉山论剑2：不学经济，学孙子兵法</a></li><li><a href="http://v.qq.com/page/w/o/r/w0393r31yor.html" target="_blank" rel="noopener">眉山论剑3：媒体经济学的伪命题</a></li><li><a href="http://v.qq.com/page/n/w/7/n0393pi9ow7.html" target="_blank" rel="noopener">眉山论剑4：他们都错了</a></li><li><a href="http://v.qq.com/page/d/j/6/d0393w16aj6.html" target="_blank" rel="noopener">眉山论剑5：印度超越中国？</a></li><li><a href="http://v.qq.com/page/h/9/f/h0393uuwp9f.html" target="_blank" rel="noopener">眉山论剑6：中国是1900年的美国</a></li></ol><p>要用科学的辩证眼光来看待问题，也许节目中的问题讲的是对的，也许讲的是不全面的，要有自己的认识，才能达到学习的目的。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>摄影杂货铺</title>
      <link href="/2017/04/07/%E6%91%84%E5%BD%B1%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
      <url>/2017/04/07/%E6%91%84%E5%BD%B1%E6%9D%82%E8%B4%A7%E9%93%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文收集了平时看到的有关摄影的小知识，不定时更新。</p></blockquote><a id="more"></a><ol><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=153129" target="_blank" rel="noopener">好照片的秘诀 - 对比和冲突</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=144397" target="_blank" rel="noopener">新手学习摄影应该注意什么？</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=146199" target="_blank" rel="noopener">所谓摄影眼，究竟是什么眼？ | 一点思路</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=141530" target="_blank" rel="noopener">学会调色，从理解HSL面板开始</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=133352" target="_blank" rel="noopener">如何突出画面中的主体？布拉德·皮特 告诉你 | 一点技巧</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/22/摄影笔记手机摄影入门/">摄影笔记手机摄影入门</a></li><li><a href="http://www.davidfnck.com/talkshow/obama_top_100_best_photos.html/">创业前辈｜Barack Obama's Top 100 best photos</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>湖南</title>
      <link href="/2017/04/06/%E6%B9%96%E5%8D%97%E8%A1%8C%E8%A7%81/"/>
      <url>/2017/04/06/%E6%B9%96%E5%8D%97%E8%A1%8C%E8%A7%81/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><blockquote><p>留存，以后再写，简单说两句。</p></blockquote><a id="more"></a><h3 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h3><ol><li>南京到张家界</li><li>张家界到武陵源</li><li>武陵源到张家界</li><li>天门山</li><li>张家界到长沙</li></ol><h3 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h3><p>想去玩的朋友需准备充足的时间，武陵源3天为宜。天门山完全是坐索道，其实没啥可玩的，时间仓促可以不去。长沙小吃还不错，时间匆忙，只去了橘子洲，还没玄武湖漂亮。好了就这么多，有空再写。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些感悟</title>
      <link href="/2017/04/06/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/"/>
      <url>/2017/04/06/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/26178137" target="_blank" rel="noopener">一些感悟</a>，仅供本博留存观看，其它商业目的请与原文联系。</p><a id="more"></a><p>首先要自律。这是最基本的。如果一个人不能控制自己的行为，那无法走出自己的路。像说到要做到，有规律地锻炼身体，勤奋努力，这些都是重要的。</p><p>接下来要跳出舒适区。举个例子，勤奋本来就是舒适区的一种。“勤能补拙”这个词是很好的，首先它说明现在处于“拙”的状态中，需要继续努力；其次，勤只能用来“补”拙，而不能让拙变巧，不是根本的解决方案。勤奋是一种惶惶然的状态，而不是一种满足的状态，勤奋意味着自己不如别人，于是得要花更多的时间去补救，别人干八小时就够了，自己得花十几个小时才能赶上。这种状态是不长久的，碰到出些小毛小病，或者家里有事，那就补不过来，就要掉队了。勤奋的用处是试错，是让自己在落后时可以多花点时间找到正确的方法，以达到和别人相当甚至更高的效率，从而提高自己的能力。别人是科班出身，我半路杀进来，当然要多花时间去补；别人学习效率高，我的效率不高，于是得要多花点时间去探索更好的方法。勤奋是暂态，它最终目的是找到更好的方法及时补上以离开这个状态，而不是以一直维持这个状态为荣。</p><p>不能按部就班，要随时作好把棋盘翻过来的准备，世事变化很快，以前的所有努力，不管经历过什么样的辛劳，全都是沉没成本，在必要时候都需要扔掉的，或许做了很多年方向A，时势告诉你情况不妙，要换成方向B，那就得坚决换。以前或许这个不常见，但是以后这样的事情会越来越多。干了十年方向A，人工智能把方向A吃掉了，然后马上转做方向B，做了五年，人工智能再把B吃掉，然后继续，如此往复。很多时候转变不是一朝一夕，而是靠滴水穿石的功夫，今天长进一点，明天长进一点，跟着领域一起变，若是一个人跑得比别人快，他就会在市场上稀缺并因此获得相对的安全。做研究的人都习惯这个，每天看新东西，每天打开思路，时刻承认自己老旧了几个月或者几周，马上拍拍屁股跟上。学会了这些再去教徒弟是饿不死师傅的，反而让师傅变得更厉害，因为师傅主动跳出来接受打脸，学得比徒弟快。对很多人来说这个比较难，特别是一直顺风顺水的。但若是一直不敢看外面的世界，那迟早有一天会被逼进去面对。与其被逼，不如提早一些主动跳进去。历史无数次以血的教训告诉了大家，适者生存乃永恒之铁律，人类在千万物种中杀出血路成为地球的主宰，也必将背负着这样的命运走向未来。一个人逃避，这个人会被淘汰，一个领域逃避，这个领域会被淘汰，一个国家逃避，这个国家就会被淘汰。</p><p>任何时候，自己一定是有错的，最可怕的不是自己错了，而是不知道自己哪里错，并且在错的方向上越走越远。如果周围有厉害的同事，这种感觉尤其强烈，碰上了随便讨论两句，就知道自己哪些知识不足，暗地里记下马上回去补。为此，主动发言积极讨论是很重要的，思维有碰撞才知道问题在哪里。我有时候觉得自己一直在悬崖边上走，也许之前走得还行，但那都过去了，下一步随时有可能踏进崖边的泥地即将摔倒。踏错了不要紧，及时发现自己错了收脚就行；怕的是一直走安稳的道，连悬崖长什么样都不知道了。前辈和老师们说的话，也非常有可能是错的，而身为后辈的我们，大任在于如何找出他们的错误来。找出了的话，能力就得到了提升。而自信，往往就是通过这种方式磨练出来的——为什么自己和别人不同？因为选了一条不一样的路。</p><p>再往上走，主次是要分清的。重要的要抓牢，不重要的要放手。有人读过很多文章看过很多书，勤勉自律好学爱问样样不缺，但门门都不精；有人事事亲为，务求完美，大事上往往把握不了。短木板理论是有问题的，大部分岗位不需要全才，要的是一专多能，要的是某方向很牛非常牛，相同程度的可以掰指头数过来，其它的过线就行，甚至不达标也无人关心。如果你不是专家，高薪聘请没有意义；如果你是专家，求全责备没有意义。人一天只有24小时，所以知道哪里要放弃是很重要的，很多时候，没有牺牲就没有得到，要得到就得付出代价，事前权衡利弊，事后愿赌服输。输了不要紧，再来一次。当然在现实中并没有那么惨烈的权衡，而往往是找到了自己的方向，自然而然地就向这个方向发展下去，这时候主要的阻力，就在于登顶之难而非选择之痛。然而，即便生于风平浪静的和平年代，觉悟依然要有，或许将来有一天，得要做出这样的决断。</p><p>最后，不要在优越感中停止自己的脚步。名利于人最可怕的莫过于此，分明刚刚启程，但欢呼声让你觉得已然冲线，本来要万里长征，却变成了百米短跑，接受完了鲜花之后，就再也看不见远处的风景。其实境界到了或是未到，只有自己知道。跋山涉水，风餐露宿，鼓掌的是别人，度化的是自己。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="http://gubangzhong.cn/2016/11/16/女人如政治/">女人如政治</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上传本地博客源码到git服务器</title>
      <link href="/2017/03/28/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/03/28/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文主要想将本地的博客文件上传到github中，以备系统崩坏or不慎删除。</p></blockquote><a id="more"></a><p>首先创建Repo，例如我创建了Blog（注意：不要添加readme.md）</p><p>然后在本地git bash中输入如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">'上传'</span></span><br><span class="line">git remote add origin https://github.com/maxiaoyuelun/Blog.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新文件</span></span><br><span class="line">git status<span class="comment">#查看已经更新哪些文件</span></span><br><span class="line">git add -u<span class="comment">#把当前文件夹下中所有tracked文件中被修改过或已删除文件的信息添加到索引库，它不会处理untracked的文件。</span></span><br><span class="line">git commit -m <span class="string">'写出你的修改内容'</span><span class="comment">#这一步必须有，否则下一步不成功</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">git add -A<span class="comment">#添加文件时将untracked文件添加到更新索引中</span></span><br><span class="line">git commit -m <span class="string">'写出你的修改内容'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Laravel5-1开发博客系列一/">Laravel5.1开发博客系列一</a></li><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo插件收集</title>
      <link href="/2017/03/28/hexo%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86/"/>
      <url>/2017/03/28/hexo%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文主要记录收集的hexo插件，不定时更新。</p></blockquote><a id="more"></a><h4 id="博文末尾加版权addlink"><a href="#博文末尾加版权addlink" class="headerlink" title="博文末尾加版权addlink"></a><a href="https://github.com/acwong00/hexo-addlink" target="_blank" rel="noopener">博文末尾加版权addlink</a></h4><h4 id="博客加密blog-encrypt"><a href="#博客加密blog-encrypt" class="headerlink" title="博客加密blog-encrypt"></a><a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">博客加密blog-encrypt</a></h4><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows文本快捷键</title>
      <link href="/2017/03/28/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/03/28/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文简记Windows文本的快捷键，以备不时之需，不定期更新。</p></blockquote><a id="more"></a><ol><li>选取块左移    Shift+Tab</li><li>选取块右移    Tab</li><li>关闭当前程序    Alt+F4</li><li>切换程序        Alt+Tab</li><li>将当前行上移、下移一行    Ctrl+Shift+左右方向键</li><li>删除当前行    Ctrl+L</li><li>选中文字        Shift+方向键</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/13/windows右键cmd/">windows右键cmd</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git Bash不能输入中文解决办法</title>
      <link href="/2017/03/14/Git-Bash%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2017/03/14/Git-Bash%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>打开Git Bash后，</p><p>对窗口右键-&gt;Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8，</p><p>关闭再打开。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/git本地文件夹上传至github/">git本地文件夹上传至github</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="http://gubangzhong.cn/2017/07/13/批处理git命令/">批处理git命令</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dlib使用指南</title>
      <link href="/2017/01/03/Dlib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2017/01/03/Dlib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>最近搞人脸识别的程序，于是广泛搜索可复用代码，再加上以前就知道的工具，在此笔记。</p></blockquote><a id="more"></a><p>进入<code>D:/github/dlib/</code>，打开cmd。在此之前需要安装<a href="https://cmake.org/" target="_blank" rel="noopener">cmake</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> examples</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G <span class="string">"Visual Studio 14 2015 Win64"</span> -DCOMPILER_CAN_DO_CPP_11=ON -DCMAKE_PREFIX_PATH=<span class="string">"D:/githun/cudnn/"</span> ..</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>face_recognition是搭建在dlib之上的代码，一个很好的框架。</p><p>测试代码</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlib.net/" target="_blank" rel="noopener">Dlib官网</a></li><li><a href="https://github.com/davisking/dlib" target="_blank" rel="noopener">Dlib github</a></li><li><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">face_recognition github</a></li><li><a href="https://github.com/MarekKowalski/FaceSwap" target="_blank" rel="noopener">FaceSwap github</a></li><li><a href="https://github.com/davisking/dlib/issues/756" target="_blank" rel="noopener">Dlib CUDA安装</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> dlib </tag>
            
            <tag> face_recognition </tag>
            
            <tag> cudnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>车站</title>
      <link href="/2016/12/13/%E8%BD%A6%E7%AB%99/"/>
      <url>/2016/12/13/%E8%BD%A6%E7%AB%99/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>写着论文，听到这首车站，不觉潸然。</p><p>读博已经到了第二年，前路可期但前路漫漫。</p><p>越来越明白一些道理，就像有了一定的阅历之后再读某一本书，深有同感。</p><p>回忆会伤人的，在李健歌声的烘托下，那一丝丝的情绪蔓延开来，断了思绪。</p><blockquote><p>只在音悦台找到邓丽君版的。</p></blockquote><iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/3B5E01605352FCC49D8A168B52C1825E.mp4?sc=e02c9c89e4c10460&br=482&vid=3112534&aid=1028&area=HT&vst=3" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>读书这些年，不免多了书生气，少了人生在这个时间段的某种阅历，所谓行万里路。况且，有失必有得，祸福相倚，书读多了，就越来越接近一种说不出的真理，亦或某种大道，亦或某种淡然，有种殊途同归的感觉。</p><p>不理解的人可能会说读傻了，产生一种难以交流的感觉，而这正是经历之后的一种觉悟，尽管我才刚刚开始，但此时才真正知道我需要什么，不需要什么，而不是被环境或者外力裹挟前进。</p><p>还要经历或者两年，写文章，做实验，最终完成毕业论文，天复一天，年复一年，似乎无聊。</p><p>这只是一种经历，经历了之后，会为你打开另外一扇门，不仅仅是苟且，也许是理想。</p><p>音乐作为一种勾起思绪的媒介，的确是个好东西，不然即使平时再无聊，也不会好好沉淀，想想，思考。</p><p>自从研究生开始学起了尤克里里，而后吉他，对其爱不释手，有时候只是简单的扫弦，也会得到某种放松。可惜，这么久才开始学，幸运是，我已经开始学了。</p><!-- 对于我，一切都不算晚。--><!-- 路，一直在脚下。-->]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李健 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mxnet初步安装及使用指北</title>
      <link href="/2016/12/06/mxnet%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/2016/12/06/mxnet%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>windows 10</li><li>visual studio 2013 community update 5</li><li>pycharm community edition 2016.3</li><li>anaconda 4.2.0 64 bit python 2.7.12</li><li>GTX 1070</li></ol><a id="more"></a><h3 id="安装小记"><a href="#安装小记" class="headerlink" title="安装小记"></a>安装小记</h3><blockquote><p>博主安装在D盘上，路径为<code>D:\mxnet\</code></p></blockquote><p>首先确保电脑上已经安装好官方Git，并已经配置成功。</p><p>确保电脑上已经安装好cuda(博主安装版本8.0)，并已经配置成功。</p><blockquote><p>cuda必须在visual studio 2013之前安装，否则不能在visual studio中正确配置cuda。</p></blockquote><p>用Git下载Github上的源文件至指定路径下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git colne https://github.com/dmlc/mxnet.git</span><br></pre></td></tr></table></figure><p>安装编译前必备的库和软件：cudnn，opencv，openblas</p><blockquote><p>以下参考官方文档<a href="http://mxnet.io/get_started/setup.html#building-and-installing-packages-on-windows" target="_blank" rel="noopener">Building and Installing Packages on Windows</a>进行安装并进行补充。</p></blockquote><p>由于博主已经安装了update5，所以不再需要安装<a href="https://www.microsoft.com/en-us/download/details.aspx?id=41151" target="_blank" rel="noopener">visual c++ compiler nov 2013 ctp</a>。如需安装请参考mxnet官方文档。</p><p><strong>cmake 3.7.0</strong></p><p><a href="https://cmake.org/" target="_blank" rel="noopener">cmake官网</a>下载安装最新版本，用来编译Visual Studio Solution。</p><p><strong>cudnn</strong></p><p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cudnn官网</a>下载最新版本5.0，存放在路径<code>D:\cudnn</code>。</p><p><strong>opencv</strong></p><p><a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.0.0/opencv-3.0.0.exe/download" target="_blank" rel="noopener">opencv下载链接</a>下载版本3.0.0，存放在路径<code>D:\opencv</code>。</p><p>在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>OpenCV_DIR</code>，并赋值<code>D:\opencv\build</code>。</p><p><strong>openblas</strong></p><p><a href="https://sourceforge.net/projects/openblas/files/v0.2.14/OpenBLAS-v0.2.14-Win64-int64.zip/download" target="_blank" rel="noopener">OpenBLAS-v0.2.14-Win64-int64下载链接</a>，存放在路径<code>D:\OpenBLAS-v0.2.14-Win64-int64</code>。</p><p>在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>OpenBLAS_HOME</code>，并赋值<code>D:\OpenBLAS-v0.2.14-Win64-int64</code>。</p><p><strong>anaconda</strong></p><p><a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">anaconda官网</a>下载安装anaconda，博主安装路径为<code>C:\Program Files\Anaconda2\</code>。</p><p><strong>visual studio编译配置</strong></p><p>首先在<code>D:\mxnet\</code>下新建文件夹build。</p><p>打开cmake。</p><p>在<code>where is the source code</code>中添加<code>D:\mxnet</code>。<br>在<code>where to build the binaries</code>中添加<code>D:\mxnet\build</code>。</p><p>点击<code>Configure</code>，进行配置，若出现配置不成功，则将需要的路径手动添加在cmake中，<strong>当然根据出现的问题针对改动</strong>。</p><p>配置成功后点击<code>Generate</code>生成solution。</p><p>生成完成后可以发现在<code>D:\mxnet\build</code>下出现solution文件，用visual studio 2013打开solution。</p><p>在visual studio 2013中编译Debug和Release文件，静待几分钟编译成功。</p><p>由于大多数使用在python环境下，需要配置python使用环境，在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>PYTHONPATH</code>，并添加值<code>D:\mxnet\python</code>。由于需要在python中使用opencv，所以在<code>PYTHONPATH</code>变量中继续添加<code>D:\opencv\build\python\2.7\x64</code>。</p><p><strong>范例测试</strong></p><blockquote><p>由于在pycharm中编写python代码，需要配置pycharm的编译环境，打开pycharm，在<code>File&gt;Settings&gt;Interpreter</code>中配置解释环境为<code>C:\Program Files\Anaconda2\python.exe</code>。</p></blockquote><p>在pycharm中打开文件train_mnist.py。该文件在<code>D:\mxnet\example\image-classification\</code>文件夹下，是官方自带示例。</p><p>在61行中将<code>gpus=None</code>改成<code>gpus=&#39;0&#39;</code>即可用gpu运行代码，最终发现结果约为：0.981190。</p><h3 id="使用小记"><a href="#使用小记" class="headerlink" title="使用小记"></a>使用小记</h3><p>mxnet自带可以将net画成pdf图的工具，但是需要配置相关库。</p><p><strong>下面需按顺序安装</strong></p><p><strong>graphviz</strong></p><p><a href="http://www.graphviz.org/Download_windows.php" target="_blank" rel="noopener">graphviz下载链接</a>，博主下载的是zip文件并解压到<code>D:\graphviz-2.38</code>下。</p><p>接下来配置环境变量，在系统环境变量<code>Path</code>中添加值<code>D:\graphviz-2.38\release\bin</code>，保存关闭。</p><p>接下来<code>以管理员身份运行</code>cmd，由于博主anaconda是安装在C盘中，所以必须以管理员身份运行安装相关软件。</p><p>确保已经用conda安装好pip。</p><p>接下来输入如下代码安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install graphviz</span><br><span class="line">pip install pydot</span><br></pre></td></tr></table></figure><p>重启电脑，graphviz安装成功，至此再次声明，上面的安装顺序不能乱。</p><p>博主在路径<code>D:\DLRVS\train\</code>下创建自己的数据分类文件夹<code>b</code>和<code>f</code>，只有两类。</p><p>用mxnet自带的工具im2rec生成相关rec文件。im2rec.py在路径<code>D:\mxnet\tools</code>下。</p><p>在cmd中切换到路径<code>D:\mxnet\tools</code>下，使用im2rec.py先生成lst文件，然后再生成rec文件。</p><p><strong>生成lst文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python im2rec.py --list True D:\DLRVS\yy D:\DLRVS\train\ --recursive True --shuffle True --train-ratio=0.8</span><br></pre></td></tr></table></figure><p>在路径<code>D:\DLRVS\</code>下生成yy_train.lst，yy_val.lst，yy_test.lst文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python im2rec.py D:\DLRVS\yy_train.lst D:\DLRVS\train --quality=100</span><br></pre></td></tr></table></figure><p>在路径<code>D:\DLRVS\</code>下生成yy_train.rec文件，同样可以生成yy_val.rec和yy_test.rec文件。</p><p>以下是本人的测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> fit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip, struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iterators</span><span class="params">(batch_size,data_shape=<span class="params">(<span class="number">1</span>,<span class="number">27</span>,<span class="number">27</span>)</span>)</span>:</span></span><br><span class="line">    train=mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=<span class="string">"D:\DLRVS\yy_train.rec"</span>,</span><br><span class="line">        mean_img=<span class="string">"\DLRVS\mean.bin"</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        shuffle=<span class="keyword">True</span>,</span><br><span class="line">        rand_crop=<span class="keyword">False</span>,</span><br><span class="line">        rand_mirror=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    val= mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=<span class="string">"D:\DLRVS\yy_val.rec"</span>,</span><br><span class="line">        mean_img=<span class="string">"D:\DLRVS\mean.bin"</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        shuffle=<span class="keyword">True</span>,</span><br><span class="line">        rand_crop=<span class="keyword">False</span>,</span><br><span class="line">        rand_mirror=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> (train,val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_symbol</span><span class="params">(num_classes=<span class="number">10</span>, **kwargs)</span>:</span></span><br><span class="line">    data = mx.symbol.Variable(<span class="string">'data'</span>)</span><br><span class="line">    <span class="comment"># first conv</span></span><br><span class="line">    conv1 = mx.symbol.Convolution(data=data, kernel=(<span class="number">5</span>,<span class="number">5</span>), num_filter=<span class="number">20</span>)</span><br><span class="line">    tanh1 = mx.symbol.Activation(data=conv1, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    pool1 = mx.symbol.Pooling(data=tanh1, pool_type=<span class="string">"max"</span>,</span><br><span class="line">                              kernel=(<span class="number">2</span>,<span class="number">2</span>), stride=(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># second conv</span></span><br><span class="line">    conv2 = mx.symbol.Convolution(data=pool1, kernel=(<span class="number">5</span>,<span class="number">5</span>), num_filter=<span class="number">50</span>)</span><br><span class="line">    tanh2 = mx.symbol.Activation(data=conv2, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    pool2 = mx.symbol.Pooling(data=tanh2, pool_type=<span class="string">"max"</span>,</span><br><span class="line">                              kernel=(<span class="number">2</span>,<span class="number">2</span>), stride=(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># first fullc</span></span><br><span class="line">    flatten = mx.symbol.Flatten(data=pool2)</span><br><span class="line">    fc1 = mx.symbol.FullyConnected(data=flatten, num_hidden=<span class="number">500</span>)</span><br><span class="line">    tanh3 = mx.symbol.Activation(data=fc1, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    <span class="comment"># second fullc</span></span><br><span class="line">    fc2 = mx.symbol.FullyConnected(data=tanh3, num_hidden=num_classes)</span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    lenet = mx.symbol.SoftmaxOutput(data=fc2, name=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> lenet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(symbol,train,val,batch_size,num_gpus)</span>:</span></span><br><span class="line">    devs=[mx.gpu(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_gpus)]</span><br><span class="line">    mod=mx.mod.Module(symbol=new_sym,context=devs)</span><br><span class="line">    mod.bind(data_shapes=train.provide_data,label_shapes=train.provide_label)</span><br><span class="line">    mod.init_params(initializer=mx.init.Xavier(rnd_type=<span class="string">'gaussian'</span>,factor_type=<span class="string">"in"</span>,magnitude=<span class="number">2</span>))</span><br><span class="line">    mod.fit(train,val,</span><br><span class="line">            num_epoch=<span class="number">1000</span>,</span><br><span class="line">            batch_end_callback=mx.callback.Speedometer(batch_size,<span class="number">10</span>),</span><br><span class="line">            optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">            optimizer_params=&#123;<span class="string">'learning_rate'</span>:<span class="number">0.01</span>&#125;,</span><br><span class="line">            eval_metric=<span class="string">'acc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num_classes=<span class="number">2</span></span><br><span class="line">    batch_per_gpu=<span class="number">600</span></span><br><span class="line">    num_gpus=<span class="number">1</span></span><br><span class="line">    new_sym=get_symbol(num_classes=<span class="number">2</span>)</span><br><span class="line">    batch_size=batch_per_gpu*num_gpus</span><br><span class="line">    (train,val)=get_iterators(batch_size)</span><br><span class="line">    mx.viz.plot_network(new_sym).view()</span><br><span class="line">    fit(new_sym,train,val,batch_size,num_gpus)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.cnblogs.com/daihengchen/p/5924768.html" target="_blank" rel="noopener">从零开始学MXnet(一)</a></li><li><a href="http://blog.csdn.net/panda1942/article/details/50923006" target="_blank" rel="noopener">mxnet深度学习实战：跑自己的数据实验和一些问题总结</a></li><li><a href="http://blog.csdn.net/shuzfan/article/details/50037273" target="_blank" rel="noopener">mxnet学习记录</a></li><li><a href="http://blog.csdn.net/Sunshine_in_Moon/article/category/6020021" target="_blank" rel="noopener">Mxnet学习系列</a></li><li><a href="http://mxnet.io/" target="_blank" rel="noopener">mxnet官网</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mxnet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我要你</title>
      <link href="/2016/11/26/%E6%88%91%E8%A6%81%E4%BD%A0/"/>
      <url>/2016/11/26/%E6%88%91%E8%A6%81%E4%BD%A0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近很喜欢听这首歌，主要是在学怎么弹啊，弹了好久都没连贯！！！</p><a id="more"></a><!--网易云音乐<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=448 height=86 src="//music.163.com/outchain/player?type=2&id=436514254&auto=0&height=66"></iframe>--><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/740C01580E4D6EDDAB4DB0E4A1D1CE59.flv?sc=0428d8f24652d584&br=796&vid=2712084&aid=41699&area=ML&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/740C01580E4D6EDDAB4DB0E4A1D1CE59.flv?sc=0428d8f24652d584&br=796&vid=2712084&aid=41699&area=ML&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>女人如政治</title>
      <link href="/2016/11/16/%E5%A5%B3%E4%BA%BA%E5%A6%82%E6%94%BF%E6%B2%BB/"/>
      <url>/2016/11/16/%E5%A5%B3%E4%BA%BA%E5%A6%82%E6%94%BF%E6%B2%BB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>女人如政治，自己想去吧！</p><a id="more"></a><p>政治是不需要道德的<br>政治是暴力或者实力征服<br>政治是虚伪的<br>政治是说一套做一套<br>政治是讲究表面的装饰<br>政治是要掩盖残酷真相的<br>政治是需要给人远大幻想的<br>政治是做了再说的</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Hexo中嵌入图片之七牛插件指北</title>
      <link href="/2016/11/13/%E5%9C%A8Hexo%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87%E4%B9%8B%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/13/%E5%9C%A8Hexo%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87%E4%B9%8B%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>根据参考文献可以完成初步配置，不够完美，正在寻找新的替代插件（比较难用，博主已放弃）。</p></blockquote><p>问题：</p><p>不能用<code>hexo qiniu sync</code>进行同步，在用<code>hexo g -d</code>也不能进行同步，需要将需要上传的image文件夹拷贝到public文件夹下，并在<code>_config.yml</code>文件中对<code>sync_dir</code>进行配置，则可以完成上传。</p><p>以上步骤还是麻烦，将待上传image文件夹拷贝到public文件夹下，在用<code>hexo d</code>命令时，图片也被上传到github中了，这违背了初始意愿，只能删除重复上传。</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://github.com/ronesam/hexo-deployer-qiniu" target="_blank" rel="noopener">hexo-deployer-qiniu</a></li><li><a href="http://linusling.com/2016/03/04/images-in-hexo-using-qiniu/" target="_blank" rel="noopener">使用七牛在 Hexo 文档中嵌入图片</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 七牛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django安装指北</title>
      <link href="/2016/11/10/Django%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/Django%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近来突发兴致学习Django，初始根据教程学习，用内置服务器运行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>在浏览器中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000</span><br></pre></td></tr></table></figure><a id="more"></a><p>得到合适的页面，也是正确的页面。</p><p>但是，在Django的开发文档中也这么说明，runserver只作为开发用途，而不是发行用途。</p><p>所以，寻求用Apache来运行Django。</p><p>这也就带来了难题，即需要如题配置。经过大约一天的时间，各种谷歌、百度寻求帮助，排除一个个error终于配置成功。</p><p>现将过程介绍如下，防止以后再遇到此类问题。</p><blockquote><p>我使用的是Ubuntu 14.04 LTS+Apache2.4+Python2或者3（根据mod_wsgi.so改变）+Django1.6或者以上</p></blockquote><h2 id="安装Apache等"><a href="#安装Apache等" class="headerlink" title="安装Apache等"></a>安装Apache等</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 libapache2-mod-wsgi python-django</span><br></pre></td></tr></table></figure><h2 id="Apache配置"><a href="#Apache配置" class="headerlink" title="Apache配置"></a>Apache配置</h2><p>　　在/etc/apache2/中找到apache2.conf</p><p>　　在最后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line"></span><br><span class="line">    ServerName hello.com</span><br><span class="line">    DocumentRoot /var/www/yourproject</span><br><span class="line">    &lt;Directory /var/www/yourprojec&gt; </span><br><span class="line">　　　　Order allow,deny </span><br><span class="line">　　　　Allow from all</span><br><span class="line">　　 &lt;/Directory&gt; </span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">　　在/etc/apache2/sites-available/中添加wsgi.conf，在新创建的wsgi.conf中输入</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;  </span><br><span class="line">  </span><br><span class="line">    ServerName wsgi.testserver  </span><br><span class="line">    DocumentRoot /var/www/yourproject </span><br><span class="line">  </span><br><span class="line">   &lt;Directory /var/www/yourproject&gt;  </span><br><span class="line">       Order allow,deny  </span><br><span class="line">        Allow from all  </span><br><span class="line">   &lt;/Directory&gt;  </span><br><span class="line">  </span><br><span class="line">    WSGIScriptAlias / /var/www/django.wsgi  </span><br><span class="line">  </span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>　　</p><p>　　</p><h2 id="Django配置"><a href="#Django配置" class="headerlink" title="Django配置"></a>Django配置</h2><p>在/var/www/中创建django.wsgi，并在其中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(<span class="string">'/var/www/yourproject'</span>)</span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'yourproject.settings'</span></span><br><span class="line"></span><br><span class="line">from django.core.wsgi import get_wsgi_application</span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite wsgi.conf</span><br><span class="line"></span><br><span class="line">sudo service apache2 reload</span><br></pre></td></tr></table></figure><p>差不多成功了。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/11/20/win10安装django错误集/">win10安装django错误集</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> python </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>月下漫步</title>
      <link href="/2016/11/10/%E6%9C%88%E4%B8%8B%E6%BC%AB%E6%AD%A5/"/>
      <url>/2016/11/10/%E6%9C%88%E4%B8%8B%E6%BC%AB%E6%AD%A5/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>清冷的星光</p><p>不知今夜几更</p><p>漫步在桥头 </p><p>留恋梦更深</p><p>难忘几段曲 </p><p>轻叩夜门</p><a id="more"></a><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fn4frj7f0bj31kw148hci.jpg" alt=""></p><p>你说今宵很美</p><p>不忍翻过这一夜</p><p>离经叛道的我们 </p><p>都念这里虫声</p><p>云端的月牙偷笑尘世的凡人</p><p>却不懂自己的清冷</p><p>嫦娥孤寂 不再天下人</p><p>又是这个夜 </p><p>早已物是人非</p><p>梧桐雨伴随脚步 </p><p>敲打这不成文</p><p>想你的时候 </p><p>默默呼唤 </p><p>不敢更深</p><p>怕心碎</p><p>无端的烦躁</p><p>莫名的悲痛</p><p>花儿已凋谢 </p><p>何时才能再开</p><p>只是独唱 </p><p>寂寞沙洲冷</p><p>记忆已慢慢消逝 </p><p>还留下什么</p><p>灯火辉煌的校园潜伏着这不知疲倦的老树</p><p>却已等不到灯下的人</p><p>昨天我们的温筑  </p><p>早已变成别人的战场</p><p>避开熟悉的脸皮  </p><p>僵硬的城池 </p><p>踏过漫漫夜波  </p><p>拥抱我身披的三世清辉</p><p>那些不愿说出的细节 </p><p>就让她随风而去</p><p>绕过绿肥红瘦 </p><p>追赶悄悄离开的雨</p><p>在深处  </p><p>忆西窗烛影 </p><p>一曲夜歌</p><p>祝福的哑语</p><p>你听到没？</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MatConvNet安装指北</title>
      <link href="/2016/11/10/MatConvNet%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/MatConvNet%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>Windows 10</li><li>VS2015/VS2013</li><li>Matlab 2016</li><li>MatConvNet各个版本</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>解压下载后的文件夹到指定路径。假定为<code>D:\matconvnet\</code></p><a id="more"></a><p>在<code>matconvnet</code>下创建文件夹<code>local</code>，并将<code>cudnn</code>及文件夹下全部文件拷贝到<code>local</code>下。</p><p>在<code>D:\matconvnet\matlab\</code>下创建<code>mex</code>文件夹。</p><p>将<code>local\cudnn\bin</code>下的<code>dll</code>文件拷贝至<code>mex</code>文件夹下。</p><p>在Matlab工作环境下切换路径至<code>D:\matconvnet\</code>文件夹下，运行如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run ./matlab/vl_setupnn.m</span><br><span class="line"></span><br><span class="line">vl_compilenn(&apos;enableGpu&apos;,true,&apos;enableCudnn&apos;,true,&apos;cudnnRoot&apos;,&apos;.\local\cudnn\&apos;);</span><br></pre></td></tr></table></figure><p>至此安装成功。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matconvnet </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vlfeat编译指北</title>
      <link href="/2016/11/10/Vlfeat%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/Vlfeat%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>首先下载源码文件解压至指定路径，例如<code>C:\Users\colin\Documents\MATLAB</code>。</p><p>查找<code>C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20</code>路径下发现有<code>Makefile.mak</code>文件。</p><p>打开菜单栏，找到<code>Visual Studio Tools</code>，双击打开<code>VS2013 x64 本机工具命令提示</code>。</p><p>在<code>cmd</code>中输入以下代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20</span><br><span class="line">nmake /f Makefile.mak</span><br></pre></td></tr></table></figure><p>至此，发现输出信息最后几行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.... CC [MEX] toolbox\mex\mexw64\vl_aib.mexw64</span><br><span class="line">系统找不到指定的路径。</span><br><span class="line">NMAKE : fatal error U1077: “echo”: 返回代码“0x1”</span><br><span class="line">Stop.</span><br></pre></td></tr></table></figure><p><strong>不用管这些信息</strong>。</p><p>打开<code>Matlab</code>，切换路径至<code>C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\</code>。</p><p>在Matlab命令窗口中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vl_setup</span><br><span class="line"></span><br><span class="line">vl_compile</span><br></pre></td></tr></table></figure><p>至此编译完成。</p><blockquote><p>估计用nmake编译不成功是没有设置matlab路径。</p></blockquote><p>切换matlab路径至<code>C:\Users\colin\Documents\MATLAB\</code>。</p><p>新建<code>startup.m</code>文件，在其中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(&apos;C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\vl_setup.m&apos;);</span><br></pre></td></tr></table></figure><p>这样就可以让matlab每次都启动vlfeat库。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> vlfeat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>visual-studio-2013编译64位boost</title>
      <link href="/2016/11/09/visual-studio-2013%E7%BC%96%E8%AF%9164%E4%BD%8Dboost/"/>
      <url>/2016/11/09/visual-studio-2013%E7%BC%96%E8%AF%9164%E4%BD%8Dboost/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>windows 10</li><li>visual studio 2013 ultimate</li><li>boost 1.58</li></ol><blockquote><p>由于本人用1.61版本编译不成功，所以转战1.58版本。原因在visual studio 2013上，也许你用其他版本vs就能编译成功。</p></blockquote><a id="more"></a><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><h4 id="编译64位"><a href="#编译64位" class="headerlink" title="编译64位"></a>编译64位</h4><p>进入开始菜单visual studio tools，找到<code>VS2013 x64 本机工具命令提示</code>，双击打开。</p><blockquote><p>你会发现这就是一个cmd，而编译boost不是随便打开一个cmd就行的。编译64位需要打开这个cmd，而编译32位的需要打开<code>VS2013 x86 本机工具命令提示</code>这个cmd。</p></blockquote><p>切换到你的boost根目录，例如我的在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\local\boost_1_58_0</span><br></pre></td></tr></table></figure><p>至此，你会发现在此路径下存在bootstrap.bat，在windows环境中只需运行<code>call bootstrap.bat</code>就会生成64位的<code>b2.exe</code>和<code>bjam.exe</code>。</p><p>接下来就是利用<code>bjam.exe</code>来编译。</p><p>如果需要获取动态库，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 threading=multi link=shared address-model=64</span><br></pre></td></tr></table></figure><p>以上是生成全部的lib，如果只生成需要的库，例如date_time，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --with-date_time toolset=msvc-12.0 threading=multi link=static address-model=64</span><br></pre></td></tr></table></figure><p>要有<code>address-model=64</code>属性，如果没有这个属性，会默认生成32位的平台库，加入这个选项才能生成64位的DLL。</p><p>如果需要获取静态库，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 threading=multi link=static address-model=64</span><br></pre></td></tr></table></figure><p>你会发现，这就是将link属性变为static。</p><p>也可以指定生成库的文件目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 --stagedir=<span class="string">"C:\boostLib"</span> threading=multi link=shared address-model=64</span><br></pre></td></tr></table></figure><h4 id="编译32位"><a href="#编译32位" class="headerlink" title="编译32位"></a>编译32位</h4><p>编译32位库只需要将cmd换为<code>VS2013 x86 本机工具命令提示</code>然后和64位进行相同操作。</p><h3 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h3><p>打开visual studio，创建工程。</p><p>编辑属性，打开<code>配置属性 &gt; VC++目录</code>，配置<code>包含目录</code>和<code>库目录</code>，接着打开<code>配置属性 &gt; 链接器 &gt; 输入</code>，在<code>附加依赖项</code>中添加lib。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libboost_chrono-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_system-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_thread-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_date_time-vc120-mt-gd-1_58.lib</span><br></pre></td></tr></table></figure><blockquote><p>我是编译的静态库，所以只需要在此添加所需的lib就可以了。如果生成的是动态库，还需要将dll所在的路径添加到系统路径path属性中，==重启==电脑使路径生效。</p></blockquote><p>将visual studio的编译器换成x64。</p><p>至此，可以说环境配置完成，可以贴上测试代码运行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/condition.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/mutex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bounded_buffer</span> :</span> <span class="keyword">private</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> boost::mutex::scoped_lock lock;</span><br><span class="line">bounded_buffer(<span class="keyword">int</span> n) : begin(<span class="number">0</span>), end(<span class="number">0</span>), buffered(<span class="number">0</span>), circular_buf(n) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="function">lock <span class="title">lk</span><span class="params">(monitor)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (buffered == circular_buf.size())</span><br><span class="line">buffer_not_full.wait(lk);</span><br><span class="line">circular_buf[end] = m;</span><br><span class="line">end = (end + <span class="number">1</span>) % circular_buf.size();</span><br><span class="line">++buffered;</span><br><span class="line">buffer_not_empty.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">lock <span class="title">lk</span><span class="params">(monitor)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (buffered == <span class="number">0</span>)</span><br><span class="line">buffer_not_empty.wait(lk);</span><br><span class="line"><span class="keyword">int</span> i = circular_buf[begin];</span><br><span class="line">begin = (begin + <span class="number">1</span>) % circular_buf.size();</span><br><span class="line">--buffered;</span><br><span class="line">buffer_not_full.notify_one();</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> begin, end, buffered;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; circular_buf;</span><br><span class="line">boost::condition buffer_not_full, buffer_not_empty;</span><br><span class="line">boost::mutex monitor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bounded_buffer <span class="title">buf</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">buf.send(n);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sent: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">buf.send(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">n = buf.receive();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"received: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">-1</span>); <span class="comment">// -1 indicates end of buffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">boost::<span class="function">thread <span class="title">thrd1</span><span class="params">(&amp;sender)</span></span>;</span><br><span class="line">boost::<span class="function">thread <span class="title">thrd2</span><span class="params">(&amp;receiver)</span></span>;</span><br><span class="line">thrd1.join();</span><br><span class="line">thrd2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://www.cnblogs.com/codingmylife/archive/2012/11/05/2754778.html" target="_blank" rel="noopener">编译64位boost</a></li><li><a href="http://blog.csdn.net/zhaoya_huangqing/article/details/47318479" target="_blank" rel="noopener">新手，Visual Studio 2013 配置Boost库。 如何编译和选择，遇到无法打开文件“libboost_thread-vc120-mt-gd-1_58.lib的解决办法</a></li><li><a href="http://www.boost.org/" target="_blank" rel="noopener">boost官网</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> boost </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git本地文件夹上传至github</title>
      <link href="/2016/11/09/git%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E8%87%B3github/"/>
      <url>/2016/11/09/git%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E8%87%B3github/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文初衷是想将本地部分文件夹推送到github进行保存共享，折腾一番终于有所斩获，在此笔记以备后来参考。</p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ol><li>windows 10</li><li><a href="https://git-scm.com/download" target="_blank" rel="noopener">git bash</a></li></ol><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>安装完git bash之后，就可以在git bash内进行各种操作。</p><p>右键Git Bash Here，你就会发现出现类似于linux的对话框，在这里你可以完全用linux指令来完成各种操作。</p><blockquote><p>本文已经假设你已经安装好git bash，并且完成本地与远程账户的关联，如果还没有完成请右转google。</p></blockquote><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>假设我的根路径在D盘，右键<code>Git Bash Here</code>。在其中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir abc</span><br><span class="line"><span class="built_in">cd</span> abc</span><br><span class="line">git init <span class="comment">#这是用来初始化文件夹git</span></span><br></pre></td></tr></table></figure><p>此时你会发现在<code>D:/abc/</code>下出现<code>.git</code>文件夹，这是用来与github关联的。</p><h3 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir</span><br><span class="line">touch aaa</span><br><span class="line">touch dir/aaa</span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure><h3 id="添加远程Git"><a href="#添加远程Git" class="headerlink" title="添加远程Git"></a>添加远程Git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/maxiaoyuelun/abc.git</span><br></pre></td></tr></table></figure><blockquote><p>假设你已经创建好远程名叫<code>abc</code>的仓库了，并且假设你在仓库你添加了<code>README.md</code>文件。</p></blockquote><h3 id="远程与本地合并"><a href="#远程与本地合并" class="headerlink" title="远程与本地合并"></a>远程与本地合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'merge'</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>至此你会在本地文件夹下发现多了<code>README.md</code>文件。</p><h3 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'upload'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>在浏览器中打开就可以看到已经将本地文件夹内的内容上传至github中了。</p><blockquote><p>在进行<code>push</code>和<code>pull</code>之前，必须进行commit，否则会有error。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm aaa</span><br><span class="line">git status</span><br><span class="line">git commit -m <span class="string">'del aaa'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>其他对于文件的操作可在参考文献中寻找。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://git.oschina.net/progit/index.html" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://www.yiibai.com/git/home.html" target="_blank" rel="noopener">Git教程</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="http://gubangzhong.cn/2017/07/13/批处理git命令/">批处理git命令</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel5.1开发博客系列一</title>
      <link href="/2016/11/09/Laravel5-1%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>/2016/11/09/Laravel5-1%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p><code>WampServer</code>、<code>PHPStorm</code>、浏览器</p><h2 id="开发前设置"><a href="#开发前设置" class="headerlink" title="开发前设置"></a>开发前设置</h2><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改<code>hosts</code>文件</h3><p>打开“我的电脑”，进入 <code>C:\Windows\System32\drivers\etc</code> 目录，然后打开 <code>hosts</code> 文件，在最下面添加一行代码：<code>127.0.0.1 maxiaoyuelun.cn</code>，之后保存退出（可能需要管理员权限）。</p><a id="more"></a><h3 id="启用WampServer虚拟域名功能"><a href="#启用WampServer虚拟域名功能" class="headerlink" title="启用WampServer虚拟域名功能"></a>启用<code>WampServer</code>虚拟域名功能</h3><p>进入 <code>C:\wamp\bin\apache\apache2.4.9\conf</code> 目录，打开<code>apache</code>配置文件 <code>httpd.conf</code> ，在里面搜索 <code>httpd-vhosts.conf</code> ，会找到下面这样一行：<br><code>#Include conf/extra/httpd-vhosts.conf</code><br>把最前面的 <code>#</code> 去掉（没有 <code>#</code> 的话直接进行下一步），保存并退出。</p><h3 id="添加虚拟域名"><a href="#添加虚拟域名" class="headerlink" title="添加虚拟域名"></a>添加虚拟域名</h3><p>进入 <code>C:\wamp\bin\apache\apache2.4.9\conf\extra</code> 目录，打开 <code>httpd-vhosts.conf</code>文件，添加下面的代码：</p><pre><code>&lt;VirtualHost *:80&gt;    ServerAdmin webmaster@laravel.dev    DocumentRoot &quot;d:/wamp/www/laravel5/public&quot;    ServerName laravel.dev    ErrorLog &quot;logs/laravel.dev-error.log&quot;    CustomLog &quot;logs/laravel.dev-access.log&quot; common&lt;/VirtualHost&gt;</code></pre><p>至此，已经启用虚拟域名并添加好了虚拟域名，重启apache服务，在浏览器输入<code>http://laravel.dev/</code>，可以看到已经可以正常访问本地的<code>Laravel 5</code>了。</p><h2 id="开发必要资源"><a href="#开发必要资源" class="headerlink" title="开发必要资源"></a>开发必要资源</h2><h3 id="添加make-view"><a href="#添加make-view" class="headerlink" title="添加make:view"></a>添加<code>make:view</code></h3><p>参考<a href="https://github.com/svenluijten/artisan-view" target="_blank" rel="noopener"><code>artisan-view</code></a>进行添加</p><h3 id="添加AdminLTE"><a href="#添加AdminLTE" class="headerlink" title="添加AdminLTE"></a>添加<code>AdminLTE</code></h3><p>在此之前需安装好bower<br>进入<code>C:\wamp\www\Laravel\public</code>目录中，右击运行<code>Use Composer Here</code>，添加如下代码：<br><code>bower install admin-lte</code><br>参考文献：<a href="https://almsaeedstudio.com/blog/integrate-adminlte-with-laravel" target="_blank" rel="noopener"><code>Integrate AdminLTE with Laravel 5</code></a></p><p>至此，初步准备阶段完成。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫抓取大伟吉他谱</title>
      <link href="/2016/11/09/Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%A4%A7%E4%BC%9F%E5%90%89%E4%BB%96%E8%B0%B1/"/>
      <url>/2016/11/09/Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%A4%A7%E4%BC%9F%E5%90%89%E4%BB%96%E8%B0%B1/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>喜欢用最近开始，最近由于个人需要，利用爬虫爬了一些东西，不得不说python是一大利器，只要你熟练之后，就可以随意创造你想要的大部分东西。插播点牢骚话，最近看网上的某些言论，实在是不敢苟同，说到创新，就似乎要打碎一切东西，从头再来，我所理解的创新是站在别人的基础上再做出自己的东西。首先，就需要对自己的领域熟悉，然后基于特定的需要，借用某种技术来实现目的。实际上，大部分的创新都是基于某种应用需求，当然前瞻性的理论创新也很重要，这里说的不是简单的一元论。</p></blockquote><p>这篇博文是用python来爬取<a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">大伟吉他教室</a>谱子的例程，在此笔记，加深印象。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>windows 10，pycharm，anaconda，scrapy，google chrome</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文因为有特定的爬取目的，所以在很多步骤上就有了简化的处理。在开始前，需要利用chrome浏览器的调试功能找到需要爬取内容的位置：就是xpath位置，然后再进行编码测试。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><pre><code>scrapy startproject tutorial</code></pre><h4 id="创建spider"><a href="#创建spider" class="headerlink" title="创建spider"></a>创建spider</h4><pre><code>scrapy genspider guitar guitar.com</code></pre><h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><p>上面两部就创建了guitar.py文件。</p><p>打开guitar.py文件，所示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuitarSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"guitar"</span></span><br><span class="line">    allowed_domains = [<span class="string">"guitar.com"</span>]</span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">'http://www.guitar.com/'</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>添加代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuitarSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"guitar"</span></span><br><span class="line">    allowed_domains = [<span class="string">"guitar.com"</span>]</span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">'http://www.daweijita.com/59492.html'</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================2=================="</span></span><br><span class="line">        <span class="keyword">print</span> response.headers</span><br><span class="line">        <span class="keyword">for</span> sel1 <span class="keyword">in</span> response.xpath(<span class="string">'//*[@id="main-content"]/div[2]/div[2]/div/div[1]'</span>):</span><br><span class="line">            <span class="keyword">for</span> sel <span class="keyword">in</span> sel1.xpath(<span class="string">'.//a/@href'</span>).re(<span class="string">r'.*.gif$'</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"===="</span></span><br><span class="line">                <span class="keyword">print</span> sel</span><br><span class="line">                <span class="keyword">print</span> re.match(<span class="string">r'.*fufei.*'</span>,sel)</span><br><span class="line">                <span class="keyword">if</span> re.match(<span class="string">r'.*fufei.*'</span>,sel) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"$$$$$$$$$$$$$$$$$$$$$"</span></span><br><span class="line">                    s=sel.split(<span class="string">'/'</span>)</span><br><span class="line">                    s2=s[<span class="number">-1</span>].split(<span class="string">'_'</span>)</span><br><span class="line">                    <span class="keyword">print</span> s2</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">                        s3=<span class="string">u'tab_'</span>+s2[<span class="number">1</span>]+<span class="string">u'_'</span>+s2[<span class="number">2</span>]+<span class="string">u'_'</span>+<span class="string">u'%d'</span> % num +<span class="string">u'.gif'</span></span><br><span class="line">                        <span class="keyword">print</span> s3</span><br><span class="line">                        s4=s[:<span class="number">-1</span>]+[s3]</span><br><span class="line">                        <span class="keyword">print</span> s4</span><br><span class="line">                        s5=s4[<span class="number">0</span>]+<span class="string">u'//'</span>+s4[<span class="number">2</span>]+<span class="string">u'/'</span>+s4[<span class="number">3</span>]+<span class="string">u'/'</span>+s4[<span class="number">4</span>]+<span class="string">u'/'</span>+s4[<span class="number">5</span>]</span><br><span class="line">                        local_filename = s3 </span><br><span class="line">                        r = requests.get(s5, stream=<span class="keyword">True</span>) </span><br><span class="line">                        <span class="keyword">print</span> r.status_code</span><br><span class="line">                        <span class="keyword">if</span> r.status_code==<span class="number">200</span>:</span><br><span class="line">                            <span class="keyword">with</span> open(local_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                                <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):  </span><br><span class="line">                                    <span class="keyword">if</span> chunk: <span class="comment"># filter out keep-alive new chunks  </span></span><br><span class="line">                                        f.write(chunk)  </span><br><span class="line">                                        f.flush() </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    local_filename = sel.split(<span class="string">'/'</span>)[<span class="number">-1</span>]  </span><br><span class="line">                    r = requests.get(sel, stream=<span class="keyword">True</span>) </span><br><span class="line">                    <span class="keyword">with</span> open(local_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):  </span><br><span class="line">                            <span class="keyword">if</span> chunk: <span class="comment"># filter out keep-alive new chunks  </span></span><br><span class="line">                                f.write(chunk)  </span><br><span class="line">                                f.flush()  </span><br><span class="line">               </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"===="</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================2=================="</span></span><br></pre></td></tr></table></figure><p>在此就算简单完成了爬取工作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>多次测试之后，其实可以发现，该网站中的图片都是以这样的形式命名：</p><pre><code>tab_演唱者_歌曲名_数字.gif</code></pre><p>也就是说，修改上面代码中的start_urls，定位到需要爬取的网站，可以爬取大部分的歌曲，但是如果碰到部分不一样的格式，则需要自己手动调试。</p><p>那么可以先定位到<a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">全站教学资源列表</a>爬取歌曲以及演唱者，根据中英文适当转化为拼音，记录到items中保存，然后可以提取items中的信息进行组合来爬取所有曲谱，这在下面的文章中会完善。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">python菜鸟教程</a></li><li><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html" target="_blank" rel="noopener">scrapy中文文档</a></li><li><a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">大伟吉他教室</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://gubangzhong.cn/2017/11/23/在python下利用opencv读取图片/">在python下利用opencv读取图片</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Protobuf安装使用指南</title>
      <link href="/2016/11/09/Protobuf%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2016/11/09/Protobuf%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><ol><li><a href="https://github.com/google/protobuf/" target="_blank" rel="noopener">https://github.com/google/protobuf/</a></li></ol><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>Windows 10 企业版 64 位（10.0，版本14393）</li><li>Visual Studio 2013</li><li>Git-2.10.1-64-bit.exe</li><li>cmake-3.6.2-win64-x64.msi</li></ol><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>在官网下载protubuf，我将其下载解压到<code>D:\Science\Google</code>下</p><h4 id="创建和编译"><a href="#创建和编译" class="headerlink" title="创建和编译"></a>创建和编译</h4><p>在开始菜单找到<code>Visual Studio Tools</code>，点击。</p><p>在出现的文件中，双击<code>VS2013 x64 本机工具命令提示</code>。</p><p>切换路径到<code>D:\Science\Google</code>下。</p><blockquote><p>在windows下切换路径直接使用<code>D:</code>回车即可，不需要<code>cd</code>命令。</p></blockquote><p>之后按照教程 <a href="https://github.com/google/protobuf/blob/master/cmake/README.md" target="_blank" rel="noopener">https://github.com/google/protobuf/blob/master/cmake/README.md</a> 输入如下指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> protobuf-master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b release-1.7.0 https://github.com/google/googlemock.git gmock</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> gmoke</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b release-1.7.0 https://github.com/google/googletest.git gtest</span><br></pre></td></tr></table></figure><p>至此，安装成功<code>gmoke</code>。</p><p>下面进行编译，输入如下指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> cmake</span><br><span class="line"></span><br><span class="line">mkdir build &amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">mkdir solution &amp; <span class="built_in">cd</span> solution</span><br><span class="line"></span><br><span class="line">cmake -G <span class="string">"Visual Studio 12 2013 Win64"</span> ^</span><br><span class="line"> -DCMAKE_INSTALL_PREFIX=../../../../install ^</span><br><span class="line"> ../..</span><br></pre></td></tr></table></figure><p>将会在solution文件夹下创建<code>protobuf.sln</code>。</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>双击打开<code>protobuf.sln</code>。</p><p>在<code>生成</code>工具下打开<code>批生成</code>，选中<code>INSTALL Debug</code>，关闭选项卡。</p><p>之后生成解决方案，静待几分钟之后，生成成功，发现在<code>D:\Science\Google\install</code>下出现需要的bin、include、lib等文件夹。</p><blockquote><p>Release生成同理。</p></blockquote><p>至此，install文件夹如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├─bin</span><br><span class="line">├─cmake</span><br><span class="line">├─include</span><br><span class="line">│  └─google</span><br><span class="line">│      └─protobuf</span><br><span class="line">│          ├─compiler</span><br><span class="line">│          │  ├─cpp</span><br><span class="line">│          │  ├─csharp</span><br><span class="line">│          │  ├─java</span><br><span class="line">│          │  ├─javanano</span><br><span class="line">│          │  ├─js</span><br><span class="line">│          │  ├─objectivec</span><br><span class="line">│          │  ├─php</span><br><span class="line">│          │  ├─python</span><br><span class="line">│          │  └─ruby</span><br><span class="line">│          ├─io</span><br><span class="line">│          ├─stubs</span><br><span class="line">│          └─util</span><br><span class="line">└─lib</span><br></pre></td></tr></table></figure><blockquote><p>上面的树状是用命令<code>tree</code>生成。</p></blockquote><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p>在此初步试用protobuf。</p><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/</a> 中给出了使用指南。</p><p>本文简单给出一个例子，具体使用请查看手册。</p><p>为简单起见，在<code>D:\Science\Google\install\bin</code>下创建person.proto文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package Im;</span><br><span class="line">message helloworld</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    requiredint32  id=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    requiredstring  str=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    optionalint32  opt=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>protoc.exe</code>生成<code>.h</code>和<code>.cc</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=D:\Science\Google\install\bin person.proto</span><br></pre></td></tr></table></figure><p>即在<code>D:\Science\Google\install\bin</code>文件夹下生成person.pb.h和person.pb.cc文件。</p><p>打开visual studio 2013，创建空项目Person_。</p><p>新建main.cpp。在其中输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lm::helloworld msg1;</span><br><span class="line">    msg1.set_id(<span class="number">100</span>);</span><br><span class="line">    msg1.set_str(<span class="string">"200"</span>);</span><br><span class="line">    msg1.set_opt(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.opt() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将person.pb.h和person.pb.cc文件拷贝到和main.cpp同样的路径下，并将这两个文件添加到工程中。</p><p>之后需要打开工程属性选项卡。</p><p>选择<code>VC++目录</code>。在<code>包含目录</code>中添加D:\Science\Google\install\include，在<code>库目录</code>中添加D:\Science\Google\install\lib。</p><p>选择<code>链接器&gt;输入</code>。在<code>附加依赖项</code>中添加libprotobufd.lib、libprotobuf-lited.lib、libprotocd.lib。</p><p>选择<code>C/C++&gt;代码生成</code>。将<code>运行库</code>中的多线程调试DLL(/MDd)替换为多线程调试(/MTd)。</p><p>至此可以编译生成。</p><p>如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p>至此，整个安装教程结束。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li><li><a href="http://gubangzhong.cn/2017/07/13/glog初步体验/">glog初步体验</a></li><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++输出到txt日志</title>
      <link href="/2016/11/09/C++%E8%BE%93%E5%87%BA%E5%88%B0txt%E6%97%A5%E5%BF%97/"/>
      <url>/2016/11/09/C++%E8%BE%93%E5%87%BA%E5%88%B0txt%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="关于C-中使用fstream输出到文件中的部分操作"><a href="#关于C-中使用fstream输出到文件中的部分操作" class="headerlink" title="关于C++中使用fstream输出到文件中的部分操作"></a>关于C++中使用<code>fstream</code>输出到文件中的部分操作</h3><blockquote><p>在编写程序的时候，常常需要将日志输出到类似txt的文件中，这时需要自己编写相关的代码。当用搜索引擎在网上进行搜索时，大多数给予的是有关C的代码，而对于C++的今天，何不用C++来简单实现这些功能呢？作为时代的进步，简化也就意味着高效。这以我在项目中的部分类似代码作为展示，请各位不吝赐教！抱拳！(用引用作为前言是不是不太好…)</p></blockquote><a id="more"></a><p>工具： Visual Studio 2013</p><p>通常都会在工程中加入头文件<code>#include</code></p><p>在这里是将日志输出到txt文件中。</p><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><ul><li>这是将数字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><ul><li>这是将文字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><ul><li>这是将文字和数字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="string">"="</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>鉴于以上组合，相信各位看官了解了如何利用C++进行文字的输出，输入请待下回分解。</p></blockquote><h3 id="关于C-中使用SYSTEMTIME获取当前时间的部分操作"><a href="#关于C-中使用SYSTEMTIME获取当前时间的部分操作" class="headerlink" title="关于C++中使用SYSTEMTIME获取当前时间的部分操作"></a>关于C++中使用<code>SYSTEMTIME</code>获取当前时间的部分操作</h3><blockquote><p>在输出日志的时候，通常需要记录日志输出的发生时间，这就需要程序员自己调用内置函数。也许看官看到这已经发现这是有关调试的文章。好吧！我承认了！调试是软件开发过程中不可或缺的步骤，很重要！</p></blockquote><p>工具： Visual Studio 2013</p><p>通常都会在工程中加入头文件<code>#include</code></p><p>在这里是将时间输出到txt文件中。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>这里只是简单实现，需要更好的看官可自行设计。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SYSTEMTIME sys;</span><br><span class="line">    GetLocalTime(&amp;sys);</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; sys.wYear &lt;&lt; <span class="string">"/"</span> &lt;&lt; sys.wMonth &lt;&lt; <span class="string">"/"</span> &lt;&lt; sys.wDay &lt;&lt; <span class="string">" "</span> &lt;&lt; sys.wHour &lt;&lt; <span class="string">"："</span> &lt;&lt; sys.wMinute &lt;&lt; <span class="string">"："</span> &lt;&lt; sys.wSecond &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，本节基本结束了，至于函数中各个参数什么意思，相信搜索引擎会帮你的忙的。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CUDA均值滤波</title>
      <link href="/2016/11/09/CUDA%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/2016/11/09/CUDA%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>cuda进行均值滤波，主要blockIdx、blockDim、threadIdx等知识点。</p></blockquote><a id="more"></a><h4 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//时间相关头文件，可用其中函数计算图像处理速度  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 80000</span></span><br></pre></td></tr></table></figure><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">runtest_img</span><span class="params">(<span class="keyword">int</span>* host_a, <span class="keyword">int</span>* host_b, <span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello OpenCV CUDA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Mat img = imread(<span class="string">"me.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (img.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No \"me.jpg\""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat gray_img;</span><br><span class="line"></span><br><span class="line">cvtColor(img, gray_img, CV_RGB2GRAY);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Gray Image"</span>, gray_img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = gray_img.rows;</span><br><span class="line"><span class="keyword">int</span> cols = gray_img.cols;</span><br><span class="line"><span class="keyword">int</span> channels = gray_img.channels();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rows : "</span> &lt;&lt; rows &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cols : "</span> &lt;&lt; cols &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"channels : "</span> &lt;&lt; channels &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* host_img = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line"><span class="keyword">int</span>* host_output_img = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">uchar* data = gray_img.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols ; j++)&#123;</span><br><span class="line">host_img[i*cols+j] = data[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; host_img[(rows - <span class="number">1</span>)*cols + cols - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">long</span> now1 = clock();<span class="comment">//存储图像处理开始时间   </span></span><br><span class="line">runtest_img(host_img, host_output_img, rows, cols);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"GPU运行时间为：%dms\n"</span>, <span class="keyword">int</span>(((<span class="keyword">double</span>)(clock() - now1)) / CLOCKS_PER_SEC * <span class="number">1000</span>));<span class="comment">//输出GPU处理时间  </span></span><br><span class="line">Mat mean_filter_img(Size(cols, rows), CV_8U);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">uchar* data = mean_filter_img.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">data[j]=host_output_img[i*cols + j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">"Mean Filter Image"</span>, mean_filter_img);</span><br><span class="line"></span><br><span class="line">cvWaitKey();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kernel-cu"><a href="#kernel-cu" class="headerlink" title="kernel.cu"></a>kernel.cu</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">checkCudaErrors</span><span class="params">(cudaError err)</span><span class="comment">//错误处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cudaSuccess != err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"CUDA Runtime API error: %s.\n"</span>, cudaGetErrorString(err));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">meanFilter</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> h,<span class="keyword">int</span> w)</span><span class="comment">//处理核函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tid = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nx = blockIdx.x;</span><br><span class="line"><span class="keyword">int</span> ny = threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt; h<span class="number">-1</span> &amp;&amp; ny&gt;<span class="number">0</span> &amp;&amp; ny &lt; w<span class="number">-1</span>)&#123;</span><br><span class="line">b[tid] = <span class="keyword">int</span>((a[(blockIdx.x - <span class="number">1</span>)*blockDim.x + threadIdx.x - <span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x - <span class="number">1</span>)*blockDim.x + threadIdx.x +<span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x +<span class="number">1</span>)*blockDim.x + threadIdx.x - <span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x +<span class="number">1</span>)*blockDim.x + threadIdx.x + <span class="number">1</span>]) / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b[tid] = a[tid];</span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">runtest_img</span><span class="params">(<span class="keyword">int</span>* host_a, <span class="keyword">int</span>* host_b, <span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">cudaDeviceProp prop;</span><br><span class="line">checkCudaErrors(cudaGetDeviceCount(&amp;num));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">cudaGetDeviceProperties(&amp;prop, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dev_a, *dev_b; </span><br><span class="line"><span class="comment">//int *dev_h, *dev_w;</span></span><br><span class="line">checkCudaErrors(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w));<span class="comment">//分配显卡内存</span></span><br><span class="line">checkCudaErrors(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w));</span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMalloc((void**)&amp;dev_h, sizeof(int)));//分配显卡内存</span></span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMalloc((void**)&amp;dev_w, sizeof(int)));</span></span><br><span class="line"></span><br><span class="line">checkCudaErrors(cudaMemcpy(dev_a, host_a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyHostToDevice));<span class="comment">//将主机待处理数据内存块复制到显卡内存中</span></span><br><span class="line">checkCudaErrors(cudaMemcpy(dev_b, host_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyHostToDevice));</span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMemcpy(dev_h, &amp;h, sizeof(int), cudaMemcpyHostToDevice));//将主机待处理数据内存块复制到显卡内存中</span></span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMemcpy(dev_w, &amp;w, sizeof(int), cudaMemcpyHostToDevice));</span></span><br><span class="line"></span><br><span class="line">meanFilter &lt;&lt;&lt;h, w &gt;&gt;&gt;(dev_a, dev_b, h,w);<span class="comment">//调用显卡处理数据</span></span><br><span class="line">checkCudaErrors(cudaMemcpy(host_b, dev_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyDeviceToHost));<span class="comment">//将显卡处理完数据拷回来</span></span><br><span class="line"></span><br><span class="line">cudaFree(dev_a);<span class="comment">//清理显卡内存</span></span><br><span class="line">cudaFree(dev_b);</span><br><span class="line"><span class="comment">/*cudaFree(dev_h);</span></span><br><span class="line"><span class="comment">cudaFree(dev_w);*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo静态站点搭建</title>
      <link href="/2016/11/09/Hexo%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%90%AD%E5%BB%BA/"/>
      <url>/2016/11/09/Hexo%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Windows，Notepad++，Node</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ol><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ol><p>如果您的电脑中尚未安装所需要的程序，请自行安装。</p><a id="more"></a><p>其次需要创建Github Pages。至于如何创建，可自行谷歌，如博主有时间再更。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用Git Bash输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml #网站配置信息，您可以在此配置大部分的参数。</span><br><span class="line">├── package.json    #应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</span><br><span class="line">├── scaffolds   #模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">├── source  #资源文件夹是存放用户资源的地方。</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes  #主题 文件夹。Hexo 会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure><h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p><p>在终端窗口下，定位到 Hexo 站点目录themes下。使用 Git Bash代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h4><p>hexo自带服务器，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>即可在浏览器中查看。</p><h2 id="Hexo部署Git命令"><a href="#Hexo部署Git命令" class="headerlink" title="Hexo部署Git命令"></a>Hexo部署Git命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>其余部分可参考给出的参考文献，至于在Github Pages中使用自己的域名，需要在Repository中部署CNAME文件。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo快速、简洁且高效的博客框架</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next精于心，简于形</a></p><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">hexo你的博客</a></p><p><a href="http://www.zhihu.com/question/20463581" target="_blank" rel="noopener">知乎：如何搭建个人独立博客？</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>opencv指针读取图片</title>
      <link href="/2016/08/28/opencv%E6%8C%87%E9%92%88%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/"/>
      <url>/2016/08/28/opencv%E6%8C%87%E9%92%88%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>一段代码</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2\opencv.hpp&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Hello OpenCV!&quot; &lt;&lt; endl;</span><br><span class="line">Mat img = imread(&quot;me.jpg&quot;);</span><br><span class="line">if (img.empty())&#123;</span><br><span class="line">cout &lt;&lt; &quot;No \&quot;me.jpg\&quot;&quot; &lt;&lt; endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int channels = img.channels();</span><br><span class="line">int rows = img.rows;</span><br><span class="line">int cols = img.cols;</span><br><span class="line">cout &lt;&lt; img.isContinuous() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; img.depth() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; img.type() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;channels = &quot; &lt;&lt; channels &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;rows = &quot; &lt;&lt; rows &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;cols = &quot; &lt;&lt; cols &lt;&lt; endl;</span><br><span class="line">imshow(&quot;这是我啊&quot;, img);</span><br><span class="line">Mat r(Size(cols, rows), CV_8U);</span><br><span class="line">int a[296][207];</span><br><span class="line">//imshow(&quot;Blue&quot;, r);</span><br><span class="line">for (int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">uchar* red = r.ptr&lt;uchar&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; cols*3; j=j+3)&#123;</span><br><span class="line">red[j/3] = data[j];</span><br><span class="line">a[i][j / 3] = data[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imshow(&quot;Blue&quot;, r);</span><br><span class="line">cout &lt;&lt; a[0][0] &lt;&lt; endl;</span><br><span class="line">waitKey();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中国通胀、汇率、楼市、股市有啥关系</title>
      <link href="/2016/05/03/%E4%B8%AD%E5%9B%BD%E9%80%9A%E8%83%80%E6%B1%87%E7%8E%87%E6%A5%BC%E5%B8%82%E8%82%A1%E5%B8%82%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB/"/>
      <url>/2016/05/03/%E4%B8%AD%E5%9B%BD%E9%80%9A%E8%83%80%E6%B1%87%E7%8E%87%E6%A5%BC%E5%B8%82%E8%82%A1%E5%B8%82%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>演讲人：邱晓华，著名经济学家，国家统计局原局长<br>现在，我把眼光回到今天，看一看今年中国经济的一些主要方面的变化。</p><a id="more"></a><h4 id="一、增长的问题"><a href="#一、增长的问题" class="headerlink" title="一、增长的问题"></a>一、增长的问题</h4><p>中国经济从增长的角度，从今年看未来，一个基本的结论是：有底，但是没有高度。未来一段时间，中国经济很可能就像人们说的，是一个”L”形的发展态势，不会是一个”V”形的发展态势，也不会是一个”U”形的发展态势，也不会是”W”形的发展态势，它就是一个”L”形的发展态势。它是一个有底部的增长态势，由底要往上走，在未来若干年都不是那么容易。<br>这个”底”在哪里？就是”十三五”提出来的”6.5%”左右，这是我们党提出来第一个百年目标要实现的最基本的速度，也就是说今年也好、明后年也好，中国经济都将在6.5%这个底线上面来增长。不会明显跌破6.5%，也不会明显高于6.5%。因此，政府会想方设法都要让这个”底”守住。<br>而中国又是一个相对独特的国家，它的独特性表现在两方面：<br>第一，它有一个很健全的行政组织体系，从中央到村一级，有一个很健全的行政组织体系，这在世界范围之内除了朝鲜都是少有的。因此，一声令下，能够快速地在全国形成一个巨大的行政推力，这是别的国家所没有的。如果只有这样一个组织体系可能还不行。<br>第二，中国是一个政府还掌握着相当要素资源的国家，从土地、银行到矿产，甚至到人——比如说我们中国所有的聪明人、能人，大多数掌握在政府的手上，哪怕是民营企业家都挂上了各种的社会职务，他也纳入到政府的体系里面。所以，它能够运用强有力的行政手段，运用自身所掌握的要素资源，来实现短期的发展。这是别的国家所没有的，所以它不会轻易地让GDP增速跌破6.5%这个底部。<br>从货币政策、财政政策等一些政策面上来看，我们同样能够看到中国经济在政策面上还是有一定的控制力。货币政策方面，虽然利率杠杆的使用是越来越接近天花板，但是在其他货币工具方面的使用还是有很大的空间，降准这是一个还有很大空间的工具，现在18%左右，你降到10%左右的正常水平还有8%，降到15%的安全线，稍微这里要宽松一点，也还有3%，每降1%就可以增加超过1万亿的商业银行的高能货币，从这个角度来说还是有货币政策灵活运用的一定的空间。<br>财政政策方面，尽管前面讲地方政府债台高筑，但从整个中国政府的角度来看，目前的负债率高的测算50%左右，政府自己说40%左右。不管是40%还是50%，甚至如果再加一块，也在世界正常范围之内，在大的经济体里面，中国政府的负债率也还是低的，美国接近100%，欧洲接近100%，日本超过200%，中国现在在60%以内。所以从这个角度来说，政府还可以加杠杆。<br>从基本面上来看，中国经济的基本面第一是工业化，第二是城市化，第三是信息化，第四是农业现代化。过去是，现在是，今后一样也还会是中国经济的基本面。完成工业化、完成城市化、完成信息化、完成农业现代化，是整个中国经济发展的最基本的方面，它能够创造出很多的需求，能够创造出很大的供给，这几个领域里面目前这个趋势还没有完结，只是现在提出来要有更多的新型的分量。从这个角度来说，也还有一个增长的惯性。<br>大家知道城市化每增加一个农民变为市民，县一级大概是5万左右的公共投入，包括基础设施，包括科教文卫；中等城市15万左右，大中城市20到更高一点不同。<br>因此，从城市化水平，从目前户籍人口占40%左右要在未来5年提高到45—50%之间，有3亿人要变为市民，即已进城的1亿人要由农民变为市民，要解决户口落地的问题，城中村的还有棚户区的1亿人要变为市民，中部地区的工作了了城市群建设涉及到1亿农民要变为市民，3亿人在未来5年变为市民。大家可以想像他们的市民化一定意味着要有一个巨大的投入，粗略估计都是40万亿以上的投入力度，才能解决3亿人市民化的问题。<br>从基本面的角度来说，它有一个增长惯性，守住底部应当说是有能力、有条件，也是可以实现的。但是它确实没有高度，或者很难达到昨日的高度，几乎已经不可能回到昨日的高度，某个季度、某个时段可能会，但是趋势上已经不大可能。<br>因此，制约中国经济的这些因素不解决，它就很难恢复到之前的高度，而且即使解决了也很难，资源问题、环境问题都很难解决。过去可以容忍的”带血的GDP”、”黑色的GDP”、”无效的GDP”，或者是”低效的GDP”，今后都不可能再实现，或者不可能再追求。<br>GDP增长今年一季度是6.7%，这是一个官方公布的数据，投资增长了10.7%，零售增长了10.3%，外贸还是下降的，但是它是靠信贷的大力度地扩张。大家知道整个社会融资的规模超过6万亿，银行的信贷投入超过4万亿，都比去年同期明显增长。换句话说是靠钱堆出来的。但是这个钱也还没有完全到位，还走在路上，还没有完全地成为现实的推动力，但是有一部分已经进入了。<br>不管怎么说，一季度6.7%总体上还是一个下行，低于去年6.9%，也低于上一季的6.8%，但是大家可以看到，减缓的速度是放慢了，某些方面出现了一定程度的改善。<br>二季度会怎么样？我想中国经济的增长，这几个因素如果没有明显的改善，它很难扭转下行。<br>第一是投资，投资如果不能稳定增长，经济也很难稳下来。眼下看投资是10.7%已经处于稳定了，比去年同期还略高了一点，高了0.3—0.4%。<br>第二是工业，工业从3月份的角度来看已经比1、2月份要回升了，但是从1—3月份来看这个5.8%应该说跟去年没有太大的变化，跟去年同期相比还略有回落。但是从趋势看，看到它有一点抬头的迹象。<br>第三是出口，一季度下降4.2%，3月份似乎有一点季节性和技术性两个因素影响回升，全年能不能扭转下降的局面也关乎到今年的增长。<br>按目前的趋势推断，二季度有可能出现”阶段性的回稳，二季度有可能经济不再下行，可能在6.8%左右的区间，至少不会低于一季度6.7%。这就出现了阶段性的趋稳。下半年，如果目前的稳增长的政策效应能够进一步放大，那么下半年有可能在二季度的基础上面还会略有回升。全年就是6.7—7%之间，平均速度可能全年就是6.8%，有可能是这样一个增长态势。<br>有一个因素需要特别指出，非经济因素对中国经济的影响有可能在今年开始会变得更有利一些，而不是不利一些。非经济因素一方面是指反腐败的这种非经济因素。前一时期更多是以治理乱作为作为反腐败的主线，未来除了继续不放松对乱作为的治理之外，将会把更多的精力或者是更多的注意力放到治理不作为。因为前一段在治理乱作为中间，派生出了一些不作为的倾向。<br>去年我到各个地方去走，跟一些老朋友见面，和地方政府的一些朋友见面，普遍得到的印象就是发展是第二位的，安全是第一位的。所以，以前那种扩张的冲劲、那种发展的热情明显地有所改变，就是心态改变了。<br>我也在政府呆过，也遇到过这种挫折，其实在政府部门呆过的人，在目前这个社会下要抓你一点问题，可以说90%以上的人都会被抓了，不可能没有问题。吃一顿饭可以抓你，你接受了5千块钱的礼品他可以抓你，以前我估计官员收个5千块钱的礼品可能不会是少数的，它可以追溯历史，现在肯定不能收了，但是历史上肯定收过，这个卡那个卡肯定都有。<br>第二，今年是换届开始的一年，地方政府开始换届，从乡政府到县、到市，陆陆续续进入到省一级，都已经进入到换届，新的一轮政治周期开启了。政治周期的开启一定意味着在一线干的同志，肯定要以经济层面、社会层面的一张成绩单去迎来政治国理政上的一定的保障度，这肯定是一个政治周期所带来的一个效应。<br>换句话说，这个地区无论是市还是省的领导人，特别是主要的领导人，都有一种”不能让这个地方出现太多的问题，不能让这个地方的经济太糟糕，要不然就入不了委，要不然就进不了局”，他就有这种政治的冲动，推动着他要把短期的经济尽可能地完成得好一点。<br>第三，今年是”十三五”的开局之年，”十三五”开好局又是大家一个普遍的心态，一些事情可能在开局之年不能太糟糕，也会转化为一定的经济发展的推动力。<br>所以我们看中国经济的2016，不能仅从经济面上去讨论问题，可能还要从非经济面上进一步地来分析问题，这样我们能够看到2016年的中国经济虽然是困难的一年，但是在困难中还是能够实现不跌破底部的发展。所以6.5—7%作为今年的目标守住，估计概率是比较大的，这就是增长的部分。</p><h4 id="二、通胀问题"><a href="#二、通胀问题" class="headerlink" title="二、通胀问题"></a>二、通胀问题</h4><p>通胀，通胀的问题从整个中国经济各方面的环境来看，始终是一个问题。<br>一方面大量的钞票肯定会转换为通胀的压力，这些年的广义货币数量确实是明显增加，从2008年之前的可能就是40、50万亿，现在是已经超过100万亿，那确实有很大的增长。他始终就会对物价形成一定的压力，最终一定会通过通胀来消化掉这些超发的货币，这是一个客观规律，哪个国家都改变不了的。你超发的货币最终就是这个钱不值钱，不值钱不就是通货膨胀吗？<br>第二，这些年各种各样的坏账、各种各样的债务，最终的解决也要通过通胀来冲销，这是始终存在的一个因素。<br>第三，我们很多价格不合理，肯定也还要调整一些价格，涨价的一些因素也还存在。<br>第四，各种不可预见的因素，气候问题、外部世界的问题等等，也可能会造成一定的通胀问题。<br>所以对”通胀不掉以轻心”这句话我认为时刻还是要记在心理，对于政府主要的领导人来说，对于我们企业来说，对于老百姓来说都要记住。也就是说我们始终面临着钱可能贬的风险，所以对于通胀不能掉以轻心。<br>对于眼下中国来说：<br>第一，市场供求关系还是供大于求。目前通胀压力更多的还是由于气候的问题和某些商品的问题造成的，猪肉价格、蔬菜价格大幅度地上涨，造成了短期通胀由1%到2%的变化，现在一季度是2.1%的通胀水平，比去年的1.4%提高了0.7%。应当说，短期是由于这些因素都释放出来。<br>长期的一些因素并没有释放出来，但是始终还是有压力，但是从未来几年来看，中国更大的问题还不是通货膨胀。换句话说，通胀还构不成中国经济的主要问题，因为从总体上看，中国现在还是供给大于需求，因此在这样一个市场环境下面，不大容易出现严重的通货膨胀。<br>第二，中国目前从总体上看，上游产品还没有改变下降的局面，PPI工业品出厂价格已经连续49个月还处于下降，一季度下降为4%多一点，3月份当月下降为4.3%，未来要由降转为增还要一定的时间，来自上游涨价的压力眼下也还不大。<br>第三，外部世界虽然变化了，一些大宗商品价格短期有些波动，但总体上看，相对于过去来自国际的涨价压力，应当说还不是很大，输入性的通胀压力不是很大，美元属于相对的强势，所以大宗商品的价格还是受到强势美元的压制。<br>第四，中国目前的通胀从性质上看属于成本推进型，而不是需求拉动型，两者对通胀释放的机理不一样的。成本推进型是渐进释放，需求拉动型是急剧释放，性质上看也不会短期快速地释放出来。<br>结论就是，未来一段时间里面，中国依然还处于温和通胀型，也就是2—3%之间变化的概率相对大一些，明显高于3%的概率小，明显高于5%的概率更小，这是从温和到中度还需要一定时间，中度到高度那就更需要时间。对于通胀问题，短期还不需要作为一个主要的问题。作为长期来看，你还是要防范，要去划界，要逐步地来解决这些超发的货币、这些债务，这些去产能，去掉这些方面的一些问题所带来的通胀因素，这些问题可能还是需要去解决。</p><h4 id="三、房地产问题"><a href="#三、房地产问题" class="headerlink" title="三、房地产问题"></a>三、房地产问题</h4><p>房地产的问题大家很关心，房价到底会怎么样变化，房地产的形势到底会怎么样的变化。从总体上看两句话：第一，房地产增长时期还没有结束，但是黄金期可能已经结束了。第二，房价上涨趋势也还没有结束，但是大幅度上涨的这种暴涨的趋势，或者是暴利的时期已经结束了。<br>基本的理由是，从房地产的形势来看，只要工业化、城市化、人口增长这三个趋势没有结束，中国的房地产就依然还处于一个增长时期，只是增长率在回落，而不是进入到一个增长率由正转为负的长期趋势。从房价的角度来看，主要是因为基本的消费需求依然还比较强烈，改善性的消费需求还更强烈，投资投机性的需求受到了抑制，因此，这样一个角度来看它还会推动房价的上涨。<br>但是暴涨暴利的时期确实已经结束了，一方面房地产的成本已经大幅度上升，因此它的利润空间也被成本挤掉了一块，另外一方面各项政策的完善也相应地压制了一块价格的上涨和暴利的获得，特别是未来随着房产税的出台，一定会极大地抑制投资、投机型的住房需求。<br>未来房地产的变化，更多会随不同的区域、不同的经济发展水平、不同的居住环境，而发生差异性的变化，一线城市房地产总体上还是处于供不应求的发展状态，因此，它的增长如果有相应的政策，肯定还是会增长比较快的。问题是由于土地等诸多制约条件，因此他们的增长也受到一定的抑制。<br>房地产什么时候会结束增长，房价什么时候会真正转入下降？就是工业化、城市化、人口增长，这三个趋势结束之后就会发生变化。这三个趋势什么时候结束，我估计5—10年之后就会发生改变。5—10年之后中国的工业化大致完成，中国的城市化也接近了一个相对稳定的水平，中国人口也由增长转为下降，那个时候死亡人口大于出生人口，所以中国人口的总量可能到14.5亿或者是14.7亿的时候，开始转为逐步的下降了，而不是再往上涨15亿、16亿……。<br>到那个阶段，那就意味着卖房的人大于买房的人，市场就会发生根本性的逆转。而眼下这个趋势是可以预见到的，因为对于大多数的城里人来说，未来的家庭住房会由目前的一套变为两套、三套，它会多出来，一个年轻的家庭将来会接收自己父母的两套住房，女方、男方各接收一套，这是未来房地产会多出来的发展趋势。<br>至于最近一段炒出来的温州20年的期限这些东西，那完全是因为对政策理解的不正确、不全面。70年不变、70年到期自动延期，至少是政策上明确的。中国虽然土地不是私有的，但是在这70年之内确实是不会变。70年之后会不会变化？我想告诉大家的是，中国的住房至少没有多少住房它的使用寿命能够达到70年，所以这是一个肯定就没有发生变化的可能性，在没有到70年之前就要重新建设、重新改变。<br>第二，70年以后中国的政策也一定会改变，也不会像今天这个政策。所以未来政策也一定会有变化，变化是什么变化？未来住宅土地一定会逐步地私有化，这是肯定的一个局面，至少现在不会，基本国情决定的。但是到未来住宅的土地一定是会变成私有化，因为农民本身宅基地已经鼓励它可以流通、可以抵押，这已经属于私有化的一个趋势。未来城里面的宅基地当然也要完全解决给个人，而不是城里人买的只有地面上的所有权，没有地下的所有权，这都不对的。因为目前大家都已经交过钱了。<br>从这个角度去说大家也不用去担心70年以后，像现在温州说的按房价的1/3补交土地出让金，这是不对的，这也不大可能发生。只是现在温州可能也只是一个炒作，土地主管部门，目前经济困难下面可能想向消费者去要一点钱，但是这种做法肯定是不对的。</p><h4 id="四、汇率问题"><a href="#四、汇率问题" class="headerlink" title="四、汇率问题"></a>四、汇率问题</h4><p>现在我们最需要防范的风险当然就是汇率风险，汇率风险肯是一个现实摆在我们面前的一个问题，这里面提出来了自己的钱和别人的钱都要出去的这样一个判断，意味着我们的外汇储备将会逐步减少，意味着人们对外汇的需求将会逐步增多，这样一个基本的判断。<br>自己的钱包括两方面，一方面是政府的钱要出去，”一带一路”战略的实施，政府鼓励外汇要用于对外的投资。第二方面是个人的钱，企业和个人在海外资产配置中的比例会逐步上升，海外资产占居民可投资资产的比重，中国相比欧洲、中东和非洲、日本、拉丁美洲、北美的比重都要低，换句话说将来富裕起来的人他的资产配制会有一个国际配置的需求。更何况有一些政策的不完善，还有一部分钱会更多地转移出去，这些都存在。所以从这个角度来说，自己的钱出去，这是一个趋势。<br>另一方面别人的钱也要出去，那就是随着中国投资环境的一些改变，整个世界格局的一些调整，以前到中国来投资的一些外商的钱，正在逐步地转移、逐步地撤退，到那些投资环境更有利、投资回报更高的地方，特别是过去在中国制造的很多转移到了周边的领域，转移到了非洲、转移到了拉丁美洲，这个趋势也在发生。<br>甚至回流发达国家的趋势也在发生，美国再工业化，欧洲强调工业化，等等这些问题已经造成一部分资金回流。再加上对人民币汇率一些预期的改变，一些热钱的流动也有一个变化，从这个角度来说，中国确实面临着对外汇的需求有一个越来越强的趋势，那就意味着外汇的价格会越来越贵。<br>这就是一个结论，需求强之后，一定意味着它的价格会更贵，本币会更便宜。这是一个客观存在的发展趋势，中国从发展层面到了一个资本输出的阶段，在人民币没有完全国际化之前，一定意味着 外汇的需求会更大地增加。只有到了人民币完全国际化了，这就会去有一个改变了，这是从一个大的宏观环境来看。<br>从外部的角度来看，美元处于一个加息的周期，自然就对我们人民币形成一定的贬值压力。他的钱更值钱，我们的钱就有可能贬值。再加上一些国家竞争性的货币贬值，也会诱发或者是改变人民币汇率方面的一些变化。<br>所以对外部有一个诱导或者是推升人民币贬值的压力。内部由于中国经济整体上还处于下行阶段，各种调整的任务还比较重，因此整个经济的基本面应当说还处于相对的不景气的状况。经济不景气一定意味着货币的弱势，只有经济的景气，这个国家的货币才会更强势。<br>人们从北京外部世界看一个国家的货币的时候，一定是跟你经济的基本面挂钩起来的，当看到你目前还处在转型升级的痛苦阶段，你的基本面困难比较多，当然他们看空人民币的这种预期就会强化。另一方面中国的出口还处于下降的局面，因此来自出口企业和相应的主管部门对弱势人民币的这种期待也比较高，期望人民币能贬一点不要升值，来帮助企业出口。<br>所以从这几个方面来看，中国确实还面临着阶段性的人民币贬值的压力。但是从一个发展过程来看，从一个长期趋势来看，中国人民币的汇率也不大可能出现长期的、趋势性的贬值。<br>一方面中国经济目前从增长的角度来看，还处于相对高的水平，中国跟国际比较还有一个增长差，你6%多跟世界3%左右，跟美国1%、跟欧洲、日本百分之零点几的增长相比，还是有一个很大的增长差，因此从增长差看问题，人民币不可能表现得比那些更差的国家更弱势。<br>第二，中国的外汇储备加上商业银行的外汇头寸都还比较充裕，即使从4万亿美元已经降到3.2万亿，但是至少中国的外汇储备还高达3万亿以上，还是世界最大的储备国。商业银行也还有超过1万亿美元的头寸，中国商业银行绝大多数都是国有，因此在一定意义上也能够扮演协助政府发挥调控作用的角色。从中国目前发展阶段所需要的正常外汇储备来说，估计也还有将近1万亿美元左右的余地，可以用来应对短期做空人民币的一些行为，不大可能出现短期就把人民币整垮。<br>从去年的”8.11”以后到今年年初，这两轮央行的”汇率保卫战”来看，还是有手段、有力量，能够有作用。从外汇储备的角度来说，政府还是有能力。更何况政府还可以根据目前中国人民币还不完全是个自由市场的这种汇率，它是个有管理的浮动汇率，因此它可以在政策上、法律上对资本的流动进行必要的管理，对外汇资产的应用进行必要的调节。也就是说它还可以采取一些限制的措施。<br>第三，外部虽然美元处于加息的周期，但是这一轮美元还是一个弱加息的周期，另外美元强势的市场预期已经透支了，或者基本上已经接近天花板，所以美元也不可能有更大的升值空间，更何况欧元还继续弱势，日元也没有太大的强势可能性。所以从这个角度来说，人民币受主要发达国家货币的影响，在未来也不是那么强烈。<br>第四，目前中国的利率水平还高于国际发达国家水平的利率水平，利率的正利差还存在，所以也不至于出现大量的资本套利跑出去。<br>从目前各方面的情况综合来看，政府的政策目标或者是央行的政策目标，很有可能是把它定在不轻易突破7元，作为一个政策的底线来考量。因此那种认为人民币可能跌到8以上，那种可能性很小，几乎不存在。<br>至于长期人民币的汇率怎么看，我想涉及到咱们自己对这个国家经济的前景怎么看，如果对国家经济的前景有信心，你就不要轻易动摇对人民币汇率的信心，反之如果你认为国家的前景不看好，你就可以不对人民币汇率有太强的信心和太强的期待。从眼下中国各方面的情况看，前者的概率明显大于后者，即中国经济好转的前景大于坏的前景，所以大家也用不着对人民币失去信心。作为个人、作为企业，在现阶段适当地调整自己的货币资产，做出一些对冲风险的阶段性的安排那还是非常必要的。</p><h4 id="五、股市问题"><a href="#五、股市问题" class="headerlink" title="五、股市问题"></a>五、股市问题</h4><p>深圳是资本市场比较活跃的一个地方，我想讲的是两点：<br>第一，短期中国的资本市场目前正处于一个振荡的阶段，振荡行情可能构成了短期的资本市场一个主要的行情，换句话说，前期的那种单边市场的阶段已经结束了，那种疯牛的行情已经没有了，”猪已死去”，那种会飞的猪已经没有了，已经死去了。这主要是因为整个资本市场的一些因素如杠杆牛等这些短期的投机性的因素，或者是短期的这种单边的因素越来越弱化了。<br>一方面中国经济跟资本市场的关系不可能长期地脱钩，也就是说基本面不可能长期与资本市场脱钩，对于股票市场要回归基本面他也是一个必然的趋势，短期他肯定受到目前这种经济下行等等这方面的一些因素的影响。<br>第二方面，前期救市之后的一些后遗症始终是短期资本市场需要消化的一个元素，1万多亿救市的资金总有一天是要从资本市场退出，或者有一个调整，这个概率是存在的，只是眼前不是那么迫切，眼下政策还不允许。<br>再就是中国资本市场先天的不足带来的那种企业业绩不好的一些问题，他也是影响到资本市场短期的因素，不可能那些亏损企业的股票能够卖到好的价格，那是不可能长期有这样的趋势，除非疯了。像去年6月份以前那是疯了。<br>还有就是上市公司冻结或者放缓之后积累下来的一些问题总有一天也要解决。现在有六七百家在排队，对短期的资本市场也会产生一些影响。<br>此外，一些改革，注册制、国际板、战略新兴板也好，这些改革虽然暂时没有时间表，但是始终也是对短期资本市场有一个心理影响的因素。<br>所以综合这些方面，再加上货币政策宽松的天花板已经越来越接近，降息的空间越来越小。2016年最多有一次，而且概率在降低，人民币利率很可能就要结束这一轮的降息周期，因此对资本市场肯定也会产生短期的稍微流动性减弱的影响。<br>第二，中国资本市场的长期面还是值得期待的，”牛”还没死去，主要是基于中国资本市场的地位、中国资本市场影响力、中国资本市场作用，在现阶段和未来中国经济的转型升级和发展中的影响力会越来越大，未来中国经济的发展离不开资本市场的逻辑越来越强。因此，政府对于资本市场的态度越来越重视、越来越友好，这个基本面没有改变，这也是从2014年年底开始资本市场逐步结束长达7年的低迷期之后的最基本的一个逻辑。<br>主要是五个方面：<br>第一，要解决企业融资难、融资贵的问题。由过去的主要由信贷驱动转到资本市场驱动，由间接融资为主到逐步提高直接融资比重，这样一个发展政策已经成为国家层面的共识。要通过发展资本市场为企业解决融资难、融资贵的矛盾，减轻企业的财务成本，缓解企业杠杆比较高的一些问题。<br>第二，中国的资产负债表也需要逐步地修复，而修复资产负债表最有效的内容就是资产证券化。而资产证券化需要的载体就是资本市场，美国2008年之后之所以摆脱困难，靠的就是资本市场提供的帮助，修复了银行的资产负债表，修复了家庭的资产负债表，修复了企业的资产负债表。<br>当然政府的资产负债表是不需要修复的，所以它变得更坏，因为政府的资产负债表是由全球买单，所以它用不着去担心，是由美元的国际地位决定的。现在中国资产负债表从政府到企业、到银行也出问题了，所以也需要修复，就要用资本市场来修复，通过资产证券化去解决。<br>第三，转型升级必然意味着存量资产需要重组，增量资产需要重配。重组重配无非是两条路，第一是政府主导，第二是市场主导。而实践已经告诉我们，政府主导是不可能完成转型升级的，而只有市场主导才能够完成转型升级，而市场主导就需要靠资本市场。通过资本市场实现资源的配置更合理、更优化，因此，对已经上市的公司，对大量的传统产业，资产的重组是未来一个重要的内容，对于各种新兴产业包括新三板这些新兴产业，进一步的资本市场化也是一个必然的趋势。所以从这个角度来说，资本市场不可或缺。<br>第四，民众的财富配置也有一个更优化的过程，要逐步地由以实体经济、房地产配置财富，到逐步地提高金融资产的比重。而金融资产的比重过去更多是银行储蓄，各种各样的理财产品，未来要更多地配置到资本市场。通过财富的专业管理，通过财富的市场运作，来保值增值，而资本市场是一个重要的通道。<br>第五，人民币国际化意味着中国资本市场要开放，意味着由一国市场变成多国市场，变成全球市场，因此来自全球的流动性将极大地补充一国的流动性。全球投资中国资本市场，一定意味着中国资本市场会更加地活跃。<br>这就是”牛没有死去”最基本的一个逻辑。只是资本市场毕竟是市场，因此是市场它就必定有风险，而中国又是在很大程度上还没有完全改变政策市的这样一个特点，因此，就又多了一个政策性的风险。所以对市场风险的防范，对政策风险的防范，也还是投资者时刻不能忘记的定律，不要因为”牛还活着”就麻木了，还是要在防范风险下面去观察、去投资资本市场。<br>未来的三条线是要注意的：<br>第一，要更多关注并购重组这条线，去发现重组的机会，去防范重组的风险。<br>第二，新兴产业发展这条线，去发现新材料、新能源，智能制造，生物医疗、环境保护治理等等方面，以及文化、健康这方面的产业，发现新的投资机会。<br>第三，要丰富自己的对冲风险的工具，要从单边的市场，单一的市场、单一的品种如何转为多元化，一级市场、二级市场联动，国际国内联动，现货期货联动，以及商品市场、资本市场、汇率市场、房地产市场各种市场兼顾，这样去增加投资的对冲风险的能力，获得绝对的收益。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>回首</title>
      <link href="/2016/04/28/%E5%9B%9E%E9%A6%96/"/>
      <url>/2016/04/28/%E5%9B%9E%E9%A6%96/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>其实，不知道该写什么题目，本想写无题，又是那么的重名，刚刚看了某人的日记，然后就蹦出来回首这个词。</p><a id="more"></a><p>也许看到题目是个怀旧的文章，也许并且可能吧，主要现在论文不想写，然后给自己找点事做，不能总是刷微博豆瓣，一遍遍的刷新，索性就写点什么。</p><p>至于回首，其实刚刚是看了琪的以前的日志，回首到以前的事情，想想以前还真是那么年少无知到那种程度，以至于那么点的关心都变成她的奢侈，可想当时伤她多深，至于后来的种种，也不好说谁对谁错了。</p><p>从这件事上，可以看出我是个怀旧的人，总喜欢挖掘点有价值的文字来弥补如今空虚的心灵。</p><p>这篇日记也只是天马行空，想到哪就写到哪。</p><p>近期干的一件事就是写论文，做了这么大约一个多月的实验，也着实累了这么长的时间，接下来的工作就是收尾，完成这最后的篇章。以前没写过论文，相对于自己匮乏的词汇，写一篇论文很难。幸亏近期看了很多的文章，所谓熟读唐诗三百首，不会吟诗也会偷。那么，我的第一篇论文只能是偷了，博采众家之长，至少能写一个令自己满意的论文。所以，近期要尽快完成初稿。</p><p>好像这段时间除了这么一件事可以说的，然后就是不断的做实验然后那么三点一线的重复的劳动，期间，收获了孤独和信心。至于其他方面的事，感情亦或自己其他方面的提升也是自己比较关注的。</p><p>感情，哎，到了这么的年纪，总是要起床每天面对的事情。这阴雨连绵的天气，给自己的感情道路也蒙上一层阴雨。有那么一个人，也许该自己主动去追。她不是很漂亮，但是很优秀，有着自内而外散发出的光芒，这也让我不得不承认家庭因素带来的固有的差距，这个差距就是我现在需要弥补的。不知道从哪看到的数据，德国近几十年的阶层并没有发生很大的变化，由此可以看出，如果不主动跳出这固有的阶层僵化，以当今社会的发展更难完成阶层的跳跃，而我可以说是幸运的，幸运的是，抓住了机会的尾巴，至少现在看来还是有可能完成阶层的翻越，也可以说是不幸的，因为在我们前面的那些人比我们更幸运，他们处在变革的大时代下，只要稍微有些资本就可以很快的完成翻越，所以，综合考量来说，我还是觉得幸运的，因为我毕竟是少数中的那么些人，人生是一场马拉松，不必在意这一城一池的得失。坚信自己现在所走的道路，也许后面会变得更好。</p><p>那么后面的可以说顺其自然，当然自己得争取，如果有个好的结果，可以说是感谢上苍，当然需要培养自己的吸引力。</p><p>人一定要有自己的爱好，记得高中的时候，跟着大家爱上了足球，所以成了四小狼之一。后来，大家都去打篮球了，我也跟着去打篮球了，不过至今篮球都没有成为我喜爱的一项运动。足球倒是成了我在繁忙的工作之余可以用来消遣的方式。至于到后来的大学，那时候还是那么幼稚，可以说和普通人一样，逃课，打游戏，因为没有什么钱，所以只能用这种方式来消遣无聊的大学时光，也许有那段时间喜欢上了吉他，但是由于觉得吉他很贵，又不得不放弃了这么一项爱好，以至于现在我终于又拿起吉他，可以说不是那么的晚，学习从来没有晚的时候，尤其是自己的兴趣爱好。游戏打了整个大学，也没见自己的技术有很大的提升，可以说大学真是混过来的，要么有那么点可以谈资的话就是交了两个女朋友，一个是高中同学，现在已嫁作他人妇，一个是大学同学，现在我也不知道近况。可以说家庭情况影响了我整个大学，并不是我不知道感恩，而是现在回首看看，细细比较之后发现，这些都是点滴之间的影响。我很感谢我的父母，是他们无私的奉献才早就如今的我，而现在的我由于学会了很多东西，渐渐发现了很多的问题，这也并不影响我以成年人的视角来审视这么些年的我。至于第二个女朋友，则是幼稚的综合体，最后到病入膏肓了为时已晚。就这样进入研究生阶段，分手也是在研究生阶段发生的，然后就是感情的空窗期直到现在，可以说到现在我都没有能力去爱别人。研究生阶段也有人跟我表白过，但是自己拒绝了，总以为自己能遇到更好的，而放弃当前可以得到的。也是有自己的固执，希望给自己和自己的孩子以更好的，而不是凑合。爱情是美好的东西，而不是将就。在研究生的最后一年，我开始学起了尤克里里，这么的小乐器终于弥补了我一直以来的音乐梦，可以说现在一般的曲子都能拿来谈，给自己的无聊生活添加那么点乐趣。吉他也是在博士期间开始的，总是自认为吉他的音色更加好听，所以开始了，但是由于学习的时间不是那么多，所以到现在吉他还是半吊子的水平，一首完整的歌都弹不起来，每天没有时间练习也就没有收获。博士开始，按揭买了台相机，这算培养自己的第二爱好，可是一直没有机会进行学习，相机也一直尘封在那里，希望能找到一个女孩，每周能带着她去采风之类的，也不至于款差不多都还了，到现在相机还只是会那么点的知识。研究生期间喜欢上了羽毛球，于是一有时间就去打，只是喜欢酣畅淋漓之后的感觉，只是现在随着进入博士期间，圈子也是越来越窄，所以打球的人也越来越少，好长时间荒废了，于是开始了跑步，记得以前连一千米都跑不下来，现在每次至少五千米的跑，想想也真是自己长大了，加上近期跑步这项运动很火啊，于是就有了现在的自己，还指望着跑步能减肥。</p><p>其实哪里有那么多的没时间，只是自己懒罢了。所以跑步这项运动还是要继续下去，没事少看点无聊的电视剧，多做些有益的运动，多走出去看看。</p><p>今天下雨，其实很喜欢在下雨天出去走走，呼吸新鲜空气，亦或者淋雨，尽管雨很脏，但是还是想这么做。</p><p>今天就写到这吧，后面有什么再写。</p><p>好吧，本来不想写的，但是后面的师姐又在焦躁的抱怨，所以顺便就接着写。</p><p>对于自己的情绪控制，我通常都是自己想，而不是怨天尤人，现在已经这样了，凡事要看的开，要学会控制自己的情绪，这我发现在实验室弥漫着这种情绪，大家都喜欢抱怨，抱怨这抱怨那，而不是去想想如何能改变这种情况，所以最终也只能成为碌碌无为的人，所以自己得到的教训就是不抱怨，有什么事自己解决，而不是向别人传递负能量。</p><p>好了，以后再写如何跟别人打交道吧。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>杭州</title>
      <link href="/2016/03/29/%E6%9D%AD%E5%B7%9E/"/>
      <url>/2016/03/29/%E6%9D%AD%E5%B7%9E/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>十月中旬，避过了人头攒动的国庆假期，收拾繁杂的心情，腾出三两天背上行囊，去这个“水光潋滟晴方好，山色空蒙雨亦奇”的杭州。</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/DSC_0628.png!gumini" alt=""></p><a id="more"></a><p>古语有言“上有天堂，下有苏杭”。苏州早在几年之前便已游历，而与其齐名的杭州至今还未曾探寻，只是不断的与之擦身而过。趁着友人相约，便把这多次的擦身变成一次有预谋的邂逅。</p><p>脱离了学生的身份，在出行时间的选择上也不再是那么游刃有余，周末也就成了唯一的选择。周五晚上，背上早已整装好的背包，就此踏上这场邂逅之旅。庆幸现如今交通的发达，从南京到杭州的高铁只需要一个半小时的时间，抛却上班时疲惫，在列车上尽情遐想未来几日会有怎样的境遇。</p><p>随着扬声器中的声音，知晓已到杭州东站，跟其它火车站没有很大的区别，同样是人多。收起纷乱的思绪，寻找地铁路线。在此不得不吐槽一下，作为现代化的杭州，地铁还没有南京方便。避开找寻酒店的种种，终于到达友人订的暂留之地。吴山之下，阳台对着远山。别有一番风味。夜幕之下，山上零星的灯光，犹如繁星点点。毕竟在山脚下，空气相对城市还要好很多了。随便收拾下，放松身心，为随之而来的两天准备充足的体能。</p><p>翌日清晨，悄悄爬起，站在阳台上，呼吸新鲜的山林之气，整个人随着那一股清凉而感到振奋。叫起友人，开始杭州之旅。</p><p>但凡游玩，总和美景美食相关。来之前也做了相关的攻略，由于时间有限，只能通过别人的建议来规划这两天的行程。吃完早餐之后，我们便向着西湖进发。如果说来杭州只能看一个地方，那当然非西湖莫属，昨夜的早早入睡，就是为了养足精力把一天时间都花在西湖之上。与友人商量之后，我们决定徒步环游西湖，用脚去感受西湖秋日的美。</p><p>从柳浪闻莺出发开始这蓄谋已久的西湖之旅。如果抛却熙攘的人流，那么西湖给我的感觉就是淡雅宁静，一切植物都相得益彰。这里也有枫叶，与南京的栖霞红枫一样，都能给人带来视觉的享受。辗转到钱王祠，有个轮渡口可以去西湖中间的三潭映月，就是一元人民币上的景点。三座瓶形小石塔鼎足而立，造型别致而优美。三个石塔相隔很远，并不如人民币上所示，要想把三个都照仪器，实在是很难办到。西湖中间还有个小岛，小岛里还有个小湖，三潭映月也叫小瀛洲。其它就没什么好看的了。下了船左走就到了西泠印社，它以研究印学保存金石兼及书画为宗旨，被称为天下第一名社。</p><p>午饭之后，随着西湖十景剩下的景观继续步行。由于是周末，到此玩赏的人也特别多。本来以为能避过十一，可大概是她的名气太过响亮，以至于长假之后的周末都不能让她有丝毫的歇息，尤其在白堤之上，更是人声鼎沸。这样的西湖也就少了些把玩的意味。</p><p>在西湖很容易能找到把自己镶入照片的美景，即使是人头攒动，也总能找到合适的角度来给自己到此一游划上痕迹。渐渐的步行之后，也就少了游玩的兴致，更多的是想坐在湖边的长椅上，看着湖光潋滟，远山婆娑。为自己寻找心灵上的宁静，寻思着生命的意思。</p><p>渐入傍晚，雷锋夕照，黄昏中的西湖别有一番韵味，如小家碧玉般静静的坐在那里，沉思着这难得的宁静。人群开始慢慢散去，给这忙碌一天的西子以宁静。</p><p>带着游玩西湖之后复杂的心情而归，没有了那激动的心情，取而待之的是平静。在游历之后，惊喜反倒降了不少，也许这样的西湖适合在平静的工作日独自一人，带着相机，慢慢品味。多了繁杂的人群，也就少了那么宁静，这也许就是心境所致。</p><p>至于晚上的南宋御街以及清河坊，并没有给我太多的惊喜，只是如南京夫子庙般，商业化过重，本来就没有了古时的味道。</p><p>杭州之旅，一为景，二为老友，分别几年，虽然现在通信技术如此发达，但是并没有拉近彼此间的距离，分别也即不相见。彼此在不同的城过着各自的生活，老友带着我们参观了阿里巴巴，感叹着中国互联网公司之巅的魅力。园区设计别致，对于我这样的过客来说，在这里工作是一种享受。也从侧面来说，有着这样充满活力的人，这样的公司如何不能继续前进。</p><p>老友相见必然三杯两盏淡酒，彼此天南海北胡侃一通，不变的是那颗热忱的心。工作之后，谈论的更多的是工作家人孩子，彼此的身上少了些年少轻狂，多了份成熟稳重，感谢岁月的雕琢，把我们变得更好。</p><p>分别之后，便匆匆回归。杭州之旅，对我来说，景没有惊喜，人依然如旧。也许这样的杭州还需要更多的发展。也许也是因为我在此只是匆匆停留，并没有领略到她更深的美。也由此带着些许遗憾，希望下次我能遇见更美的杭州。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>matlab坐标系疑云</title>
      <link href="/2015/12/20/matlab%E5%9D%90%E6%A0%87%E7%B3%BB%E7%96%91%E4%BA%91/"/>
      <url>/2015/12/20/matlab%E5%9D%90%E6%A0%87%E7%B3%BB%E7%96%91%E4%BA%91/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>编程中总会被matlab的奇怪坐标系坐标搞晕，在此笔记。</p></blockquote><a id="more"></a><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fmn5rn6v4xj307y07pwea.jpg" alt=""></p><p>如上图所示，即是matlab图像格式，假设图像用<code>I</code>表示，那么在<code>x</code>轴100和<code>y</code>轴50处，读取图像的像素为<code>I(50,100)</code>，此即为matlab的坐标系格式。一般在figure中点击某点显示像素坐标，显示的是<code>x</code>轴和<code>y</code>轴的坐标，但是编写代码的时候就要反过来，注意注意。</p><p>另外，matlab的坐标系是从<code>1</code>开始的，而不是从<code>0</code>开始。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2015/01/01/hello-world/"/>
      <url>/2015/01/01/hello-world/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>黄山</title>
      <link href="/2015/01/01/%E9%BB%84%E5%B1%B1/"/>
      <url>/2015/01/01/%E9%BB%84%E5%B1%B1/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>2015年元旦前夕，研三上，看似很忙的时间在元旦假期又都抽出了时间。短暂的商量敲定黄山的旅程。本来定好泰山，奈何车票难订，鉴于黄山大家都没去过，又都敲定了。由于飞哥要上班，所以我们选择了31号晚上的火车，大约夜里到达。没买到直达的硬座K221，富有经验的飞哥选了K224(其实跟K221是一班车)从泰州的有硬座的票，南京上车，也就贵了15块钱，6个小时的车程，还是坐着比较好。这是我第二次做快车，以前做过一次，挤的人仰马翻，还是那个人带着的，只是物是人非罢了。这次还好，车上换了几个座位准备打牌打到黄山，奈何中间有个哥们来了，然后众人理不清那错综复杂的换座关系，打牌在19.30作罢了。剩余的漫长时间只能小说度过了。《藏地密码》这是选择在火车上看的小说，可能有点趣味。每次坐上火车，车上都有人谈论国家大事，用飞哥的话说：他们都好像理解的很深的样子。其实国家大事我也不甚明了，只是局势使然，每一方都只是时间的棋子。其实近来我越来越觉得历史其实从来都是一样的，只是所用的工具不一样了。也许现在的理解肤浅了。翻着书页，伴随人来人往，嘈嘈杂杂，浸入其中，舍弃宅时散漫，体会生活。</p><a id="more"></a><p>31号晚上将近12点到达黄山火车站，之前我们已经订好了房间，所谓兵马未动，粮草先行。可是后面山上的却没有订，也是节假日没有，这也为我们后来的暴走之旅埋下了伏笔。</p><p>云天徽尚离火车站很近，出了火车站就看到了，也就300米的样子。住宿环境只能说一般吧，没有热水，没有暖气，也就价格便宜，每个人40多块钱，夜里12点到黄山，有个能睡的地方就不错了。莫强求，一切随心就行。众人匆匆吃点东西，就赶紧为第二天的暴走养精蓄锐。</p><p>一夜天明，也没睡几个钟头，其实在陌生的地方一直睡得不是那么好。也因为早早要赶车，日出是没戏了，如果住黄山上面或者汤口镇，倒还有可能。吃了早餐，错过一趟车，然后赶上6.30的车大约一个小时到汤口镇，随即买票坐上山的车。盘山公路蛇形蜿蜒，很佩服司机的技术，比我这二把刀高下立判。大抵也是庖丁解牛，熟能生巧了。旅游大巴一直把我们送到云谷索道售票处，我们四个人，买了门票加索道票，可惜研究生证用不了了，215有点小贵吧。不过经过之后一天的游览，还是觉得值了，用那个女孩的话，如果不是亲眼看见，真以为这是PS过的。认识女孩的过程后文介绍吧。她叫彭彭。</p><p>云谷索道，六个人一厢。</p><p>我们四个加上一哥们，忘了那哥们是哪个学校的了，只记得他是浙江来的，说他们宿舍四个元旦各奔东西了，然后他就一个人来黄山了。也佩服这哥们，想我上次独自旅行，一个人去了西安，然后就自己欣赏美景，虽然有美景，但是一个人的旅途，有时候还是对耐力的一种考验。你也可以途中认识不同的人，分享彼此的故事，这其实有时候回忆起来很美好，因为认识不同的人，也知道了解了不同的人生，每一种其实都值得称赞。好吧，扯的远了。索道向外看，就已经被美景给震撼了，这还只是刚刚开始，我们的奇妙之旅才刚刚开始。</p><p>可能有些地方记不清了，因为这样，所以我才在火车上用手机记录下来，怕忘的更多。其实，真正的算是心路旅程吧。</p><p>写这篇文章已经是零点了，宿舍哥们都已经睡了，可是我还想记完才睡。夹杂只言片语的车厢很有味道。</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/DSC_1698.jpeg!gumini" alt=""></p><p>出了索道，下面就是真正我们的旅途了，今天天气格外的好，来之前做了点功课说山上冷，其实也就风大，运动起来也就跟平时一样。光线照射，印象中好久没看到这样的太阳，记忆中还是小时候在老家见过这样的太阳，现在常年在外，城市中些许阳光的施舍已经很了不起了。旅程就是伴随着拍照留恋和欢声笑语。</p><p>我们走的是最经典的一日游的路线，贴图。没有另辟蹊径，这毕竟不是紫金山，那么点大，总能走下来。略去某些拍照的细节暂且不说，等会去对着照片再说吧。</p><p>在某个崖边，要飞哥给自己拍了张手捧相机的照片，飞哥拍的还真不错，然后我就说，我的微信头像终于又可以换了，然后我就发了朋友圈，不过飞哥比我发的更快，因为我拍他没有他拍的我好看，所以要比我先发，之后我刷新朋友圈发现他发的是我，我赞了飞哥的技术，问飞哥别人怎么回复的，飞哥说，好多女的都说应该找飞哥这样的男朋友啊，后悔没下手。我也连忙赞同了，毕竟我们这样的拍照小白，出张还过的去的照片不容易呀，请允许我吐槽渣渣的技术，回去好好练吧。彭彭的技术很好，在我看来她就是专业的，可以没让她帮我们多拍几张，遗憾。</p><p>再后来就是猴子观海啊，可惜天气实在是太好了，没有了云海徒有猴子在审视这苍茫大地。路线地名实在记不住了，想到什么记什么吧。</p><p>每一处景点都围着很多人，找一个合适的拍照地点相当不容易。</p><p>到光明顶，差不多十点半，小吃了会，亮哥一个人跑别处去了。</p><p>下面好像就到彭彭的故事了，记不清是否在光明顶了。<br>记得是一块大石，人很多，由于我要给金金拍照，他一直在寻找合适的地点，然后就找到一个他认为满意的地方，估计是故意的，也许早就想好了搭讪，哈哈，可是又不敢上去。从我的角度，前面正好挡着两个女孩，其中一个就是彭彭，还有一个是她闺密吧（好吧，我一直没问彭彭那个女孩的名字），然后她貌似看见我们要拍照，她们好像也正在拍照，彭彭正准备离开，我心血来潮，说了句，就一起拍吧，有两个美女的衬托，给纯爷们的旅途带来些许色彩吧。彭彭好像当时也正犹豫走不走开，只留给我侧脸，然后我就拍了两三张，再之后，金金给我拍，我也就换到那个位置，彭彭走到旁边，我又来了句，可以一起拍张照吗？彭彭估计当时也没多想就同意了，后来看照片，我们拍的还不错，拍完之后没想到她们也邀请我留一张，不记得当时是她邀请的还是她闺密，我们于是在她那边也留了合影，后来又大胆的要了微信，就这么加了对方好友。再之后我们就先走了，她们还在那边停留。</p><p>宿舍哥们在一起总会起哄的，说什么为什么不邀请同游之类的。现在跟她有点熟之后，还真有点后悔了，哈哈。</p><p>故事还在继续。</p><p>我们又陆续去了飞来石，在那也留下了影像和记忆，再后来的诸多景点，听一个大爷说，西海大峡谷虽然封了，但徒步还是可以的，本来我们真想去了，考虑到只有一天的时间，不得不忍痛了，继续沿着经典的路线行进，期间有关彭彭的起哄仍不时响起，后来金金说旁边那个女孩不错啊，很像一个人，想认识下，让我要微信号，我在他的劝说下和彭彭的第二次交流，如果没有这个插曲，我想当时也只是加了个微信号吧。然后在相簿中留下她的照片，仅此而已。本以为要不到，没想到墨菲定律又发生了。我们继续行进着。</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/20076864687.jpeg!gumini" alt=""></p><p>再后来我们到了一线天，天都峰，莲花峰，沿途景色美不胜收，飞哥一直再说简直不能太美，真的很美，这也大概就是黄山回来不看岳的由来吧。有些地方也有华山的险，巍峨不失凌厉，俊秀不失千险。此时的我们已经很累，可是还是不断攀登，越难登越要登，百步云梯，记忆深刻，飞哥还特地数了下，我还说百步在文言文中是虚词，其实不止百步，后来证明我对了，哈哈，得意了下。到此我们始终没有遇到彭彭她们。</p><p>后来听说她们已经在玉屏索道了，等我们到她们又在迎客松了。</p><p>说到迎客松，就想到送客松，飞哥怎么都找不到拍摄的合适角度，后来他攀上岩石大叫说，对的，就是这里，后来他给我们看照片，的确是那个角度。</p><p>到迎客松那里，我们就跑到设在那做生意的地点，自己拍了几张照片，没想到他们还通情达理，也没赶我们走，我们就在那拍了好多。</p><p>迎客松之后差不多就是下山了，中间得知彭彭她们还在迎客松，好吧，错过了。</p><p>后来我们下山途中突然看见了她们，彭彭后来说如果我不叫她，她还真没认出我来，她是脸盲。叫上她也没说几句又各自下山了，途中我们又相互超越了几次，最后在看到她一个人冲到前面，然后在前面休息中我们下山回去找旅馆了。还没有住的地方。</p><p>后来在车上就和她聊了起来，也算是认识了。告诉她我们还没有住的地方，还开玩笑睡大桥，唱歌捧场聊了很久。</p><p>暂且不说彭彭了，继续我的旅程，我们坐车到了老街，找了家旅馆，也就一般吧，相对便宜然后有了热水，也就可以舒服的洗个澡，在老街吃了徽菜，毛豆腐啊，还有臭桂鱼啊，其实也没觉得怎么样，还不如我妈烧的菜。吃完稍微逛了老街，感觉也没啥可逛的，再加上累了，就回旅馆歇着了，看着电视，抱着手机聊天，十一点差不多结束和彭彭的聊天，她是个标准的大学生，睡觉十一点为界。</p><p>第二天，在众人的起哄中，我们去了亮哥同学（女的）在的齐云山，齐云山是四大道教名山之一，早上我们坐了旅游车到景点下了，由于有亮哥同学的帮助，我们很顺利就上山了，有人就是好，免票，免索道费，其实齐云山也没什么可以看的，现在我是这么认为的，它更多的是宣扬道教文化之地吧，而且山上人家众多，很多建筑都在修葺，也就多了现代破土动工的景象，少了历史沉淀和自然之每，山比紫金山高一百多米，由于前面我们已经爬了黄山，正真到一半的时候我们也开始累了，毕竟连续爬山还是对体力很有要求的，经常锻炼如我们也会觉得累。齐云山的后山风景倒是不错，脱离了前山道教些许残破的遗迹，自然总会给你以惊喜，这也是这地的山和水。后山层岩叠翠，在神秘长廊驻足远望，山天相交，些许点缀着农家小院，一副世外桃源的景象。景致如此，不像我们说的，自己看是如此不堪，而到照片里就分外艳丽。而到了黄山这里，我们的照相技术完全不能超越实地的美景，也能算是一种遗憾吧。从后山然后绕道潜山，走了方腊洞，五老像。此时的上山下山是一种受罪，独和彭彭的些许聊天还能带来一丝快乐。经历了这些景点，我们也该下山了，其实，快三点了，本来还想着和彭彭的宏村相遇算是彻底泡汤了，不得不说是一种遗憾。下山之后，亮哥的同学又请我们吃了一顿，臭鳜鱼，还有香肠，笋，都是特产，这一顿吃的有点不好意思了。忘了提到，还有一个女孩（原谅我没问别人的名字，一路上我只问了彭彭的名字，暂且称小A吧）跟我们一起的，很善言语，也看人很准，用边荒传说里谢安的观人术来赞美也不为过吧。这可能就是在社会中磨练出来的一种技能。至少我觉得她看我看的很准，这中间还有一段小的插曲，一个追她的男的（暂且称他为男朋友吧，估计还没有追到手）为我们作导游，然后小A跟我在后面聊天，她男朋友估计看不下去了，一把把小A拉倒了前面，好吧，我只是个游客，不是来跟你争小A的。后来她男朋友中途就下山了，小A也是个活泼开朗的女孩子，她的很多话都很中肯，有时候觉得社会上的人和学校中的是不一样的，我的思想也越来越接近社会中人的思想，总觉得学校和社会中间隔了点什么，说不清楚，即使我马上还要读一个博士。齐云山之旅到此不表了吧。</p><p>说回彭彭，真是个活泼率真的女孩子，聊起天来也很开心，我俩的聊天很逗，用她的话说来，我们聊了很多自己，分享着，高兴着。能在旅途中遇到如此女孩，也不枉此行，景美人更美。彭彭的拍照技术相当好，我是膜拜的，简直不用修饰。宏村景致如山水画，静物人影比写真，一切都很自然，很美。她是专业的。</p><p>有关彭彭的故事先说到这，以后会补上一个彭彭作为对她的纪念，很有意思的女孩。有点困了，先睡了。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>癸巳十月三十</title>
      <link href="/2013/10/30/%E7%99%B8%E5%B7%B3%E5%8D%81%E6%9C%88%E4%B8%89%E5%8D%81/"/>
      <url>/2013/10/30/%E7%99%B8%E5%B7%B3%E5%8D%81%E6%9C%88%E4%B8%89%E5%8D%81/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>日始霜露重，</p><p>晓寒雾喧天。</p><p>由来出征早，</p><p>笑对梦中人。</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>癸巳十月十八于上班途中</title>
      <link href="/2013/10/18/%E7%99%B8%E5%B7%B3%E5%8D%81%E6%9C%88%E5%8D%81%E5%85%AB%E4%BA%8E%E4%B8%8A%E7%8F%AD%E9%80%94%E4%B8%AD/"/>
      <url>/2013/10/18/%E7%99%B8%E5%B7%B3%E5%8D%81%E6%9C%88%E5%8D%81%E5%85%AB%E4%BA%8E%E4%B8%8A%E7%8F%AD%E9%80%94%E4%B8%AD/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>秋深抬眼对望窗，却惊天际已泛黄。</p><p>无奈匆匆浮桥去，切肤片片晨风凉。</p><p>与君信言诗一首，叹笑学堂搜肚肠。</p><p>求得子安灵附体，遥想终曲满庭芳。</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>贺友人入职一周年记</title>
      <link href="/2013/04/28/%E8%B4%BA%E5%8F%8B%E4%BA%BA%E5%85%A5%E8%81%8C%E4%B8%80%E5%91%A8%E5%B9%B4%E8%AE%B0/"/>
      <url>/2013/04/28/%E8%B4%BA%E5%8F%8B%E4%BA%BA%E5%85%A5%E8%81%8C%E4%B8%80%E5%91%A8%E5%B9%B4%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>癸巳夏正浓，蝉嘒喋不休。</p><p>徐行微月起，不见皓长空。</p><p>谁云万里不惜君，恰似旧年，音笑犹身边。</p><p>也学词人作，摇首出古今。</p><p>一岁初峥嵘，风雨但任啾。</p><p>道南国何妨故土，正好长驱，俯仰点东风。</p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
