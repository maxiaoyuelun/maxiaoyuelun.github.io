<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hexo主题prince</title>
      <link href="/2018/04/16/hexo%E4%B8%BB%E9%A2%98prince/"/>
      <url>/2018/04/16/hexo%E4%B8%BB%E9%A2%98prince/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>推荐一个hexo主题</p><p>链接在此：<a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank" rel="noopener">hexo-theme-prince</a></p><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hexo文章推荐</title>
      <link href="/2018/04/16/hexo%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/04/16/hexo%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>hexo跨博客文章推荐插件</p><p>链接在此：<a href="https://github.com/huiwang/hexo-recommended-posts" target="_blank" rel="noopener">hexo-recommended-posts</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next豆瓣插件</title>
      <link href="/2018/04/16/next%E8%B1%86%E7%93%A3%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/04/16/next%E8%B1%86%E7%93%A3%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>推荐一个使用插件将豆瓣电影、读书和游戏自动部署到自己的github博客上。</p><p>链接在此：<a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">hexo-douban</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows安装pytorch</title>
      <link href="/2018/04/05/windows%E5%AE%89%E8%A3%85pytorch/"/>
      <url>/2018/04/05/windows%E5%AE%89%E8%A3%85pytorch/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>江湖传言，tensorflow适合工业，pytorch适合科研，所以，来一波呗</p><a id="more"></a><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://blog.csdn.net/xiangxianghehe/article/details/78736482" target="_blank" rel="noopener">Windows下安装PyTorch0.3.0</a></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Love Like Magic</title>
      <link href="/2018/03/27/Love-Like-Magic/"/>
      <url>/2018/03/27/Love-Like-Magic/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>翻到这么首歌，还不错！！！</p></blockquote><a id="more"></a><!--<iframe width="816" height="623" src="https://static.hdslb.com/miniloader.swf?aid=2956284&p=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>-->]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 张国荣 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>朝鲜战争基本常识问答</title>
      <link href="/2018/03/26/%E6%9C%9D%E9%B2%9C%E6%88%98%E4%BA%89%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94/"/>
      <url>/2018/03/26/%E6%9C%9D%E9%B2%9C%E6%88%98%E4%BA%89%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h4 id="一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？"><a href="#一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？" class="headerlink" title="一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？"></a>一、三八线是条什么线？它是“国际公认”的朝鲜半岛南北政权的政治分治线吗？</h4><p>答：非也！三八线是1945年8月由美国提出，以朝鲜国土北纬三十八度线作为美、苏两国对日军事行动和受降范围的临时分界线，三八线以北为苏军接受日军投降区，以南为美军受降区。三八线是一条受降临时分界线，仅此而已。说这条线是“国际公认”的朝鲜南北的政治分治线，没有任何国际法依据，而且不为朝鲜半岛南北双方政权所承认。</p><p>换言之，三八线具有约束苏美军队的意义，却没有约束朝鲜半岛南北双方的意义。中国领导人决策出兵参战的前提是“美国军队越过三八线”，而不是“韩国军队越过三八线”，这是原因之一。而美国军队率先越过三八线，是打破这个约束的始作俑者。</p><a id="more"></a><h4 id="二、朝鲜战争是北方侵略了南方吗？"><a href="#二、朝鲜战争是北方侵略了南方吗？" class="headerlink" title="二、朝鲜战争是北方侵略了南方吗？"></a>二、朝鲜战争是北方侵略了南方吗？</h4><p>答：朝鲜战争是一场以民族统一为目的的内战，没有“侵略”不“侵略”之分。正如中国国共内战既不能说国民党侵略了共产党，也不能说共产党侵略了国民党，美国内战既不能说南方侵略了北方，也不能说北方侵略了南方一样。美国军队直接介入朝鲜内战，才是名符其实的“侵略”行为。</p><h4 id="三、联合国是否有权利干预朝鲜内战？"><a href="#三、联合国是否有权利干预朝鲜内战？" class="headerlink" title="三、联合国是否有权利干预朝鲜内战？"></a>三、联合国是否有权利干预朝鲜内战？</h4><p>答：没有权利。联合国是一个国际组织，不是“世界政府”。与一个国家的政府有着本质的区别，它没有干预一个国家内部事务权利和依据。实际上，《联合国宪章》就明确规定：“不得干涉本质上属于任何国家内部管辖之事件”。联合国安理会关于武装干预朝鲜的决议是在安理会常任理事国有缺席，而美国军队已经先斩后奏率先介入的情况下作出的，开了一个毫无道理的先例，是一个非法决议。所以从朝鲜战争以后，再也没有“联合国军”名义的军事行动，就是这种方式已为历史进程所否定的反证。</p><p>尤其需要特别说明的是，朝鲜南北方政权都没有加入联合国，都不是联合国成员国，联合国出兵干预，不伦不类，无根无基，没有任何法理依据，本身就是对《联合国宪章》的粗暴践踏。</p><h4 id="四、“联合国军”是一支维持和平部队吗？"><a href="#四、“联合国军”是一支维持和平部队吗？" class="headerlink" title="四、“联合国军”是一支维持和平部队吗？"></a>四、“联合国军”是一支维持和平部队吗？</h4><p>答：不是！“联合国维持和平行动”的概念产生于朝鲜战争之后，而且有其特定涵义和规范。联合国成立之时，就设有军事观察员，并逐步形成了维和部队，在1956年建立第一支联合国维和部队时，联合国秘书长哈马舍尔德曾经提出了著名的维和三原则：</p><p>第一，维和行动不得妨碍有关当事国之权利、要求和立场，需保持中立，不得偏袒冲突中的任何一方；</p><p>第二，维和行动必须征得有关各方的一致同意才能实施；</p><p>第三，维和部队只携带轻武器，只有自卫时方可使用武力。</p><p>人们把这三项原则概括为中立的原则、同意的原则和自卫的原则，并称之为哈马舍尔德三原则。哈马合尔德三原则是联合国传统维和行动的基本准则。80年代未期以前的维和行动，都是以哈马舍尔德三原则为基本依据的。哈马吉尔德三原则对联合国近四十年的维和行动具有重要的指导意义。秘书长啥马舍尔德之所以就联合国维和行动提出这三项基本原则，主要是因为联合国建立时制定的《联合国宪章》没有关于维和行动的规定。以哈马舍尔德原则为基础，传统维和行动大体遵循以下一些基本原则：</p><p>1.维和行动由联合国安理会授权和组织．特殊情况下由联合国大会组织，具体由秘书长控制和指挥。</p><p>2.维和行动必须征得冲突各方政府以及直接有关的各方的同意。具体讲，维和部队的规模、进驻的起始和结束时间、进驻的地域等部必须征得有关各方的一致同意特别是进驻国的同意。</p><p>3.维和部队的军事人员由会员国自愿提供。军事观察员不携带武器、维和部队携带轻型防御性武器。</p><p>4.维和部队除自卫外，不得使用武力。</p><p>5.严守中立。不能支待一方反对另一方。</p><p>6.不得干涉驻在国内部事务，不能介入内部冲突。</p><p>“联合国军”的决策和行动不符合其中任何一条。</p><h4 id="五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？"><a href="#五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？" class="headerlink" title="五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？"></a>五、美国政府只有解决朝鲜问题而没有染指中国的意图吗？</h4><p>答：中国有句老话：察其言，观其行。美国军队事实上已经侵犯了中国领土（台湾），介入了中国内战（出兵台湾即介入中国内战），而且其地面武装力量已经越过三八线直趋中国国门，“联合国军”总司令已经提出：“无论如何，如果我们不去利用鸭绿江的自然防御功能，那么这种西部低洼，东中部崎岖的地形是不适于我们的防御体系的。这条江是整个朝鲜绝无仅有的天然屏障，但如果仅仅依赖于此作为唯一的天然防线，则无论是军事还是政治的防御能力都不足以维护韩国的领土完整。……只是占领鸭绿江以南地区旋即停止推进，我们根本就不可能找到一个可有效控制所有通向北朝鲜的路径的位置”。</p><p>而同时期，美国空军的炸弹已经落到中国的城市和乡村。这已经不是意图而是实实在在的事实，这在任何一个国家包括美利坚合众国自己，都绝不会视为一种友好表示而只能认为是不怀好意的侵略行动。</p><p>美国前国务卿亨利·基辛格先生也曾在其著作《大外交》中指出：“毛泽东有理由认为，如果他不在朝鲜阻挡美国，他或许会在中国领土上与美军交战。最起码，他没有理由去作出相反的结论。”</p><p>1989年5月5日，美国军事历史学家约翰·托兰（著有《漫长的战斗》）在中国人民解放军军事科学院与他的中国同行们交流时说：“中国出兵朝鲜是出于国家利益的考虑，是不得已的。如果苏联打到墨西哥，那么美国在5分钟之内就会决定出兵。”</p><h4 id="六、中国军队出兵援朝的决策真正原因是什么？"><a href="#六、中国军队出兵援朝的决策真正原因是什么？" class="headerlink" title="六、中国军队出兵援朝的决策真正原因是什么？"></a>六、中国军队出兵援朝的决策真正原因是什么？</h4><p>答：保家卫国！中国人民志愿军入朝参战，是在中国领土主权受到侵犯，“联合国军”打到鸭绿江边，战火已烧到中国边境城市的情况下发生的，是侵略凶焰已经直接威胁到我们的国家安全环境的情况下发生的，是在中国政府再三警告言之有预有理有节先礼后兵而侵略者仍然置若罔闻肆无忌惮得寸进尺一意孤行的情况下发生的。严肃一点的美国学者或军人──既或是与中国军队交过手的美国军人，都不否认中国军队出兵援朝的合理性。</p><p>其次，对盟友和战友危难之际履行一个社会主义大国的国际主义义务也是一个重要原因，弱者对付强者最有效的武器就是自身的团结与互助，一个负责任的社会主义大国首先应该对自己的战友和盟友负责！受人涓埃之恩，必当涌泉相报，这是中华民族代代传承的道义火矩和优良传统，中朝两国人民在过去反对帝国主义侵略的共同斗争曾经相濡以沫相互支援共挽民族危亡，中国人民革命斗争的旗帜也浸染着朝鲜志士的鲜血，共同的境遇共同的命运使中朝两大民族同病相怜，共同的利益共同的愿望使中朝两国人民生死相依。可以说，没有任何两个毗邻民族能够比中朝两大民族更能深刻体验和感受唇亡齿寒之迫，户破堂危之急。勿需对历史作太久远的回顾，灭亡了朝鲜的日本得寸进尺染指中国最终迫使中华民族发出“最后的吼声”，对中国人民就足具史鉴来者之功效。</p><h4 id="七、中国军队出兵援朝延缓了解放台湾吗？"><a href="#七、中国军队出兵援朝延缓了解放台湾吗？" class="headerlink" title="七、中国军队出兵援朝延缓了解放台湾吗？"></a>七、中国军队出兵援朝延缓了解放台湾吗？</h4><p>答：这种说法颠倒了因果关系，中国军队出兵援朝是在美国军队进占台湾之后，阻碍中国人民完成祖国统一大业的是美国军队。这个因果关系应该不难分清。</p><h4 id="八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？"><a href="#八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？" class="headerlink" title="八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？"></a>八、朝鲜民主主义人民共和国经济状况不佳，战后发展远不如大韩民国，是否证实中国人民志愿军入朝参战是错误的？</h4><p>答：没有道理。打个比方，你向银行货款购房，银行是否因此就要对你终生的行为和经济状况负责？你购了房，银行得了利，你后来又把房卖了，银行是否必须为你的卖房行为负责？或者再打个比方，你见义勇为救了一个人，是否意味着你必须对此人此后所有行为负责？更何况，朝鲜民主主义人民共和国在安全环境受到了严重威胁，生存环境受到了严重制约的情况下，取得举世瞩目的建设成就，朝鲜人民既或在经济上遭受了严重困难的日子里仍然享受着令世人羡慕的各种基本福利制度，劳动群众的基本生存权利得到了相当切实有效的保障，这也是不容忽视的事实！</p><h4 id="九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？"><a href="#九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？" class="headerlink" title="九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？"></a>九、有人说：“中国军队出兵援朝有合理性，但打过三八线就是侵略。”这种说法有无道理？</h4><p>答：没有道理。</p><p>第一，来而不往非礼也，寇能往，我亦能往！</p><p>第二，除恶务尽，第二次世界大战中，苏美英军队直捣柏林为中国军队作出了极好的榜样。至于没有达到这个目的，那是中国军队本事不够，家伙也不行，与该不该打过去没有关系！</p><p> 第三，三八线的本质涵义是只有约束美苏的意义，而无约束其它人的意义。</p><h4 id="十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。"><a href="#十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。" class="headerlink" title="十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。"></a>十、抗美援朝延缓了中国的国际交往，延缓了经济建设和对外开放。</h4><p>答：此问与第七问一样，属因果颠倒。再者，战争胜利鼓舞了人民斗志，在抗美援朝战争期间，中国完成了国民经济恢复，在近代史上，第一次将军费降到了国家财政支出的一半以下，同时还完成了清匪反霸，消灭百万国民党残余部队，进军西藏完成祖国大陆统一的壮举。应该说抗美援朝促进了新中国的建设。至于对外开放交流，抗美援朝战争为三十年后的改革开放奠定了安全环境。没有志愿军将士用枪炮与霸权实现的交流，就没有后来在平等基础上的和平对话。没有“打”开路，就没有“和”临头！对强权者，敢战，方能言和！</p><h4 id="十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？"><a href="#十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？" class="headerlink" title="十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？"></a>十一、有人将德国分治与朝鲜半岛分裂相提并论，有无法理依据？</h4><p>答：没有！德国是第二次世界大战的战败国，不光要享受盟国分区占领的待遇，还要接受盟国的强行管制。1945年6月5日，苏美英法在柏林签署了击败德国、对德分区占领和管制德国的三个宣言，决定了德国彻底的非武装化和非军事化的问题，明确了盟国有权在德国任何部分或全部驻扎军队及设置民事机构，行使最高权力。同是也明确了盟国可以采取他们认为对于和平与安全所需要的步骤。</p><p>而朝鲜是日本帝国主义的殖民地，是帝国主义侵略战争的受害者而不是加害者，朝鲜人民在反法西斯战争胜利后理应获得独立自由和解放——这也是开罗宣言中包括美国在内的各大国为之作出的承诺，而不是占领、约束和强行管制，更不是再次受到侵略战争的戗害！</p><h4 id="十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？"><a href="#十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？" class="headerlink" title="十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？"></a>十二、有人称，朝鲜战争中苏联占了大便宜，因而中国出兵参战是错误的，此话似乎有理？</h4><p>答：这是一个低智商问题，与当今时髦的市场经济理念格格不入——这与做生意的道理一样，大本钱挣大钱，小本钱挣小钱，不能因为有大本钱的挣了大钱，只有小本钱的连小钱也不挣了——更何况挣来的还未必是小钱。比如第二次世界大战中国出了大力，占的便宜不大，甚至还被人出卖权益，而美国人却占了大便宜，那么是否可以认为中国抗战也是错误的？</p><h4 id="十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？"><a href="#十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？" class="headerlink" title="十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？"></a>十三、美国即然出兵占领了中国台湾，为什么中国不出兵台湾而出兵朝鲜？</h4><p>答：又是一个低智商问题。谁规定了别人打我头我也只能打他头的道理？德国轰炸英国的脑袋伦敦，邱吉尔却在打量人家“柔软的下腹部”。同理，美国人卡中国人脖子，中国人就朝踢美国人的裤裆狠命一脚——如此而已！</p><h4 id="十四、有人占了中国的外蒙古，中国为什么不出兵？"><a href="#十四、有人占了中国的外蒙古，中国为什么不出兵？" class="headerlink" title="十四、有人占了中国的外蒙古，中国为什么不出兵？"></a>十四、有人占了中国的外蒙古，中国为什么不出兵？</h4><p>答：新中国接过的是国民党反动政府的破产家业，同时也承担了国民党反动政府留下的历史债务，而且也尽其可能清理得足够干净了。新中国必须为已经取得的国家利益以及能够争取到的国家权益承担全责，世人没有理由要求他们能够清偿所有的历史债务——尤其是扔下这个破产家业再也不承但任何实际责任的前朝败家子！</p><h4 id="十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！"><a href="#十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！" class="headerlink" title="十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！"></a>十五、中国军队在朝鲜战争中伤亡大于美军，所以美军是胜利者！</h4><p>答：不胜其理！即或此说前提成立，推论仍属荒谬。评价战争胜负的首要前提是战争的目的达到与否及达到的程度，而不仅仅是人头账。苏德战争德军伤亡低于苏军，是否可以认为德军是胜利者？越南战争越南军民伤亡200～300万，美军伤亡30余万，美国人是否敢说自己是胜利者？</p><p>另外，中朝军队面对的是整个“联合国军”和韩军，做算术题时忽略这些被加数，是一种难以原谅的选择性遗忘！</p><h4 id="十六、毛泽东送儿子上前线是镀金。"><a href="#十六、毛泽东送儿子上前线是镀金。" class="headerlink" title="十六、毛泽东送儿子上前线是镀金。"></a>十六、毛泽东送儿子上前线是镀金。</h4><p>答：既然这是个天大的好事儿，将来再有战争或抗洪救灾之类的好事情时，建议首先安排出此语者自己或其儿女到炮火下或洪水中去镀它一金，或烈火焚身，或洪水没顶？新中国决定出兵入朝参战时，连许多身经百战的将帅都没有把握一定胜利，新中国领导人甚至还准备应付美国军队进入中国——“就当中国革命晚胜利几年”！如果有人硬要说毛泽东此时送子上前线是去“镀金”，那不是卯足了劲儿在夸毛泽东料事如神，硬把毛泽东再往神坛上推么？</p><p>再者，如果毛泽东不送儿子上前线呢？你是否能够接受而不再赘言？你又会不会诅咒毛泽东让别人的孩子当炮灰，自家儿子在家躲清闲？横竖毛泽东都是一肚子私欲？而毛岸英就因为有毛泽东这个老子，横竖都该死，——哪怕他是为国捐躯？</p><p>这还有理可讲么？不是天赋人权么？不是上帝面前人人平等么？哪儿去啦？</p><h4 id="十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！"><a href="#十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！" class="headerlink" title="十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！"></a>十七、为什么要用志愿军名义，是因为中国人胆小不敢向美国宣战！</h4><p>答：这是幼儿智力问题且有睁眼瞎之嫌！美利坚合众国正规军劈头盖脑挨了一顶臭揍，明知出招者乃货真价实训练有素的中国正规八路，却仍然忍气吞声不敢堂而皇之宣战接招，不光是胆小，且已气短。至于中国人为何使用志愿军名义，那是中国人民高兴中国人民愿意，中国人民乐意在没有官方名义的前提下充分表达自己的“自由意志”。</p><h4 id="十八、中国军队有苏联撑腰，胜之不武！"><a href="#十八、中国军队有苏联撑腰，胜之不武！" class="headerlink" title="十八、中国军队有苏联撑腰，胜之不武！"></a>十八、中国军队有苏联撑腰，胜之不武！</h4><p>答：中国军队将美国军队从鸭绿江赶回三八线，基本上凭的是手中的“万国牌武器”。苏式武器是运动战后期四五次战役才开始陆续装备部队，苏联空军只掩护清川江以北部分交通线，且大规模参战是在五一年夏季以后，而此时战场大格局已经奠定。</p><p>另外，国民党军队有美国家伙撑腰还有力量优势，仍然败到了台湾？是不是败之很武？</p><p>顺便说一句，美国军队有联合国旗号壮胆，却被迫与人议和，与之对等议和者还是一个根本不被联合国承认的国家，实在是和之无脸！</p><h4 id="十九、中国军队打人海战术，胜之不武！"><a href="#十九、中国军队打人海战术，胜之不武！" class="headerlink" title="十九、中国军队打人海战术，胜之不武！"></a>十九、中国军队打人海战术，胜之不武！</h4><p>答：战争是一种资源较量。各打各的资源，穷人的资源是人，富人的资源是钱──钱能买来“火海战术”。中国军队在“火海战术”下还能集中和机动优势兵力打歼灭战，是战争指导艺术高超的体现。中国军队战略上是“人海战术”，战术上是“小兵群战术”，对此，前美第八集团军司令官马克斯韦尔·泰勒将军对中国军队有极高评价。</p><h4 id="二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。"><a href="#二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。" class="headerlink" title="二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。"></a>二十、在今天这个和平发展的新时代应该多讲如何避免战争，而不应津津乐道于过去的战争。</h4><p>答：同意！所以说“好战必亡”的道理应该多讲给战争能力极其强大而自身受战争戗害极少的国家听。“忘战必倾”的道理应该多讲给战争能力不够强大且自身受战争戗害极多的国家听。具体地说，军事机器最强大而自身受战争戗害极少的美利坚合众国不应津津乐道过去的战争，而要多听听“好战必亡”的道理；军事机器不够强大且自身受战争戗害太多的中华人民共和国需要多多回顾过去的战争，且须多念念“忘战必倾”的道理。这样才有可能避免战争再起。 </p><h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h4><p>朝鲜战争：1950年6月—1953年7月，是<a href="http://baike.baidu.com/view/119146.htm" target="_blank" rel="noopener">朝鲜半岛</a>上的朝韩之间的民族内战。</p><p>抗美援朝：1950年10月—1953年7月，是中国人民支援朝鲜人民抗击美国侵略的群众性运动。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说话</title>
      <link href="/2018/03/25/%E8%AF%B4%E8%AF%9D/"/>
      <url>/2018/03/25/%E8%AF%B4%E8%AF%9D/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Welcome to my blog, enter password to read. "/> <label for="pass"> Welcome to my blog, enter password to read. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/Ul1dRYmmlZXpTDVz0XL96nvNCFapMg373SbQRcbwopkrYCbZ1O0KqjKsq+3YSGfC2s+69/S0fVj/XDBDDADEdjnL0aum/4N1Ffa6h1gNc46SbJsLa+e8RCfnVx1Q1tuW6DujWBBNeJbsCzr6pbW2XdH9MYMJTnvOqlrnJcgxvqNjynvAwMz1W5wNWxM37dNVA0ZPuCtF9DAbESxeePBb7tUgDWEDkg6g/oBXymlX+TNKosm52jkqkr8bw5pXp9oG9BCaThjjLMfIkwsDkfJpOFhCrvPZMWxRxU1mrhEFB0JMd3hZBPED6/cAe+hk/OM+Hw6CtfT3fa87Qt3rYGTiYTDUCHMd27w4yuQoTVouwFsB+eo1eWMonbBX/AIBodzOjuVm6wYNJRCh37220H+alnU8EidfMnCeDUcxqkBcf5XxFEFMQ+XtXG1GzSnI7NBC49RMsG7rfDMEqV2YvScF6Ps9ahq3bZJQQH18TzvULB/FQqWt+1ddaumU/4MXNo0ZA0j1B9YtgtVd4MSf3FLmr2Sk8aV10Dxn/2IMBKORf/cdVBMtkLCQYcQDARSBo+pgD5NNT9NIDWwpxSCzawSx+UrKyGsoSuK9wM/ltYdRKijf3DC7YNgQl1gWDFHAy8ahtWI6NDy4X/0z2o0k1awnR5Xhp/HbfMbB4pYE9wDlu6VzX1cxCkI1w3BeKot++oe9nRRr1s30m7VNdpXPZGrjYRf/R01OLS7+t8a+kXlPyYvQ8hlw4FMun4s/W/Kw5UMK7+t9h2yMKHrANlHGbtfjcb642on1Qyc7qfCeD6s/cRolxiz3e5D5mTlfCk3J7ZCIOkiX6eebj926vNt7apTmT+vRY+fnn0b8fl65VAnGENRh5FVXYYH5vxqEcNc/qEQIeZrC2BLMYpOIXzYzIedqAvpoLWWtfmvUbRefT0y6gc0GRGC/DrEBznxM7bPuzrm1ThsNWwv6ubzdytf6Hpg4t2+YF8d1vGc+nNpW1tscAhZJrXNfIIieguUTp6692ruIFv7VB/pqjVtyjjBAcLyYEBJ/PLVb0l4Xu3VdwgXCdJkDN64CL9hvXpl+cZgqDELvfNnfAhkCmI9q/deuXP29Z+0aWeD+3XujnVFvAeLdGD1/tCxAGSEWz29SCkCp2j9GUsLgqK5Ntsk1XLFWMWLjCdFPRfIQRVapyxviwEaQV3pYiSC6bnPIoKVqMll/3RA2d+qSKYkDer+HnMjo1t3xqH+KqDKtuTQhdnFzAHP2DFM6m4fpkT21A2N7SS0AWjr6bVAlQGS6+4yOhr06I5skm/unX/mwQfyteD/I7dV3e/xjb1y5NWhLZ3bAHfIepReFwUE7PX2g4qYF+RKiq91QtW6DCjmTuFh8MYzo97B3NcIIVb1B/59z+KPopW1HXmxg1EvtspEm+mgRpqCBeJ1DPwTItDl7GMJkRogSjeZW7Jyb6wXtwD1z9ya8y9xOHCObvhzAdKCFHADXtjoxqLVmXRP37YLxRpD859txWbAO+nxcLaEhBjTIYsmSRQKDoxuI10RG9GKrM3la9hQ2N/XHsgRJ9Kp+mYgJHFVHqnxS9Ygaleyakw77kDUhajmRHJAi1PA+TOlaEz2p4seJMHMKhHNMYX6V9lodWUusHaEVDxqNbqPxveFSmYGDsOEqklhiZS0mmfr2nYT3sv6HEIJXrs4tcq9pHioJCvkIMCHv6hUmEyw0z2E4aliVPfFoO0Z3I5RrDv1lD83Cg7Lfos8nv56Z72t+aJvwft85AMhvW/i108uB18ljeVpCBg0rYvedLA3qIKhymCFccZ3YaPapABNOBn1kZldG3lIDGTJL0yDXsyOiSqMS/N6kDSSQLmcGxtvQAdtn/F6CTIkfg0ygYBA2XIa04bPXnVVYO0C0qLizxWiYDzR6OJ302iXb/rcKypQhTmCCPPcP8T8ySNRI4ct9aI1miInvdUtG/K+/5Ijh14QY9BK8eSS7ZNM6oQFcapvTWsk/Z3jwsvvFBuxT3OFwktqnIlvUzTp1gA1impENUwXM7S90PiMNkpTw3pgY3Af600RSUDpX0ezCngtMMPiPVPBgzNMCUh+WhlDfJI7nwof3nhtnDcBQrOMcID6dKlcbeFBRRfwRD36G43yAFv6w02wMxcND0L4U1Xfv4topjEIRJoiISZdxaHKAi/YlHZU3t7n3W1AG1hbpDfxYgR5lFsnL2zFhJtKDy/BzUPuFkBy0JVyTGmRWyyIOlWzHbbCppbGj7A1j6uTJLOaNFrcxKhpzDeP+xiA1soYON1y5iBLLUR7/yNl9Z7dhQhP47u/4oFtF9e2+Dc/eGL069/lgqpmhmitcDkVDAnQwWYQWeQmksrsTxWX1Mu+ZVGQD/dp7kxX4HEMDuOiVL8g5SZDkc40z+xk1oK2mbmrQaxWwPNL+/d/UL4IepTuYQg0fpeSt2jek9P/LOCRPY3BYTiYqhDMk61dUYgU9gkRSoW0cjxUm6XCWjX4wq5wR/hijm9Wm7vm7xExeamLCkKmafMbWtxah70EpGj4ZmFTaFqgJ2sE1O3NBnPdiFHYlfYO0AXLbJMxwXRtC044NfOq/p/CNrDo4ye4mD5rrPiCnTH/5k5MTohabZF1r8HTXaIkfue8XXGCrlGeCpL6b+mShse/+JMmkjAZCK1X7XuZtVHJ/CNU20TlnwQR6DJHbTYt84U7tPktnpFPVVdo4O1LDIWLWwojdWofi9MoafQoBH/H0mZYMmrqKJrSKXsEguG6qchA3lZENait95ncMfhQIpcgB8iZjWsMdvVn6RxuFqX5y9HrJaL0A6VkHyIJwr9YR3dXm+I+vGPceh5EXIHZkSd2EhywLnbsOAzUN5FaWrmspus1chtT/uxJrVVJb56D+LLRRjBuNRLM+aQL4tPluJEEp7uA12cl/xQR0HvA+GaEoPqdwsnnrE0OiII4MVWgFpJyEoXHXbe+R+WsiLFHcQEnX9DHzVtznh+OqzsBHKTyEfMlj8N7t2FM4BbfMUh1jlzWFxucb51S6r06VJkz8j/wHiAqTFPGtpQLVm5QcDTRICR6cSg7CervFB3kTKJjlWPCrW53M2Jw8PFvGMz+t51opZAmIF0uwvj1B3JUwws0ACX2K05L1XDRmfJqWsdJPRztbJyu8gRezGbkdzXg8W6tUs4RGuPBLX2vWUxF6yUc2QhLTmX3GC6HcZkd7vAg/YYsh3OXolAy5r6/fn6AdShVzfZ3P5bkDvd6P0U2sPT3tpBIqnoeGitOVfEA4TTXn2bpwy4UX9TOc/SL3sxH6sUmR/kVpDWjXSTNQuI09oXkdP1IdPbZtBOVM+tMD8yisXRyYQk/ayaKdJK1hROuY/4RMDTbJUqpELaVRPWc+4cvY1fLpWFq0wFii0V0hRi52oTpMozkZ8x22mVucF5eczjZREo6EjG3hoFPpHQXscmRMPiLPBnLbJsMHcEztsf0vrqRg5RIGAUZyZoTn42Cgllh6HvIi11NmP95u3et/niHF4Nx6cUMs73VEEaUlqBZrZ6rPgpN6XuTLFCDooY6oSHKVLgHoS3mCXwS+WWRdzpDCzoUuHTBmyH6AOy4iqAGRZtoIeizDm2YTj1nOdPu5/LDqzZC6aEakSdK37swzSwnDgn/aHmgWjmK8adDVOe3p9VwaLHQWYpmZxBer3U+FEpmZtuKZhXW8= </div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>强制删除工具Geek Uninstaller</title>
      <link href="/2018/03/22/%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%B7%A5%E5%85%B7Geek-Uninstaller/"/>
      <url>/2018/03/22/%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%B7%A5%E5%85%B7Geek-Uninstaller/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>介绍一个强力删除windows软件的小工具，只有2M大小。<a href="https://geekuninstaller.com/" target="_blank" rel="noopener">官方网址在此</a></p><p>经测试，QQ拼音输入法还是不能完全删除，这锅得QQ来背。太流氓！！！不过这款软件还是很好用！</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/31299448" target="_blank" rel="noopener">2M强力“卸载神器”，从此对流氓软件说“不”</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jackie Chan 成龙</title>
      <link href="/2018/03/19/Jackie-Chan-%E6%88%90%E9%BE%99/"/>
      <url>/2018/03/19/Jackie-Chan-%E6%88%90%E9%BE%99/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>想开篇来聊一聊成龙。</p><p>读了这么多书，总想着写东西首先得规划怎么写，采用什么框架写，才不至于流水账形式。</p><p>对于成龙来说，看着他的电影长大，喜欢李连杰的飘逸，可惜李连杰老了，再不复当年之勇，光环慢慢退却；而成龙，还时常活跃在视线中，他还是那个能打能给人带来欢乐的影人，虽然偶尔也发现他也是个六十多岁的老头了，但对他的欣赏仍旧没有改变，反倒随着时间的推移，越来越爱。为了了解他，特地去知乎上搜了：如何评价成龙？从众网友的文字中不难发现，大家都很爱成龙，他超越了同时代的其他影人，成为了旗帜，成了龙。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=64266&auto=0&height=66"></iframe><p>这首歌，是我比较喜欢的大哥的一首歌，歌词平淡，很生活化。其实在众多华语音乐人来说，成龙的标签很明显，这跟他的从师经历有很大的关系。师从京剧名家，京剧表演已经深深烙印在他的灵魂里，无论拍戏还是唱歌，都能发现京剧对他的影响，他很好的把传统与现代结合，独树一帜。</p><iframe width="480" height="320" src="https://static.hdslb.com/miniloader.swf?aid=103632&p=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><blockquote><p><del>这个B站链接有问题，可以直接点进去观看。</del>终于可以了，用swf格式，就可以内嵌播放了。</p></blockquote><p>这部电影揭示了成家班的特效制作，作为影人，成龙将成家班做到了专业化，这也是他走出去回来给自己带来的变化。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成龙 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一人之下</title>
      <link href="/2018/03/16/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B/"/>
      <url>/2018/03/16/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>国漫崛起时，最近被一部国漫《一人之下》实力圈粉，尤其喜欢剧内的各种方言配音，当然少不了各种人物角色歌曲，下面即是网易云的链接：</p><a id="more"></a><h3 id="诸葛青"><a href="#诸葛青" class="headerlink" title="诸葛青"></a>诸葛青</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=537196363&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一人之下 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>女朋友要带回家</title>
      <link href="/2018/01/14/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E8%A6%81%E5%B8%A6%E5%9B%9E%E5%AE%B6/"/>
      <url>/2018/01/14/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E8%A6%81%E5%B8%A6%E5%9B%9E%E5%AE%B6/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>这是昨晚翻B站突然听到的很老的歌，谭杰希的《女朋友要带回家》，还是一个小女生唱的，以前自己玩尤克里里也唱过，那还是刚学那会，现在这么老，唱这么苏的歌有点不好意思唱了，所以每次尽量选择励志的歌来学习，学了好久，至今还是扫弦君。。。大半夜听这么苏的歌很想拿起吉他啊。。。</p></blockquote><a id="more"></a><iframe width="840" height="473" src="http://player.youku.com/embed/XMTMxNjI3OTky" frameborder="0" 'allowfullscreen'=""></iframe>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谭杰希 </tag>
            
            <tag> 郑湫泓 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RNN生成古诗</title>
      <link href="/2018/01/07/RNN%E7%94%9F%E6%88%90%E5%8F%A4%E8%AF%97/"/>
      <url>/2018/01/07/RNN%E7%94%9F%E6%88%90%E5%8F%A4%E8%AF%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>利用RNN生成古诗，看看生成的样子。</p></blockquote><p>隐室令帆出水令，猎人宜道意初干。</p><p>鸣波太众岚彩禁，易郭香鸣栈堕风。</p><p>风竹出茏寒透匣，碧榛终乱异宫祠。</p><p>迷坛金石人难到，骏退多候快逐连。</p><p>千里战旗亭万匝，望烟川色耀光辉。</p><p>异人不敢传秘著，形骸情无念太平。</p><a id="more"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/wzyonggege/RNN_poetry_generator" target="_blank" rel="noopener"></a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="https://LorrinWWW.github.io/posts/[2017.12.10]Entity-resolution/">实体解析 Entity resolution</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于微博图床</title>
      <link href="/2018/01/06/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/"/>
      <url>/2018/01/06/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天发现，上传到微博上的照片，即使客户端删除之后，服务器中还保存副本，链接依然有效，所以考虑到安全问题，有关个人信息的图片还是不要上传到微博上。</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微博 </tag>
            
            <tag> WeiBO </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>晚婚</title>
      <link href="/2017/12/29/%E6%99%9A%E5%A9%9A/"/>
      <url>/2017/12/29/%E6%99%9A%E5%A9%9A/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>突然听到李宗盛的《晚婚》，感觉比江蕙的更好听，唱出了那种岁月沉淀，饱含沧桑。以前很喜欢李宗盛的歌，基本去KTV必点他的歌，这首歌也让我单曲循环了好久，此刻就在。</p></blockquote><a id="more"></a><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/253A015C7271945908E10EBCE654E07D.mp4?sc=e224b9162c5d2a93&br=778&vid=2844070&aid=311&area=HT&vst=2" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/253A015C7271945908E10EBCE654E07D.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>大叔说：我从来不想独身，却有预感晚婚。快30的年头，这已经不是预感了。少不听李宗盛，听了他这么多年，越来越觉得他的词不经岁月打磨，很难到这个境界。他唱歌带吟带唱，像独白、诉说，又或低吟。往往令人情不自禁，所以，今天分享这首，听歌的人每个人感受都不一样，歌者需要的就是拨动人的心弦。</p><p>岁月如歌，年华残酷。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://www.davidfnck.com/marketing/ad_new-balance_jonathan-lee.html/">广告的事｜New Balance X 李宗盛「每一步都算数」</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李宗盛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>摄影笔记手机摄影入门</title>
      <link href="/2017/12/22/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/"/>
      <url>/2017/12/22/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>这是摘选自摄影笔记的内容，在自己的博客中留存。</p></blockquote><a id="more"></a><p><a href="http://www.sybj.com/may.php?c=deLovely&amp;a=courseTable&amp;t=1&amp;name=phone" target="_blank" rel="noopener">手机摄影入门</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/04/07/摄影杂货铺/">摄影杂货铺</a></li><li><a href="http://www.davidfnck.com/talkshow/obama_top_100_best_photos.html/">创业前辈｜Barack Obama's Top 100 best photos</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>月供是怎么回事</title>
      <link href="/2017/12/06/%E8%BD%AC%E6%9C%88%E4%BE%9B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
      <url>/2017/12/06/%E8%BD%AC%E6%9C%88%E4%BE%9B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>买房、买车，人生大事，抛开全款，你了解月供几何？</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://mp.weixin.qq.com/s/9qQ21OFThBqAIQuUsYdbvA" target="_blank" rel="noopener">月供是怎么回事？</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转傅立叶白话分析</title>
      <link href="/2017/12/05/%E8%BD%AC%E5%82%85%E7%AB%8B%E5%8F%B6%E7%99%BD%E8%AF%9D%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/05/%E8%BD%AC%E5%82%85%E7%AB%8B%E5%8F%B6%E7%99%BD%E8%AF%9D%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文以简明的语言向读者阐述了傅立叶分析的基本原理，适合入门。</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程（完整版）更新于2014.06.06</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 傅立叶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转从LeNet到DenseNet</title>
      <link href="/2017/12/05/%E8%BD%AC%E4%BB%8ELeNet%E5%88%B0DenseNet/"/>
      <url>/2017/12/05/%E8%BD%AC%E4%BB%8ELeNet%E5%88%B0DenseNet/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文详细介绍了CNN各网络的发展史，值得一读。</p></blockquote><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/31006686" target="_blank" rel="noopener">从LeNet-5到DenseNet</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>南京美食记</title>
      <link href="/2017/12/05/%E5%8D%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E8%AE%B0/"/>
      <url>/2017/12/05/%E5%8D%97%E4%BA%AC%E7%BE%8E%E9%A3%9F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>平时无聊，总想着去哪吃，会看到一些网友推荐，过后再想吃的时候又忘了，所以，特开此文广记南京美食，采取完成任务列表模式，当然，现在一家都没吃过，开篇啦！！！</p></blockquote><a id="more"></a><h3 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/Itdw09JSwujCypXSE3eOww" target="_blank" rel="noopener">尤广记牛杂王</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/808T4rVTkiLkiMCkzab8GQ" target="_blank" rel="noopener">大蔬无界</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/SyTjL5Y3UnqwGS43CL-BYw" target="_blank" rel="noopener">泽锅草原牛肉火锅</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://mp.weixin.qq.com/s/I_ogU9vOY7N89OTUeJoZAg" target="_blank" rel="noopener">米桃餐厅</a></li></ul><h3 id="饮品"><a href="#饮品" class="headerlink" title="饮品"></a>饮品</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://mp.weixin.qq.com/s/OUpX8a5XAmSS4YvdD2h57Q" target="_blank" rel="noopener">甜荟</a></li><li style="list-style: none"><input type="checkbox"> ​</li></ul>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
            <tag> 南京 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛排常识</title>
      <link href="/2017/12/04/%E7%89%9B%E6%8E%92%E5%B8%B8%E8%AF%86/"/>
      <url>/2017/12/04/%E7%89%9B%E6%8E%92%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>常听别人说起某某某牛排，那么各种牛排的区别是什么，本博文假他人之手娓娓道来。</p></blockquote><a id="more"></a><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm520zsoqsj30hj0bn7lp.jpg" alt=""></p><p><strong>先来一张我大蔚蓝海岸尼斯柠檬节的神牛镇题</strong></p><p>法国人虽然没有西班牙人对牛如此有感情把牛当成<strong>国家图腾</strong>（法兰西喜欢大公鸡+ +), 但是对于个个吃货的法国来说牛排和牛肉简直就是人生活下去的动力之一。所以在吃牛上法国的讲究都是世界牛肉研究的领头羊。在做牛排这事上还是得看法国人的，所以基本牛肉在牛身上的位置专业单词都是法语基础，英语的单词都是直接引用<strong>法语词汇换成英语发音</strong>而已。下文有些<strong>专业单词</strong>我就直接用法语写了。</p><p>只是牛排的话<strong>小牛肉veau </strong>是最好的牛排食材既兼顾<strong>鲜嫩多汁</strong>而且肉的<strong>弹性</strong>也非常<strong>完美</strong>，但是牛肉的做法十分复杂，根据肉质不同用法也不尽相同。</p><p>在硕士一年级<strong>修味嗅觉分析</strong>的时候专门研究过牛排的口感和味道不同，还写了<strong>一篇论文</strong>。</p><p>把当时的论文用图先放出来，文字的话看完<strong>今晚的世界杯</strong>翻译过来 : D</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm5210k0inj30j20c74a4.jpg" alt=""></p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm52117b7fj30j10d04bo.jpg" alt=""></p><p>世界杯看完了，意大利万岁，我又赢了一顿日本料理 : D</p><p>在讨论<strong>味道</strong>的时候不先讨论<strong>牛的品种和产地</strong>都是耍<strong>流氓</strong>，我的论文第一部分就是对各个<strong>AOC产地保护</strong>的<strong>法国牛</strong>种的讨论和确定它们各自的特点。</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5211tcf8j30a70f7ju9.jpg" alt=""></p><p>这些都是被<strong>欧盟承认</strong>的法国产区保护的独特牛种，其中最后一种白色的<strong>charolaise 白牛</strong>肉质最为鲜美，在广阔的<strong>特种牧草放牧</strong>长大，并且本身肉质就以肉内<strong>血脂细腻</strong>出名。是在世界范围内都是很出名不可多得的<strong>高大上牛肉</strong>。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5212fksrj30dx0afk1f.jpg" alt=""></p><p>好漂亮的牛牛，么么嗒 :》</p><p>其他的高品质牛肉还有人尽皆知的<strong>日本和牛，澳洲牛肉，匈牙利牛肉</strong>等等，这些牛肉某些部位脂肪肌肉比例搭配完美直接sashimi 是最好的选择，<strong>牛排浪费了</strong>。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm52132qhfj30fm0cgwq0.jpg" alt=""></p><p>比如这道<strong>法国牛肉名菜</strong>：<strong>tartare du boeuf</strong>。 也是被各种<strong>排名</strong>文章和传说中的<strong>仰望星空派</strong>一样放在绝对不要点的外国菜里面，排名还<strong>挺高</strong>。</p><p>有一次在巴黎歌剧院附近的HIPOPOTAMUS 吃饭，旁边两个中国情侣游客看到法国人点的这个，立马眼睛瞪得牛大<strong>开始议论</strong>：哎呀，妈呀，生肉哎，那个中国人能吃这个呀！话音还没落，服务员就给我上了一道<strong>一样的</strong>，他俩的表情别说多精彩了 : p</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5213q4ukj308r05wae9.jpg" alt=""></p><p>法国的tartare du boeuf 做法<strong>不够细腻</strong>，牛肉块比较大，主要靠搭配不同的SAUCE来调味。而意大利的做法更加适合想要品尝一下牛肉原味而又不是吃肉老饕的人，用剁碎的牛肉搭配各种香草，味道很好，比更加出名的意大利生牛肉切片CARPACIO 更有肉质风味。（有点像生吃牛肉饺子馅:》)</p><p><img src="http://wx2.sinaimg.cn/mw690/005IKUsQly1fm5214ftaxj30ee09uk11.jpg" alt=""></p><p>回到正题讨论牛排的不同部位口感：</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm52159ob9j30ey0hr7b0.jpg" alt=""></p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm52169e7hj30hx06laml.jpg" alt=""></p><p>一只牛可以吃的部位不要太多，我们得确定牛身上那些<strong>部分</strong>是可以<strong>煎牛排</strong>的：从表中我们可以看到3，4，5，7，9,20,21,22,23,24 这几个部位都是用来做煎牛排的，那么这些部位叫什么名字呢？</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm5216zsuzj30i10dl1dd.jpg" alt=""></p><p><strong>部位三entrecôte</strong> 是肋排，是最经典的煎牛排部位。 肋排肋排必然是排骨肉啦。 跟猪肉一样，肋排口感不够细腻，但是咬头很好，很咬口，而且不会有含牛筋那种藕断丝连嚼不烂的感觉。 最重要的是肋排一般比较<strong>便宜</strong>比较<strong>大块</strong>，饭店里动辄350G 或者500G的大肋排，适合我这种<strong>食肉动物</strong>。</p><p><strong>部位五六七</strong>味道相近，但<strong>等级不同</strong></p><p>部位六就是传说中的<strong>菲利（法语filet）</strong>牛排，是牛排中最顶级的部位。腰内肉部分<strong>牛腰肉</strong>（英语tenderloin），最嫩处切出，是牛脊上的肉，形状头大尾小，脂肪含量少，适合三分熟，吸吮<strong>甜美的肉汁</strong>，<strong>肉质鲜嫩</strong>，菲力牛排包裹在牛腹腔中，所以肌肉都没运动到，故肌肉纤维不粗。是牛排中单价最高的。</p><p>五七两个部分比较复杂，<strong>5 faux filet</strong> 就是接近于菲利牛排的牛胸脊肉部分，口感与菲利牛排类似，但是<strong>鲜嫩度</strong>较低，弹性较好和肉质稍稍<strong>偏硬</strong>但不会让人觉得咀嚼困难。</p><p>这两个部分在美国英国等地叫法不同，或者翻译成沙朗牛排或者西冷牛排。<br>沙朗牛排在美国指牛后腰脊柱两侧的肉，肉质细嫩，价格高。其中顶部（top sirloin）的肉质最好，价格最高，一般会标明。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5217op46j30e708i40l.jpg" alt=""></p><p>沙朗牛排在英国、香港等地指牛胸脊肉部分，肉质细嫩度次于菲利牛排，售价也较低于菲力牛排，上端部分的西冷牛排较为鲜嫩，售价亦稍高。</p><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fm5218fllsj30dy08mjvw.jpg" alt=""></p><p>filet 菲利是除了小牛肉这种高级食材外做牛排最好最高价的部位，基本都是各个牛排屋的拿手绝活。</p><p>二十，二十一两个部位比较相近常常放到一起讨论，这两个部位是牛肉中<strong>最少见</strong>的部分。基本不会在大的超市里销售，肉店老板会<strong>留给识货</strong>或相熟的大厨朋友。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm52194xivj30gr0drh1p.jpg" alt=""></p><p>ONGLET是<strong>膈柱肌肉</strong>， 可以做牛排，但是一定要避免过度煎烤。因为肌肉纤维较长，如果全熟会导致牛排过硬难以切割，更别说下口了。</p><p>HAMPE 是靠近大腿内侧的<strong>腹部肉</strong>， 一般情况下<strong>不会直接</strong>煎成牛排，因为肌肉纤维太长外表看起来都很明显。 但这个部位可以做成最好的steak haché <strong>碎肉牛排</strong>，不会因为肉质过软导致剁碎后牛肉失去<strong>弹性</strong>。碎肉牛排就是一般汉堡包会使用的牛排。是不是高档汉堡就看其中的肉排是不是HAMPE做的就可以了。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm5219xjcaj30dd08l473.jpg" alt=""></p><p>这两个部位一般是被认为最接近下水的牛肉，所以不是牛肉老饕根本不会关注这两个部位的口感。</p><p><strong>23，24 bavette </strong>是牛的<strong>腰腹部细肉</strong>， bavette à l’échalote 是一道用小洋葱做的传统法国名菜。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521ai6dwj30i40e1dwj.jpg" alt=""></p><p>这个部位牛排做法比较<strong>奇特</strong>，厨师用非常热的手在肉的两端各放几分钟，牛排的内心必须是全生的。因为这个部分筋非常多，如果烤熟就太过难咬。但如果做的适当，可以说是牛身上味道最丰富的一个部位。</p><p><strong>24 flanchet是腹肉，相当</strong>少见用来做牛排的一个部分。因为作为牛身体<strong>脂肪</strong>最多的部位，应该说油脂能增加牛排香味。可是此处油脂含量过高，导致牛排煎起来较生会油腻，煎熟又会导致牛排肉质因为煎烤时间过长而过老难以下口，所以通常是做牛排牛肉中最后一个选择。</p><p><strong>2 basses cotes 牛上脑</strong> 或者翻译成牛眼肉，也是我个人最喜欢的一个部位。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521b4lykj30bs076tfq.jpg" alt=""></p><p>不光是做牛排，就算是中国的传统火锅，牛上脑也是最棒的<strong>刷锅肉材</strong>！ 肉质绵软细腻，肥瘦相宜，如若切片生吃，可算是慢慢在口中融化的感觉异常美妙。</p><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fm521br0v6j30bw07t47i.jpg" alt=""></p><p> 普罗旺斯的AIX 我住的城市里有一家韩国烧烤，提供<strong>匈牙利牛上脑</strong>烧烤，每次去朋友们都是烟熏火绕异常热闹，而只有我自己慢慢品味上脑在口中融化纠缠的感觉。每次被人笑话把韩餐吃成<strong>日料</strong> : )</p><p>大家下次在高档火锅店确定是<strong>内蒙牛肉</strong>的上脑薄切片肉可以试试用清淡调料<strong>腌制</strong>一下，然后<strong>生食</strong>，享受如同<strong>西班牙火腿</strong>的如丝织般的性感。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521cgftyj30fm0c2tjg.jpg" alt=""></p><p>如果用牛上脑做牛排，比较适合的是5成熟。外表的虽然已熟透，但下口没有阻碍感，内部的汁水会浸满过舌，<strong>略微甜甜</strong>又不腥腻，咀嚼起来丝毫不用力，微微咬动已经<strong>满口肉香</strong>。有点像吃鲑鱼子寿司挤破鱼子的快感。</p><p><img src="http://wx3.sinaimg.cn/mw690/005IKUsQly1fm521d76yaj30hz0cbgyz.jpg" alt=""></p><p>而相较于菲利（filet）牛上脑<strong>体积</strong>比较大，价格并不昂贵，是非常具有<strong>性价比</strong>的牛排部位。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.zhihu.com/question/20467087/answer/26828813" target="_blank" rel="noopener">不同部位的牛肉有什么区别，做出的牛排口感有何差异？ - 晨曦的回答 - 知乎</a></li></ol>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛排 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种咖啡种类区别</title>
      <link href="/2017/12/04/%E5%90%84%E7%A7%8D%E5%92%96%E5%95%A1%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/12/04/%E5%90%84%E7%A7%8D%E5%92%96%E5%95%A1%E7%A7%8D%E7%B1%BB%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>平时听说各种咖啡，还有各种区别，听起来头大，在此笔记。</p></blockquote><a id="more"></a><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbk3yj20c80a1aa5.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbfugj20c80adt8u.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbokoj20c80a5q34.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpbffvj20c80at3yl.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpa4xcj20c80a874e.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpb5gxj20c809swek.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpcq2oj20c80au3yo.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpd4nbj20c80abmx9.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/a86c2ca1gy1fm4xtpdwl4j20c80atjrh.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本地编辑markdown工具Typora</title>
      <link href="/2017/12/04/%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91markdown%E5%B7%A5%E5%85%B7Typora/"/>
      <url>/2017/12/04/%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91markdown%E5%B7%A5%E5%85%B7Typora/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>推荐一个本地编辑markdown的工具，在各平台下都有版本。</p></blockquote><p>官方网址为：<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows绝赞应用</title>
      <link href="/2017/12/04/windows%E7%BB%9D%E8%B5%9E%E5%BA%94%E7%94%A8/"/>
      <url>/2017/12/04/windows%E7%BB%9D%E8%B5%9E%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>「Windows 绝赞应用」项目由 @<a href="https://link.zhihu.com/?target=https%3A//github.com/EMLVIRUS" target="_blank" rel="noopener">EMLVIRUS</a> 发起，旨在帮用户提供优秀的 Windows 应用以免除繁琐的搜寻工作。<strong>我们姑且可以将其理解为一份人工维护的优质 Windows 应用推荐榜单</strong>，前往 <a href="https://link.zhihu.com/?target=https%3A//emlvirus.gitbooks.io/windows-apps-that-amaze-us/content/" target="_blank" rel="noopener">该项目的 GitBook 页面</a> 即可在线进行阅读和索引。</p><p><a href="https://amazing-apps.gitbooks.io/windows-apps-that-amaze-us/content/zh-CN/" target="_blank" rel="noopener">Windows绝赞应用</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="http://gubangzhong.cn/2016/11/16/女人如政治/">女人如政治</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一千年以后</title>
      <link href="/2017/11/26/%E4%B8%80%E5%8D%83%E5%B9%B4%E4%BB%A5%E5%90%8E/"/>
      <url>/2017/11/26/%E4%B8%80%E5%8D%83%E5%B9%B4%E4%BB%A5%E5%90%8E/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>感叹养猪家音乐越来越办不下去了，现在基本是企鹅一家独大，好多养猪家的歌曲现在都听不了了，于是悄悄下了企鹅家的QQ音乐，其实现在对企鹅家的东西不是太排斥，尽管年少曾骂过。企鹅家的音乐有个不好的地方，就是我不方便在自己的网页中嵌入代码。不像养猪家那么人性化，比如，我今天听到一千年之后，就想在自己的网页中嵌入这段音乐，可惜只有链接。这时候又念叨养猪家的东西好啊！！！</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26305531&auto=0&height=66"></iframe><p>越老越怀念以前，可能是单身或者在学校的时间久了，有太多的时间迷茫和感伤，所以就听歌吧！！！</p><p>不知道一年之后的自己是什么样子，也许也许，板凳坐久了总想出去看看，想多了也就看淡了，现在少年老成的词也许已经不合适了，人到中年了哈！！！</p>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些资料翻译收集</title>
      <link href="/2017/11/25/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E7%BF%BB%E8%AF%91%E6%94%B6%E9%9B%86/"/>
      <url>/2017/11/25/%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E7%BF%BB%E8%AF%91%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://zhuanlan.zhihu.com/p/31363259" target="_blank" rel="noopener">Scikit-Learn 中文文档第一期校验完成，邀请你来参与维护，一起走的更远 | ApacheCN</a><br>2.<a href=""></a><br>3.<a href=""></a><br>4.<a href=""></a><br>5.<a href=""></a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2018/01/07/RNN生成古诗/">RNN生成古诗</a></li><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> 转载 </tag>
            
            <tag> scikit-learn </tag>
            
            <tag> elastic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在python下利用opencv读取图片</title>
      <link href="/2017/11/23/%E5%9C%A8python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/"/>
      <url>/2017/11/23/%E5%9C%A8python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'filename'</span>)</span><br><span class="line">print(type(img))</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'window_name'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">'window_name'</span>)</span><br></pre></td></tr></table></figure><p>注意opencv读出来的img格式直接是numpy.ndarray格式，可以用numpy直接操作。</p><p>参考资料1不是用opencv读取图像的，可以尝试看看，以供学习。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.cnblogs.com/yinxiangnan-charles/p/5928689.html" target="_blank" rel="noopener">python 读取并显示图片的两种方法</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> opencv </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10安装django错误集</title>
      <link href="/2017/11/20/win10%E5%AE%89%E8%A3%85django%E9%94%99%E8%AF%AF%E9%9B%86/"/>
      <url>/2017/11/20/win10%E5%AE%89%E8%A3%85django%E9%94%99%E8%AF%AF%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在cmd中创建第一个项目吧。</p><p>django-admin startproject mysite(千万不要使用django-admin.py startproject mysite这样老是打开django-admin.py文件，仅纪念踩过的坑)</p><p>cd mysite,运行python manage.py runserver,打开浏览器输入<a href="http://127.0.0.1:8000/,下面就开始开发你的网站吧" target="_blank" rel="noopener">http://127.0.0.1:8000/,下面就开始开发你的网站吧</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://blog.csdn.net/uuyytg/article/details/76036557" target="_blank" rel="noopener">window10下安装Django</a></p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转PyQt5教程</title>
      <link href="/2017/11/20/%E8%BD%ACPyQt5%E6%95%99%E7%A8%8B/"/>
      <url>/2017/11/20/%E8%BD%ACPyQt5%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.cnblogs.com/archisama/tag/PyQt5/" target="_blank" rel="noopener">PyQt5</a></li></ol><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 转载 </tag>
            
            <tag> PyQt5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彻底卸载VisualStudio</title>
      <link href="/2017/11/20/%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVisualStudio/"/>
      <url>/2017/11/20/%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDVisualStudio/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有个插件叫TotalUninstaller，启用这个插件就可以完全删除visual studio的版本！在此mark，在我的百度网盘里有留存！</p><a id="more"></a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://jingyan.baidu.com/article/72ee561a560958e16138dfda.html" target="_blank" rel="noopener">教你彻底卸载Visual Studio 2015</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转：目标检测系列博客</title>
      <link href="/2017/11/20/%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/11/20/%E8%BD%AC%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="晓雷机器学习笔记"><a href="#晓雷机器学习笔记" class="headerlink" title="晓雷机器学习笔记"></a>晓雷机器学习笔记</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/23006190?refer=xiaoleimlnote" target="_blank" rel="noopener">RCNN-将CNN引入目标检测的开山之作</a></li><li><a href="https://zhuanlan.zhihu.com/p/24774302?refer=xiaoleimlnote" target="_blank" rel="noopener">SPPNet-引入空间金字塔池化改进RCNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24780395?refer=xiaoleimlnote" target="_blank" rel="noopener">Fast R-CNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24916624?refer=xiaoleimlnote" target="_blank" rel="noopener">Faster R-CNN</a></li><li><a href="https://zhuanlan.zhihu.com/p/24916786?refer=xiaoleimlnote" target="_blank" rel="noopener">图解YOLO</a></li><li><a href="https://zhuanlan.zhihu.com/p/24954433?refer=xiaoleimlnote" target="_blank" rel="noopener">SSD</a></li><li><a href="https://zhuanlan.zhihu.com/p/25167153?refer=xiaoleimlnote" target="_blank" rel="noopener">YOLO2 </a></li></ol><h3 id="Learning-Machine"><a href="#Learning-Machine" class="headerlink" title="Learning Machine"></a>Learning Machine</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/28585873" target="_blank" rel="noopener">keras版faster-rcnn算法详解(1.RPN计算)</a></li><li><a href="https://zhuanlan.zhihu.com/p/29400164" target="_blank" rel="noopener">keras版faster-rcnn算法详解(2.roi计算及其他)</a></li></ol><h3 id="机器学习随笔"><a href="#机器学习随笔" class="headerlink" title="机器学习随笔"></a>机器学习随笔</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">Faster R-CNN</a></li></ol><h3 id="刘航呈"><a href="#刘航呈" class="headerlink" title="刘航呈"></a>刘航呈</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/30316608" target="_blank" rel="noopener">R-CNN学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/30368989" target="_blank" rel="noopener">Fast R-CNN学习总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/30720870" target="_blank" rel="noopener">Faster R-CNN学习总结</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己动手做聊天机器人</title>
      <link href="/2017/07/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2017/07/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ol><li><a href="http://www.shareditor.com/bloglistbytag/?tagname=%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA" target="_blank" rel="noopener">自己动手做聊天机器人</a></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RNN资料收集</title>
      <link href="/2017/07/22/RNN%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>/2017/07/22/RNN%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><ol><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></li><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-2-implementing-a-language-model-rnn-with-python-numpy-and-theano/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 2 – Implementing a RNN with Python, Numpy and Theano</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ol><a id="more"></a><p>另外WILDML的一些博客：</p><ol><li><a href="http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/" target="_blank" rel="noopener">Implementing a Neural Network from Scratch in Python – An Introduction</a></li><li><a href="http://www.wildml.com/2015/09/speeding-up-your-neural-network-with-theano-and-the-gpu/" target="_blank" rel="noopener">Speeding up your Neural Network with Theano and the GPU</a></li><li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">Understanding Convolutional Neural Networks for NLP</a></li><li><a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="noopener">Implementing a CNN for Text Classification in TensorFlow</a></li><li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">Attention and Memory in Deep Learning and NLP</a></li><li><a href="http://www.wildml.com/2016/04/deep-learning-for-chatbots-part-1-introduction/" target="_blank" rel="noopener">Deep Learning for Chatbots, Part 1 – Introduction</a></li><li><a href="http://www.wildml.com/2016/07/deep-learning-for-chatbots-2-retrieval-based-model-tensorflow/" target="_blank" rel="noopener">Deep Learning for Chatbots, Part 2 – Implementing a Retrieval-Based Model in Tensorflow</a></li><li><a href="http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/" target="_blank" rel="noopener">RNNs in Tensorflow, a Practical Guide and Undocumented Features</a></li><li><a href="http://www.wildml.com/2016/10/learning-reinforcement-learning/" target="_blank" rel="noopener">Learning Reinforcement Learning (with Code, Exercises and Solutions)</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安装latex</title>
      <link href="/2017/07/22/%E5%AE%89%E8%A3%85latex/"/>
      <url>/2017/07/22/%E5%AE%89%E8%A3%85latex/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文主要记录下安装使用latex的两个软件：</p><ol><li><a href="https://miktex.org/" target="_blank" rel="noopener">miktex</a></li><li><a href="http://www.xm1math.net/texmaker/" target="_blank" rel="noopener">texmaker</a></li></ol><p>首先安装miktex，然后再安装texmaker。</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/u013063099/article/details/51926023" target="_blank" rel="noopener">Miktex 2.9+Texmaker 4.4.1安装及中英PDF生成过程</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://LorrinWWW.github.io/posts/hexo-with-latex/">解决hexo使用公式冲突问题 hexo with latex</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如果我爱你</title>
      <link href="/2017/07/21/%E5%A6%82%E6%9E%9C%E6%88%91%E7%88%B1%E4%BD%A0/"/>
      <url>/2017/07/21/%E5%A6%82%E6%9E%9C%E6%88%91%E7%88%B1%E4%BD%A0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近新上的剧《春风十里》的主题曲，最近越来越喜欢周冬雨了。以前不待见这么个演员，从老谋子选角山楂树开始，觉得老谋子怎么选了个这么样的女演员，长得不怎么好看，眼镜如此之小。现如今再看，真为当时的自己感到羞愧，如此以貌取人。近段时间，从《七月与安生》到《喜欢你》，本来我不喜欢的电影，愣是凭着周冬雨的戏让我坚持看了下来，从此开始喜欢上这个有点神经再细看又如此美丽的演员。新剧《春风十里》估计符合她这几部剧一贯的风格，调皮、青涩、生动，只她演过的那几部戏，就深深吸引了我。这是她和张一山为《春风十里》而唱的主题曲，尽管唱功不是那么完美，但是由这两人唱出来平添了许多的韵味，有初恋的那种单纯，有春风化雨的细腻，有怦然心跳的悸动。如果我爱你……</p><a id="more"></a><p>网易云音乐</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=489998494&auto=0&height=66"></iframe><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/E62E015D3ECA5CF4408B7E2AB8AE5F6A.mp4?sc=281fab630288fdbe&br=774&vid=2910410&aid=14997&area=ML&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/E62E015D3ECA5CF4408B7E2AB8AE5F6A.mp4?sc=281fab630288fdbe&br=774&vid=2910410&aid=14997&area=ML&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周冬雨 </tag>
            
            <tag> 张一山 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Matlab常用函数及技巧</title>
      <link href="/2017/07/17/Matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%8A%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/07/17/Matlab%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%8A%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文记录常用matlab函数以及技巧，不定时更新。</p></blockquote><a id="more"></a><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>TBD</p><h3 id="strrep"><a href="#strrep" class="headerlink" title="strrep"></a>strrep</h3><p>TBD</p><h3 id="imwrite"><a href="#imwrite" class="headerlink" title="imwrite"></a>imwrite</h3><p>imwrite(参数变量,’保存名称.保存格式’);</p><p>如果参数变量是double类型的，在保存的时候切记将参数变量除以参数变量的动态范围以归一化到[0,1]，这样才能正确保存为bmp或者jpg等格式。</p><h3 id="var-cov"><a href="#var-cov" class="headerlink" title="var/cov"></a>var/cov</h3><p>方差/协方差</p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>dir(路径);</p><p>遍历变量路径下的文件和文件夹</p><h4 id="isdir"><a href="#isdir" class="headerlink" title="isdir"></a>isdir</h4><p>判断dir得到的struct是否是文件夹</p><h3 id="fread-fopen-fclose"><a href="#fread-fopen-fclose" class="headerlink" title="fread/fopen/fclose"></a>fread/fopen/fclose</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fid = fopen(路径);</span><br><span class="line"><span class="keyword">if</span> fid &gt; <span class="number">0</span></span><br><span class="line">data = fread(fid,[高 宽],存储格式);</span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error(<span class="string">'文件未能打开'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="fullfile"><a href="#fullfile" class="headerlink" title="fullfile"></a>fullfile</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fullfile(变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>,变量<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&gt; &gt; 变量<span class="number">1</span>/变量<span class="number">2</span>/变量<span class="number">3</span>/变量<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">strcat(变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>,变量<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&gt; &gt; 变量<span class="number">1</span>变量<span class="number">2</span>变量<span class="number">3</span>变量<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="num2str"><a href="#num2str" class="headerlink" title="num2str"></a>num2str</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">num2str(变量,<span class="string">'%04d'</span>) <span class="comment">% 整数补充到4位，不足前面加零</span></span><br><span class="line"></span><br><span class="line">num2str(<span class="number">2</span>,<span class="string">'%04d'</span>)</span><br><span class="line"></span><br><span class="line">&gt; &gt; <span class="number">0002</span></span><br></pre></td></tr></table></figure><h3 id="ginput"><a href="#ginput" class="headerlink" title="ginput"></a>ginput</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[x y] = ginput(<span class="number">2</span>);<span class="comment">% 手动在图上选取2个点</span></span><br></pre></td></tr></table></figure><h3 id="corr"><a href="#corr" class="headerlink" title="corr"></a>corr</h3><p>计算矩阵列向量相关系数函数</p><h3 id="movefile-copyfile"><a href="#movefile-copyfile" class="headerlink" title="movefile/copyfile"></a>movefile/copyfile</h3><p>移动文件/复制文件</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://blog.csdn.net/watkinsong/article/details/38535595" target="_blank" rel="noopener">matlab imwrite 保存图像详解</a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010q68.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）-（一）</a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010twg.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）-（二）_函数var </a></li><li><a href="http://blog.sina.com.cn/s/blog_9e67285801010twv.html" target="_blank" rel="noopener">方差var、协方差cov、协方差矩阵（浅谈）（三）_函数cov</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>protobuf生成c++代码详解(初稿)</title>
      <link href="/2017/07/13/protobuf%E7%94%9F%E6%88%90cplusplus%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/07/13/protobuf%E7%94%9F%E6%88%90cplusplus%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文翻译自<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="noopener">C++ Generated Code</a></p></blockquote><a id="more"></a><p>本文描述了<code>protocol</code>缓冲编译器为指定的<code>protocol</code>定义生成的<code>C++</code>代码。<code>proto2</code>和<code>proto3</code>生成代码之间的任何区别都会突出显示。请注意，这些差异在生成代码中，而不在<code>base classes/interfaces</code>，这两个版本的<code>base classes/interfaces</code>都相同。在阅读本文档之前，您应该阅读proto2语言指南和/或proto3语言指南。</p><h3 id="Compiler-Invocation"><a href="#Compiler-Invocation" class="headerlink" title="Compiler Invocation"></a>Compiler Invocation</h3><p><code>protocol</code>缓冲区编译器在使用<code>--cpp_out=</code>命令行时生成<code>C++</code>输出。该<code>--cpp_out=</code>选项的参数是编译器生成<code>C++</code>代码输出的目录。编译器为每个<code>.proto</code>文件输入创建头文件和实现文件。输出文件的名称通过获取<code>.proto</code>文件的名称并进行两次更改来实现：</p><ul><li>源文件扩展名<code>.proto</code>被替换为<code>.pb.h</code>或<code>.pb.cc</code>，即为头或实现文件。</li><li><code>proto</code>路径（用<code>--proto_path=</code>或<code>-I</code>命令行标志指定）被输出路径（用<code>--cpp_out=</code>标志指定）替换。</li></ul><p>假设你调用编译器如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto</span><br></pre></td></tr></table></figure><p>编译器将读取这些文件<code>src/foo.proto</code>和<code>src/bar/baz.proto</code>，产生四个输出文件：<code>build/gen/foo.pb.h</code>，<code>build/gen/foo.pb.cc</code>，<code>build/gen/bar/baz.pb.h</code>，<code>build/gen/bar/baz.pb.cc</code>。编译器根据需要自动创建目录将<code>build/gen/bar</code>，但不会创建<code>build</code>或<code>build/gen</code>，它们必须已经存在（即需要自己创建）。</p><h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h3><p>如果<code>.proto</code>文件包含一个<code>package</code>声明，则文件的全部内容将被放置在相应的<code>C++</code>命名空间中。例如，给出<code>package</code>声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br></pre></td></tr></table></figure><p>文件中的所有声明将在<code>foo::bar</code>命名空间中。</p><h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>给出一个简单的消息声明：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><code>protocol</code>缓冲区编译器生成一个由<code>google::protobuf::Message</code>公开派生的类<code>Foo</code>。这个类是一个具体的类，没有纯虚函数等待实现。根据优化模式，<code>Message</code>中的虚函数但不是纯虚函数可以被<code>Foo</code>覆盖也可以不被覆盖。默认情况下，<code>Foo</code>以最大速度实现所有函数的专门版本。但是，如果<code>.proto</code>文件包含该行：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure><p>那么<code>Foo</code>将仅覆盖功能所需的最小的一组方法，并依赖其余的基于反射的实现。这显著减少了生成的代码，但也降低了性能。或者，如果<code>.proto</code>文件包含：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = LITE_RUNTIME;</span><br></pre></td></tr></table></figure><p>那么<code>Foo</code>将包括所有方法的快速实现，将实现该<code>google::protobuf::MessageLite</code>接口，该接口只包含<code>Message</code>方法的子集。特别地，它不支持描述符或映射。但是，在这种模式下，生成的代码只需要链接<code>libprotobuf-lite.so</code>（<code>libprotobuf-lite.lib</code>在<code>Windows</code>上），而不是<code>libprotobuf.so</code>（<code>libprotobuf.lib</code>）。<code>lite</code>库比完整的库小得多，更适合资源有限的系统，如手机。</p><p>你不能创建自己的<code>Foo</code>子类。如果您将此类子类化并覆盖虚函数，则覆盖可能会被忽略，因为许多生成的方法调用都将被去虚拟化以提高性能。</p><p><code>Message</code>接口定义了检查、处理、读取或写入整个<code>message</code>的方法，包括解析和序列化到二进制字符串。除了这些方法，<code>Foo</code>类还定义了以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo()：默认构造函数。</span><br><span class="line">~Foo()：默认析构函数。</span><br><span class="line">Foo(<span class="keyword">const</span> Foo&amp; other)：拷贝构造函数。</span><br><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; other)：赋值运算。</span><br><span class="line"><span class="keyword">void</span> Swap(Foo* other)：用另一个消息交换内容。</span><br><span class="line"><span class="keyword">const</span> UnknownFieldSet&amp; unknown_fields() <span class="keyword">const</span>：返回解析此消息时遇到的一组未知字段。</span><br><span class="line">UnknownFieldSet* mutable_unknown_fields()：返回指向解析此消息时遇到的未知字段的可变集的指针。</span><br></pre></td></tr></table></figure><p>该类还定义了以下静态方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Descriptor* <span class="title">descriptor</span><span class="params">()</span></span></span><br><span class="line">- 返回类型的描述符。这包含有关类型的信息，包括它的字段和它们的类型。这可以用映射以编程方式检查字段。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Foo&amp; <span class="title">default_instance</span><span class="params">()</span></span></span><br><span class="line">- 返回一个const单例实例Foo与新构造的实例相同Foo（所有单个字段未设置，所有重复字段都为空）。请注意，消息的默认实例可以被用作工厂通过调用其New()方法。</span><br></pre></td></tr></table></figure><p><code>message</code>可以在另一个<code>message</code>中声明。例如：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123; message Bar &#123; &#125; &#125;</span><br></pre></td></tr></table></figure></p><p>在这种情况下，编译器生成两个类：<code>Foo</code>和<code>Foo_Bar</code>。另外，编译器会在<code>Foo</code>类下生成一个<code>typedef</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Foo_Bar Bar;</span><br></pre></td></tr></table></figure><p>这意味着您可以使用嵌套类型的类，就像它是嵌套类<code>Foo::Bar</code>一样。但是，请注意，<code>C++</code>不允许向前声明嵌套类型。如果要在另一个文件中转发声明并使用该声明，则必须将其标识为<code>Foo_Bar</code>。</p><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><p>除了上一节中描述的方法之外，<code>protocol</code>缓冲区编译器为<code>.proto</code>文件中的消息中定义的每个字段生成一组访问方法。</p><p>除了访问器方法之外，编译器还会为包含其字段编号的每个字段生成一个整数常量。常数名称是字母<code>k</code>，后跟字段名称转换为驼峰法，后跟<code>FieldNumber</code>。例如，给定该字段<code>optional int32 foo_bar = 5;</code>;编译器将生成常量<code>static const int kFooBarFieldNumber = 5;</code>。</p><p>对于返回<code>const</code>引用的字段访问器，当对消息进行下一个修改访问时，该引用可能会无效。这包括调用任何<code>const</code>字段的任何非访问者，通过其他方法（例如，使用该消息作为参数）调用<code>const</code>继承<code>Message</code>或修改消息的任何非方法<code>Swap()</code>。相应地，如果在此期间没有对消息进行任何修改访问，返回引用的地址只能在访问器的不同调用中保持相同。</p><p>对于返回指针的字段访问器，当对消息进行下一个修改或不修改访问时，该指针可能无效。这包括，不管<code>const</code>是什么，调用任何字段的任何访问者，<code>Message</code>通过其他方式调用继承或访问消息的任何方法（例如，通过使用复制构造函数复制消息）。相应地，返回的指针的值不能保证在访问器的两个不同调用中是相同的。</p><h4 id="Singular-Numeric-Fields-proto2"><a href="#Singular-Numeric-Fields-proto2" class="headerlink" title="Singular Numeric Fields (proto2)"></a>Singular Numeric Fields (proto2)</h4><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line">int32 foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line">void set_foo(int32 value)：设置字段的值。调用后，has_foo()将返回true并foo()返回value。</span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br></pre></td></tr></table></figure><p>对于其他数字字段类型（包括<code>bool</code>），<code>int32</code>将根据标量值类型表替换为相应的<code>C++</code>类型。</p><h4 id="Singular-Numeric-Fields-proto3"><a href="#Singular-Numeric-Fields-proto3" class="headerlink" title="Singular Numeric Fields (proto3)"></a>Singular Numeric Fields (proto3)</h4><p>对于此字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 foo() const：返回字段的当前值。如果未设置该字段，则返回0。</span><br><span class="line">void set_foo(int32 value)：设置字段的值。调用后，foo()会返回value。</span><br><span class="line">void clear_foo()：清除字段的值。调用这个之后，foo()会返回0。</span><br></pre></td></tr></table></figure><p>对于其他数字字段类型（包括<code>bool</code>），<code>int32</code>将根据标量值类型表替换为相应的<code>C++</code>类型。</p><h4 id="Singular-String-Fields-proto2"><a href="#Singular-String-Fields-proto2" class="headerlink" title="Singular String Fields (proto2)"></a>Singular String Fields (proto2)</h4><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：</span><br><span class="line">返回<span class="literal">true</span>是否设置了该字段。</span><br><span class="line"></span><br><span class="line">const string&amp; foo() const：</span><br><span class="line">返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：</span><br><span class="line">设置字段的值。调用后，has_foo()将返回<span class="literal">true</span>并foo()返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">使用C风格的以null结尾的字符串设置字段的值。调用后，has_foo()将返回<span class="literal">true</span>并foo()返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">返回指向可变<span class="built_in">string</span>对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空（而不是默认值）。调用它后，has_foo()将返回<span class="literal">true</span>并foo()返回任何写入给定字符串的值。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">将<span class="built_in">string</span>对象设置为字段，并释放前一个字段值（如果存在）。如果<span class="built_in">string</span>指针不是<span class="literal">NULL</span>，消息将获取所分配的<span class="built_in">string</span>对象的所有权并has_foo()返回<span class="literal">true</span>。否则，如果value是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">释放字段的所有权并返回<span class="built_in">string</span>对象的指针。调用该<span class="built_in">string</span>函数后，调用者将获取已分配对象的所有权，has_foo()将返回<span class="literal">false</span>，并foo()返回默认值。</span><br></pre></td></tr></table></figure><h4 id="Singular-String-Fields-proto3"><a href="#Singular-String-Fields-proto3" class="headerlink" title="Singular String Fields (proto3)"></a>Singular String Fields (proto3)</h4><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const string&amp; foo() const：返回字段的当前值。如果未设置该字段，则返回空字符串/空字节。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：设置字段的值。调用后，foo()会返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">使用C风格的以null结尾的字符串设置字段的值。调用后，foo()会返回一份value。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">返回指向可变<span class="built_in">string</span>对象的指针，该对象存储字段的值。如果在调用之前未设置该字段，则返回的字符串将为空。调用它之后，foo()将返回写入给定字符串的任何值。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。</span><br><span class="line">调用这个之后，foo()将返回空字符串/空字节。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">将<span class="built_in">string</span>对象设置为字段，并释放前一个字段值（如果存在）。如果<span class="built_in">string</span>指针不是<span class="literal">NULL</span>，该消息将占用所分配<span class="built_in">string</span>对象的所有权。否则，如果value是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">释放字段的所有权并返回<span class="built_in">string</span>对象的指针。调用该方法后，调用者将获取已分配<span class="built_in">string</span>对象的所有权，并foo()返回空字符串/空字节。</span><br></pre></td></tr></table></figure><h4 id="Singular-Enum-Fields-proto2"><a href="#Singular-Enum-Fields-proto2" class="headerlink" title="Singular Enum Fields (proto2)"></a>Singular Enum Fields (proto2)</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> Bar foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line"></span><br><span class="line">Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：设置字段的值。</span><br><span class="line">调用后，has_foo()将返回<span class="literal">true</span>并foo()返回value。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用它后，has_foo()将返回false并foo()返回默认值。</span><br></pre></td></tr></table></figure><h4 id="Singular-Enum-Fields-proto3"><a href="#Singular-Enum-Fields-proto3" class="headerlink" title="Singular Enum Fields (proto3)"></a>Singular Enum Fields (proto3)</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bar foo() const：返回字段的当前值。如果未设置该字段，则返回默认值（0）。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：设置字段的值。打电话后，foo()会返回value。</span><br><span class="line"></span><br><span class="line">void clear_foo()：清除字段的值。调用该命令后，foo()将返回默认值。</span><br></pre></td></tr></table></figure></p><h4 id="Singular-Embedded-Message-Fields"><a href="#Singular-Embedded-Message-Fields" class="headerlink" title="Singular Embedded Message Fields"></a>Singular Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于任何这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proto2</span></span><br><span class="line"><span class="keyword">optional</span> Bar foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//proto3</span></span><br><span class="line">Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：返回true是否设置了该字段。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo() const：</span><br><span class="line">返回字段的当前值。如果未设置该字段，则返回一个不设置Bar其字段（可能Bar::default_instance()）的字段。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo()：</span><br><span class="line">返回指向可变Bar对象的指针，该对象存储字段的值。如果在调用之前没有设置该字段，则返回Bar的字段将不会设置任何字段（即它将与新分配的相同Bar）。调用这个之后，has_foo()将返回<span class="literal">true</span>并foo()返回对同一个实例的引用Bar。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">清除字段的值。调用它后，has_foo()将返回<span class="literal">false</span>并foo()返回默认值。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(Bar* bar)：</span><br><span class="line">将Bar对象设置为字段，并释放前一个字段值（如果存在）。如果Bar指针不是<span class="literal">NULL</span>，消息将获取所分配的Bar对象的所有权并has_foo()返回<span class="literal">true</span>。否则，如果Bar是<span class="literal">NULL</span>，行为与调用相同clear_foo()。</span><br><span class="line"></span><br><span class="line">Bar* release_foo()：</span><br><span class="line">释放字段的所有权并返回Bar对象的指针。调用该Bar函数后，调用者将获取已分配对象的所有权，has_foo()将返回<span class="literal">false</span>，并foo()返回默认值。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Numeric-Fields"><a href="#Repeated-Numeric-Fields" class="headerlink" title="Repeated Numeric Fields"></a>Repeated Numeric Fields</h4><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">int32 foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, int32 value)：设置给定基于零的索引的元素的值。</span><br><span class="line"></span><br><span class="line">void add_foo(int32 value)：用给定的值追加一个新元素到该字段。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedField&lt;int32&gt;&amp; foo() <span class="keyword">const</span>：</span><br><span class="line">返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedField&lt;int32&gt;* mutable_foo()：</span><br><span class="line">返回指向RepeatedField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。对于其他数字字段类型（包括<span class="keyword">bool</span>），int32将根据标量值类型表替换为相应的C ++类型。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-String-Fields"><a href="#Repeated-String-Fields" class="headerlink" title="Repeated String Fields"></a>Repeated String Fields</h4><p>对于任一这些字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">const string&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const string&amp; value)：设置给定基于零的索引的元素的值。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const char* value)：使用C风格的以null结尾的字符串来设置给定基于零的索引处的元素的值。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo(int index)：返回一个指向可变string对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void add_foo(const string&amp; value)：用给定的值追加一个新元素到该字段。</span><br><span class="line"></span><br><span class="line">void add_foo(const char* value)：使用C风格的以null结尾的字符串向字段添加一个新元素。</span><br><span class="line"></span><br><span class="line">void add_foo(const char* value, int size)：像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* add_foo()：添加一个新的空字符串元素并返回一个指针。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedPtrField&lt;<span class="built_in">string</span>&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedPtrField&lt;<span class="built_in">string</span>&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Enum-Fields"><a href="#Repeated-Enum-Fields" class="headerlink" title="Repeated Enum Fields"></a>Repeated Enum Fields</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">Bar foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">void set_foo(int index, Bar value)：设置给定基于零的索引的元素的值。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void add_foo(Bar value)：用给定的值追加一个新元素到该字段。在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedField&lt;<span class="keyword">int</span>&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedField&lt;<span class="keyword">int</span>&gt;* mutable_foo()：返回指向RepeatedField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure></p><h4 id="Repeated-Embedded-Message-Fields"><a href="#Repeated-Embedded-Message-Fields" class="headerlink" title="Repeated Embedded Message Fields"></a>Repeated Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于此字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo_size() const：返回字段中当前的元素数。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo(int index) const：返回给定基于零的索引的元素。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo(int index)：返回一个指向可变Bar对象的指针，该对象在给定的基于零的索引处存储元素的值。使用[0，foo_size（））之外的索引调用此方法会产生未定义的行为。</span><br><span class="line"></span><br><span class="line">Bar* add_foo()：添加一个新元素并返回一个指针。返回的Bar将不会设置任何字段（即它将与新分配的相同Bar）。</span><br><span class="line"></span><br><span class="line">void clear_foo()：从字段中删除所有元素。调用后，foo_size()将返回零。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RepeatedPtrField&lt;Bar&gt;&amp; foo() <span class="keyword">const</span>：返回RepeatedPtrField存储字段元素的底层。这个容器类提供了类似STL的迭代器和其他方法。</span><br><span class="line"></span><br><span class="line">RepeatedPtrField&lt;Bar&gt;* mutable_foo()：返回指向RepeatedPtrField存储字段元素的底层<span class="keyword">mutable</span>的指针。这个容器类提供了类似STL的迭代器和其他方法。</span><br></pre></td></tr></table></figure><h4 id="Oneof-Numeric-Fields"><a href="#Oneof-Numeric-Fields" class="headerlink" title="Oneof Numeric Fields"></a>Oneof Numeric Fields</h4><p>对于这个oneof字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">int32</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">int32 foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(int32 value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value，并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果不是，情况不会改变kFoo。</span><br><span class="line">- 如果一个情况是kFoo，清除字段的值和一个<span class="keyword">case</span>。has_foo()（仅限proto2）将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><p>对于其他数字字段类型（包括bool）， int32将根据标量值类型表替换为相应的C ++类型。</p><h4 id="Oneof-String-Fields"><a href="#Oneof-String-Fields" class="headerlink" title="Oneof String Fields"></a>Oneof String Fields</h4><p>对于任何这些oneof字段定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">string</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">bytes</span> foo = <span class="number">1</span>;</span><br><span class="line">    ...。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">const string&amp; foo() const：如果一种情况，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(const string&amp; value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原始<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 使用C风格的空值终止的字符串设置字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原始<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void set_foo(const char* value, int size)：</span><br><span class="line">像上面一样，但是字符串大小是明确给出的，而不是通过寻找一个空终止符字节来确定。</span><br><span class="line"></span><br><span class="line">string* mutable_foo()：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- kFoo将一个<span class="keyword">case</span>设置为并返回一个指向可变字符串对象的指针，该对象存储字段的值。如果一个情况不在kFoo调用之前，则返回的字符串将为空（而不是默认值）。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回任何写入给定字符串的值，oneof_name_case()并返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是kFoo，任何事情都不会改变。</span><br><span class="line">- 如果一个案例是kFoo，释放字段并清除一个<span class="keyword">case</span>。has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(string* value)：</span><br><span class="line">- 电话clear_oneof_name()。</span><br><span class="line">- 如果字符串指针不是<span class="literal">NULL</span>：将字符串对象设置为字段并将其设置为一个kFoo。该消息将获取已分配的字符串对象的所有权，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>并oneof_name_case()返回kFoo。</span><br><span class="line">- 如果字符串指针是<span class="literal">NULL</span>，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">string* release_foo()：</span><br><span class="line">- <span class="literal">NULL</span>如果一个情况不是返回kFoo。</span><br><span class="line">- 清除一个情况，释放该字段的所有权并返回字符串对象的指针。调用这个之后，调用者占用所分配的字符串对象，has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">false</span>，foo()将返回默认值，并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><h4 id="Oneof-Enum-Fields"><a href="#Oneof-Enum-Fields" class="headerlink" title="Oneof Enum Fields"></a>Oneof Enum Fields</h4><p>给定枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Bar &#123;</span><br><span class="line">  BAR_VALUE = 0;</span><br><span class="line">  OTHER_VALUE = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于oneof字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof oneof_name &#123;</span><br><span class="line">    Bar foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const（仅限于proto2）：true如果一个情况下返回kFoo。</span><br><span class="line"></span><br><span class="line">Bar foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回默认值。</span><br><span class="line"></span><br><span class="line">void set_foo(Bar value)：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- 设置此字段的值，并将其中的一个设置为kFoo。</span><br><span class="line">- has_foo()（仅原型<span class="number">2</span>）将返回<span class="literal">true</span>，foo()将返回value并oneof_name_case()返回kFoo。</span><br><span class="line">- 在调试模式（即NDEBUG未定义）中，如果value与定义的任何值不匹配Bar，则此方法将中止该过程。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是，任何事情都不会改变kFoo。</span><br><span class="line">- 如果一个案例是kFoo，清除字段的值和一个<span class="keyword">case</span>。has_foo()（仅限proto2）将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure><h4 id="Oneof-Embedded-Message-Fields"><a href="#Oneof-Embedded-Message-Fields" class="headerlink" title="Oneof Embedded Message Fields"></a>Oneof Embedded Message Fields</h4><p>给定消息类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message Bar &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于oneof字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oneof oneof_name &#123;</span><br><span class="line">    Bar foo = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool has_foo() const：如果一个case返回true kFoo。</span><br><span class="line"></span><br><span class="line">const Bar&amp; foo() const：如果是一个case，则返回该字段的当前值kFoo。否则返回Bar::default_instance()。</span><br><span class="line"></span><br><span class="line">Bar* mutable_foo()：</span><br><span class="line">- 如果设置了同一个任何一个字段，则调用clear_oneof_name()。</span><br><span class="line">- kFoo将一个情况设置为并返回一个指向可变的Bar对象的指针，该对象存储该字段的值。如果一个情况不在kFoo调用之前，则返回的栏将不会设置任何字段（即它将与新分配的Bar相同）。</span><br><span class="line">- 调用这个之后，has_foo()会返回<span class="literal">true</span>，foo()将返回一个引用到同一个实例Bar并oneof_name_case()返回kFoo。</span><br><span class="line"></span><br><span class="line">void clear_foo()：</span><br><span class="line">- 如果一个案件不是，任何事情都不会改变kFoo。</span><br><span class="line">- 如果一个情况相等kFoo，则释放该字段并清除该情况。has_foo()将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br><span class="line"></span><br><span class="line">void set_allocated_foo(Bar* bar)：</span><br><span class="line">- 电话clear_oneof_name()。</span><br><span class="line">- 如果Bar指针不是<span class="literal">NULL</span>：将Bar对象设置为字段并将其设置为一个kFoo。该消息占用所分配的Bar对象，has_foo（）将返回<span class="literal">true</span>，而oneof_name_case（）将返回kFoo。</span><br><span class="line">- 如果指针是<span class="literal">NULL</span>，has_foo()将返回<span class="literal">false</span>并oneof_name_case()返回ONEOF_NAME_NOT_SET。（行为就像调用clear_oneof_name()）</span><br><span class="line"></span><br><span class="line">Bar* release_foo()：</span><br><span class="line">- <span class="literal">NULL</span>如果一个情况不是返回kFoo。</span><br><span class="line">- 如果一种情况是kFoo，清除一种情况，释放该字段的所有权并返回该Bar对象的指针。调用这个之后，调用者占用所分配的Bar对象，has_foo()将返回<span class="literal">false</span>，foo()将返回默认值并oneof_name_case()返回ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure></p><h4 id="Map-Fields"><a href="#Map-Fields" class="headerlink" title="Map Fields"></a>Map Fields</h4><p>对于此Map字段定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">int32</span>, <span class="built_in">int32</span>&gt; weight = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译器将生成以下访问器方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> google::protobuf::Map&lt;int32, int32&gt;&amp; weight();：返回一个不可变的Map。</span><br><span class="line">google::protobuf::Map&lt;int32, int32&gt;* mutable_weight();：返回一个可变的Map。</span><br></pre></td></tr></table></figure></p><p>一个<code>google::protobuf::Map</code>是用于存储映射字段的协议缓冲区中使用的特殊容器类型。从下面的界面可以看出，它使用常用的子集<code>std::map</code>和<code>std::unordered_map</code>方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T&gt; &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">  <span class="comment">// Member types</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> ... value_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterators</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> Key&amp; key);</span><br><span class="line">  <span class="function"><span class="keyword">const</span> T&amp; <span class="title">at</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lookup</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; value);</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>);</span></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp; Key)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy</span></span><br><span class="line">  Map(<span class="keyword">const</span> Map&amp; other);</span><br><span class="line">  Map&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Map&amp; other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加数据的最简单的方法是使用普通的地图语法，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ProtoName&gt; my_enclosing_proto(<span class="keyword">new</span> ProtoName);</span><br><span class="line">(*my_enclosing_proto-&gt;mutable_weight())[my_key] = my_value;</span><br></pre></td></tr></table></figure><p><code>pair&lt;iterator, bool&gt; insert(const value_type&amp; value)</code>将隐含地导致<code>value_type</code>实例的深层副本。将新值插入到一个最有效的方法<code>google::protobuf::Map</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> Key&amp; key): <span class="built_in">map</span>[new_key] = new_mapped;</span><br></pre></td></tr></table></figure><p>使用<code>google::protobuf::Map</code>标准<code>Map</code></p><p><code>google::protobuf::Map</code>支持相同的迭代器<code>API</code>的<code>std::map</code>和<code>std::unordered_map</code>。如果您不想<code>google::protobuf::Map</code>直接使用，可以<code>google::protobuf::Map</code>通过执行以下操作转换为标准<code>Map</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;int32, int32&gt; standard_map(message.weight().begin(),</span><br><span class="line">                                    message.weight().end());</span><br></pre></td></tr></table></figure><p>请注意，这将使整个Map的深层副本。</p><p>您还可以<code>google::protobuf::Map</code>按照以下方式从标准映射构建一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google::protobuf::Map&lt;int32, int32&gt; weight(standard_map.begin(), standard_map.end());</span><br></pre></td></tr></table></figure><p>解析未知值</p><p>在线上，<code>.proto</code>映射等效于每个<code>key/value</code>对的映射条目消息，而映射本身是映射条目的重复字段。像普通消息类型一样，解析的映射条目消息可能具有未知字段：例如，<code>int64</code>定义为映射的映射中的类型字段<code>map&lt;int32, string&gt;</code>。</p><p>如果Map条目消息的有线格式中有未知字段，则它们将被丢弃。</p><p>如果Map条目消息的有线格式中有一个未知的枚举值，那么它在<code>proto2</code>和<code>proto3</code>中的处理方式不同。在<code>proto2</code>中，将整个map条目消息放入包含消息的未知字段集中。在<code>proto3</code>中，它被放入一个映射字段，就像它是一个已知的枚举值一样。</p><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>给出一个<code>Any</code>这样的字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">  google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们生成的代码中，该<code>details</code>字段的<code>getter</code>返回一个实例<code>google::protobuf::Any</code>。这提供了以下特殊方法来打包和解压缩Any的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Packs the given message into this Any using the default type URL</span></span><br><span class="line">  <span class="comment">// prefix “type.googleapis.com”.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PackFrom</span><span class="params">(<span class="keyword">const</span> google::protobuf::Message&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packs the given message into this Any using the given type URL</span></span><br><span class="line">  <span class="comment">// prefix.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PackFrom</span><span class="params">(<span class="keyword">const</span> google::protobuf::Message&amp; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; type_url_prefix)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unpacks this Any to a Message. Returns false if this Any</span></span><br><span class="line">  <span class="comment">// represents a different protobuf type or parsing fails.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">UnpackTo</span><span class="params">(google::protobuf::Message* message)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if this Any represents the given protobuf type.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">Is</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><p>给定一个这样的定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oneof_name &#123;</span><br><span class="line">    <span class="built_in">int32</span> foo_int = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">string</span> foo_string = <span class="number">9</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将生成以下<code>C++</code>枚举类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum OneofNameCase &#123;</span><br><span class="line">  kFooInt = 4,</span><br><span class="line">  kFooString = 9,</span><br><span class="line">  ONEOF_NAME_NOT_SET = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，它会产生这种方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneofNameCase oneof_name_case() const：返回指定哪个字段被设置的枚举。ONEOF_NAME_NOT_SET如果没有设置它们返回。</span><br></pre></td></tr></table></figure></p><p>编译器还生成以下私有方法，它在一个字段访问器中使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clear_oneof_name()：如果一个字段集使用一个指针（Message或String），并设置一个case，则释放该对象ONEOF_NAME_NOT_SET。</span><br></pre></td></tr></table></figure><h3 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h3><p>给定一个枚举定义，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Foo &#123;</span><br><span class="line">  VALUE_A = 0;</span><br><span class="line">  VALUE_B = 5;</span><br><span class="line">  VALUE_C = 1234;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议缓冲区编译器将生成一个<code>Foo</code>使用相同值进行调用的<code>C++</code>枚举类型。此外，编译器将生成以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const EnumDescriptor* Foo_descriptor()：返回类型的描述符，其中包含有关此枚举类型定义的值的信息。</span><br><span class="line"></span><br><span class="line">bool Foo_IsValid(int value)：true如果给定的数值与其中一个Foo定义的值匹配，则返回。在上面的例子中，true如果输入为0,5或1234 ，则返回。</span><br><span class="line"></span><br><span class="line">const string&amp; Foo_Name(int value)：</span><br><span class="line">返回给定数值的名称。如果不存在这样的值，则返回一个空字符串。如果多个值具有此数字，则返回第一个定义的值。在上面的例子中，Foo_Name(<span class="number">5</span>)会返回<span class="string">"VALUE_B"</span>。</span><br><span class="line"></span><br><span class="line">bool Foo_Parse(const string&amp; name, Foo* value)：</span><br><span class="line">如果name是此枚举的有效值名称，则将该值分配value并返回<span class="literal">true</span>。否则返回<span class="literal">false</span>。在上面的例子中，Foo_Parse(<span class="string">"VALUE_C"</span>, &amp;someFoo)将返回<span class="literal">true</span>并设置someFoo为<span class="number">1234</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo Foo_MIN：枚举的最小有效值（示例中为VALUE_A）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo Foo_MAX：枚举的最大有效值（在示例中为VALUE_C）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Foo_ARRAYSIZE：总是定义为Foo_MAX + <span class="number">1</span>。</span><br></pre></td></tr></table></figure><blockquote><p>将整数转换为proto2枚举时要小心。 如果将整数转换为proto2枚举值，则该整数必须是枚举以外的有效值之一，否则结果可能未定义。如果有疑问，请使用生成的Foo_IsValid()函数来测试该转换是否有效。将proto2消息的枚举类型字段设置为无效值可能会导致断言失败。如果在解析proto2消息时读取一个无效的枚举值，它将被视为未知字段。这些语义在proto3中已经改变了。只要适用于int32，就可以将任何整数转换为proto3枚举值。在解析proto3消息并由枚举字段访问器返回时，也将保留无效的枚举值。</p><p>在switch语句中使用proto3枚举时要小心。Proto3枚举是打开的枚举类型，可能的值超出了指定符号的范围。在解析proto3消息并由枚举字段访问器返回时，将不会识别到枚举值。在没有默认情况下的proto3枚举上的switch语句将无法捕获所有情况，即使列出了所有已知字段。这可能会导致意外的行为，包括数据损坏和运行时崩溃。始终添加默认情况，或者Foo_IsValid(int)在交换机外部显式调用以处理未知的枚举值。</p></blockquote><p>您可以在消息类型中定义一个枚举。在这种情况下，协议缓冲区编译器会生成代码，使得它看起来是枚举类型本身被声明为嵌套在消息的类中。在Foo_descriptor()与Foo_IsValid()函数声明为静态方法。实际上，枚举类型本身及其值在全局范围内被声明为具有变量名称，并且通过typedef和一系列常量定义导入到类的范围内。这只是为了避免声明排序的问题。不要依赖于被破坏的顶级名称; 假装枚举真的嵌套在消息类中。</p><h3 id="Extensions-proto2-only"><a href="#Extensions-proto2-only" class="headerlink" title="Extensions (proto2 only)"></a>Extensions (proto2 only)</h3><p>给定一个扩展范围的消息：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  extensions 100 to 199;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该协议缓冲编译器将产生一些额外的方法<code>Foo</code>： <code>HasExtension()</code>，<code>ExtensionSize()</code>，<code>ClearExtension()</code>，<code>GetExtension()</code>，<code>SetExtension()</code>，<code>MutableExtension()</code>，<code>AddExtension()</code>，<code>SetAllocatedExtension()</code>和<code>ReleaseExtension()</code>。作为其第一参数，这些方法中的每一个都采用标识扩展字段的扩展标识符（如下所述）。剩余的参数和返回值与对于与扩展标识符相同类型的普通（非扩展）字段生成的相应存取器方法的参数和返回值完全相同。（<code>GetExtension()</code>对应于没有特殊前缀的访问器）</p><p>给定一个扩展定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> repeated_bar = <span class="number">124</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单个扩展字段<code>bar</code>，协议缓冲区编译器生成一个调用的扩展标识符 <code>bar</code>，您可以使用它们<code>Foo</code>的扩展访问器来访问此扩展，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">assert(!foo.HasExtension(bar));</span><br><span class="line">foo.SetExtension(bar, <span class="number">1</span>);</span><br><span class="line">assert(foo.HasExtension(bar));</span><br><span class="line">assert(foo.GetExtension(bar) == <span class="number">1</span>);</span><br><span class="line">foo.ClearExtension(bar);</span><br><span class="line">assert(!foo.HasExtension(bar));</span><br></pre></td></tr></table></figure><p>类似地，对于重复的扩展字段<code>repeated_bar</code>，编译器生成一个调用的扩展标识符<code>repeated_bar</code>，您也可以使用Foo扩展名的扩展名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSize; ++i) &#123;</span><br><span class="line">  foo.AddExtension(repeated_bar, i)</span><br><span class="line">&#125;</span><br><span class="line">assert(foo.ExtensionSize(repeated_bar) == kSize)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSize; ++i) &#123;</span><br><span class="line">  assert(foo.GetExtension(repeated_bar, i) == i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（扩展名标识符的确切实现是复杂的，涉及神奇使用模板 - 但是，您不需要担心扩展名标识符如何使用它们。）</p><p>扩展可以被声明为嵌套在另一种类型之内。例如，一个常见的模式是做这样的事情：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional Baz foo_ext = 124;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，扩展名标识符<code>foo_ext</code>被声明嵌套在里面<code>Baz</code>。可以使用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">Baz* baz = foo.MutableExtension(Baz::foo_ext);</span><br><span class="line">FillInMyBaz(baz);</span><br></pre></td></tr></table></figure><h3 id="Arena-Allocation"><a href="#Arena-Allocation" class="headerlink" title="Arena Allocation"></a>Arena Allocation</h3><p>Arena分配<br>是一个仅<code>C++</code>功能，可帮助您优化内存使用情况，并在使用协议缓冲区时提高性能。在您<code>.proto</code>的<code>C++</code>生成的代码中添加额外的代码来使用Arena分配。您可以在“Arena分配指南”中了解有关竞技场分配<code>API</code>的更多信息。</p><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>如果<code>.proto</code>文件包含以下行：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>然后，协议缓冲区编译器将根据本节中所述的文件中找到的服务定义生成代码。然而，所生成的代码可能是不期望的，因为它不与任何特定的<code>RPC</code>系统相关联，并且因此需要针对一个系统进行编码的更多级别的间接代码。如果您不希望生成此代码，请将此行添加到文件中：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果不给出上述任何一行，则该选项默认 <code>false</code>为通用服务已被弃用。（请注意，在2.4.0之前，该选项默认为<code>true</code>）</p><p>基于<code>.proto</code>语言服务定义的RPC系统应该提供插件来为系统生成代码。这些插件可能要求抽象服务被禁用，以便它们可以生成自己的同名的类。插件是新版本2.3.0（2010年1月）。</p><p>本节的其余部分描述了启用抽象服务时协议缓冲区编译器生成的内容。</p><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><p>给定服务定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service Foo &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">Bar</span><span class="params">(FooRequest)</span> <span class="title">returns</span><span class="params">(FooResponse)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议缓冲区编译器将生成一个类Foo来表示此服务。 Foo将为服务定义中定义的每个方法设置虚拟方法。在这种情况下，该方法Bar定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bar</span><span class="params">(RpcController* controller, <span class="keyword">const</span> FooRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                 FooResponse* response, Closure* done)</span></span>;</span><br></pre></td></tr></table></figure><p>参数等同于参数<code>Service::CallMethod()</code>，除了<code>method</code>参数是隐含的，<code>request</code>和<code>response</code>指定其确切类型。</p><p>这些生成的方法是虚的，但不是纯虚的。默认实现只需调用一个<code>controller-&gt;SetFailed()</code>错误消息，指示该方法未实现，然后调用回调<code>done</code>。实现自己的服务时，您必须对此生成的服务进行子类化，并根据需要实现其方法。</p><p>Foo子类Service接口。协议缓冲区编译器自动生成方法的实现Service如下：</p><ul><li>GetDescriptor：返回服务的ServiceDescriptor。</li><li>CallMethod：根据提供的方法描述符确定正在调用哪个方法，并直接调用它，将请求和响应消息对象降级到正确的类型。</li><li>GetRequestPrototype和GetResponsePrototype：返回给定方法的正确类型的请求或响应的默认实例。</li></ul><p>还会生成以下静态方法：</p><ul><li><code>static ServiceDescriptor descriptor()</code>：返回类型的描述符，其中包含有关此服务具有哪些方法及其输入和输出类型的信息。</li></ul><h4 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h4><p>协议缓冲区编译器还生成每个服务接口的“stub”实现，由客户端希望向执行服务的服务器发送请求使用。对于Foo服务（上），<code>Foo_Stub</code>将定义存根实现。与嵌套消息类型一样，使用<code>typedef Foo_Stub</code>也可以被称为<code>Foo::Stub</code>。</p><p>Foo_Stub是一个子类Foo也实现了以下方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo_Stub(RpcChannel* channel)：构造在给定通道上发送请求的新存根。</span><br><span class="line">Foo_Stub(RpcChannel* channel, ChannelOwnership ownership)：构造一个新的存根，在给定的通道上发送请求，并且可能拥有该通道。如果ownership是，Service::STUB_OWNS_CHANNEL当存根对象被删除时，它也会删除该通道。</span><br><span class="line">RpcChannel* channel()：返回此存根的通道，传递给构造函数。</span><br></pre></td></tr></table></figure></p><p>存根附加地将每个服务的方法实现为通道周围的包装器。调用一种方法简单地调用<code>channel-&gt;CallMethod()</code>。</p><p>协议缓冲库不包括RPC实现。但是，它包括将生成的服务类连接到您选择的任意任意RPC实现所需的所有工具。您只需要提供RpcChannel和的实现RpcController。有关service.h详细信息，请参阅文档。</p><h3 id="Plugin-Insertion-Points"><a href="#Plugin-Insertion-Points" class="headerlink" title="Plugin Insertion Points"></a>Plugin Insertion Points</h3><p>要扩展C ++代码生成器的输出的代码生成器插件可以使用给定的插入点名称插入以下类型的代码。除非另有说明，否则每个插入点都显示在.pb.cc文件和.pb.h文件中。</p><ul><li>includes：包含指令。</li><li>namespace_scope：属于文件包/命名空间但不在任何特定类中的声明。出现在所有其他命名空间范围代码之后。</li><li>global_scope：属于文件命名空间之外的顶层的声明。出现在文件的最后端。</li><li>class_scope:TYPENAME：属于消息类的成员声明。 TYPENAME是完整的原名，例如package.MessageType。在课后所有其他公开声明后出现。此插入点仅显示在.pb.h文件中。</li></ul><blockquote><p>不要生成依赖于标准代码生成器声明的私有类成员的代码，因为这些实现细节可能会在将来版本的协议缓冲区中更改。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> protobuf </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批处理git命令</title>
      <link href="/2017/07/13/%E6%89%B9%E5%A4%84%E7%90%86git%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/07/13/%E6%89%B9%E5%A4%84%E7%90%86git%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>每次更新博客，都需要输入大量指令来同步github，那么是否可以批处理这些命令使之自动之行？</p><p>当然可以。</p><a id="more"></a><p>比如，我在hexo文件夹下有hexo博客文件，那么我只需在此创建upload.sh文件并输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">git status</span><br><span class="line">git add -A</span><br><span class="line">git add -u</span><br><span class="line">git commit -m <span class="string">"Update at <span class="variable">$(date)</span>"</span></span><br><span class="line">git push origin master:mydesktop</span><br></pre></td></tr></table></figure><p>创建好之后，在git bash中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./upload.sh</span><br></pre></td></tr></table></figure><p>就会自动执行这一系列指令，省去了好多麻烦，敲一下，等待、喝杯咖啡、去个洗手间！！！</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="http://gubangzhong.cn/2016/11/09/git本地文件夹上传至github/">git本地文件夹上传至github</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows右键cmd</title>
      <link href="/2017/07/13/windows%E5%8F%B3%E9%94%AEcmd/"/>
      <url>/2017/07/13/windows%E5%8F%B3%E9%94%AEcmd/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在使用windows操作系统的时候，常常需要win+R打开cmd窗口，在此特记简单快捷方法如下：</p><p>按住shift键在指定文件夹下右击鼠标出现“在此处打开命令窗口(W)”，点击此，就会在指定文件夹下打开cmd。</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/28/Windows快捷键/">Windows文本快捷键</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>glog初步体验</title>
      <link href="/2017/07/13/glog%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/"/>
      <url>/2017/07/13/glog%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>最近看caffe源码，希望对源码中的每个知识点都吃透，遇到不会的记录。今天仅记录glog的一段测试代码，详细TBD。</p></blockquote><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog\logging.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">google::InitGoogleLogging(<span class="string">""</span>);</span><br><span class="line">google::SetLogDestination(google::GLOG_INFO, <span class="string">"./myInfo"</span>);</span><br><span class="line">LOG(INFO) &lt;&lt; <span class="string">"This is a message!"</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">CHECK_GT(a, <span class="number">3</span>) &lt;&lt; <span class="string">"a is little than 3!"</span>;</span><br><span class="line">google::ShutdownGoogleLogging();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Protobuf安装使用指南/">Protobuf安装使用指南</a></li><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> glog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类之虚函数,纯虚函数和普通函数</title>
      <link href="/2017/07/07/%E7%B1%BB%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2017/07/07/%E7%B1%BB%E4%B9%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本篇文章主要介绍了C++中的普通成员函数、虚函数以及纯虚函数,非常的详细，有需要的朋友可以参考下。</p></blockquote><p>普通成员函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数；</p><p>虚函数为了重载和多态的需要，在基类中定义的，即便定义为空；</p><p>纯虚函数是在基类中声明的虚函数，它可以再基类中有定义，且派生类必须定义自己的实现方法。</p><a id="more"></a><p>假设我们有三个类Person、Teacher、Student它们之间的关系如下：</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/class_virtual_function.png" alt="image"></p><p>类的关系图 </p><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo-1"></a>Demo-1</h3><p>根据这个类图，我们有下面的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OBJEDT_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __OBJEDT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> m_age; <span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age, <span class="keyword">const</span> <span class="built_in">string</span>&amp; title):</span><br><span class="line">        Person(name, age), m_title(title)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"职称："</span> &lt;&lt; m_title &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_title; <span class="comment">//职称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age, <span class="keyword">int</span> studyId): </span><br><span class="line">        Person(name, age), m_studyId(studyId)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"学号："</span> &lt;&lt; m_studyId &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> m_studyId;  <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//__OBJEDT_H__</span></span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person* pPerson = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">22</span>);</span><br><span class="line">    Teacher* pTeacher = <span class="keyword">new</span> Teacher(<span class="string">"李四"</span>, <span class="number">35</span>, <span class="string">"副教授"</span>);</span><br><span class="line">    Student* pStudent = <span class="keyword">new</span> Student(<span class="string">"王五"</span>, <span class="number">18</span>, <span class="number">20151653</span>);</span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pPerson;</span><br><span class="line">    <span class="keyword">delete</span> pTeacher;</span><br><span class="line">    <span class="keyword">delete</span> pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br>这里的ShowInfo就是一个普通的函数。pPerson、pTeacher和pStudent三个对象调用ShowInfo分别展示自己的信息。<br>我们知道：父类的指针是可以指向子类的对象的。我们把上面的测试代码稍微改一下： </p></blockquote><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo-2"></a>Demo-2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18</span><br></pre></td></tr></table></figure><p>这时，pTeacher和pStudent只输出了姓名和年龄，并没有输出子类所具有的特性(职称和学号)。</p><p>这应该不是你期望的结果，你可能期望pTeacher和pStudent输出老师和学生的完整信息，这时就需要用虚函数。</p><p>虚函数</p><p>我们把Person中的ShowInfo成员改成虚函数(在前面加上virtual)，代码如下： </p><h3 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo-3"></a>Demo-3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual void ShowInfo()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    string m_name; //姓名</span><br><span class="line">    int m_age; //年龄</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行上面[Demo-2]中的测试代码，得到我们想到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：22</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：35 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：18 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><blockquote><p>虚函数用法要点：</p><ol><li>虚函数的声明方式：virtual RETURN_TYPE functionName(ARGS 参数列表);</li><li>虚函数作用：现实C++中的多态，进行动态绑定(父类指针可指向子类的对象)，直到运行时才知道要调用哪个版本(哪个类定义)的函数；</li><li>我们必要对虚函数进行定义；</li><li>一旦父类的成员函数声明virtual，其子类的函数不管有没有声明为virtual，都是虚函数；</li><li>如果虚函数使用默认实参，父类和子类定义的默认实参最好一致。</li></ol></blockquote><h3 id="Demo-4"><a href="#Demo-4" class="headerlink" title="Demo-4"></a>Demo-4</h3><p>针对第4点说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; name, int age) : m_name(name), m_age(age)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual void ShowInfo()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string GetName(); //正确，普通函数如果不被使用，可以只有声明没有定义</span><br><span class="line">    virtual int GetAge(); //错误，虚函数必须要有定义，即使是一个空实现,因为编译器无法确定会使用哪个函数</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    string m_name; //姓名</span><br><span class="line">    int m_age; //年龄</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Demo-5"><a href="#Demo-5" class="headerlink" title="Demo-5"></a>Demo-5</h3><p>针对第5点进行说明：<br>设计我们的类如下定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 0)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Teacher : public Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 1)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : public Person&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void SetAge(int age = 2)&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>测试1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Teacher* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Student* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;SetAge();</span><br><span class="line">    pTeacher-&gt;SetAge();</span><br><span class="line">    pStudent-&gt;SetAge();</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：0</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：1 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：2 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><p>测试2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;SetAge();</span><br><span class="line">    pTeacher-&gt;SetAge();</span><br><span class="line">    pStudent-&gt;SetAge();</span><br><span class="line">    </span><br><span class="line">    pPerson-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pTeacher-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;ShowInfo();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pPerson;</span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 </span><br><span class="line">年龄：0</span><br><span class="line"></span><br><span class="line">姓名：李四 </span><br><span class="line">年龄：0 </span><br><span class="line">职称：副教授</span><br><span class="line"></span><br><span class="line">姓名：王五 </span><br><span class="line">年龄：0 </span><br><span class="line">学号：20151653</span><br></pre></td></tr></table></figure><p>纯虚函数<br>在上面的例子中，我们假设所有的人都要工作，但不同的人工作的方式不同。</p><p>于是我们就要强制要求继承自Person的子类都要有工作的方法，这就需要纯虚函数。</p><p>定义如下： </p><h3 id="Demo-6"><a href="#Demo-6" class="headerlink" title="Demo-6"></a>Demo-6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork() = 0;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但此时我们编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person* pPerson = new Person(&quot;张三&quot;, 22);</span><br></pre></td></tr></table></figure><p>这句话时会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C2259: ‘Person&apos; : cannot instantiate abstract class</span><br></pre></td></tr></table></figure></p><p>这是因为我们并没有为Person实现DoWork方法，而包含纯虚函数的类是一个抽象的类，抽象类不能被实例化。</p><p>于是我们在子类中对它实现如下： </p><h3 id="Demo-7"><a href="#Demo-7" class="headerlink" title="Demo-7"></a>Demo-7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Teacher : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;教书...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Student : public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //... 省略</span><br><span class="line">    virtual void DoWork()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;学习...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //... 省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没用DoWork方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    Person* pTeacher = new Teacher(&quot;李四&quot;, 35, &quot;副教授&quot;);</span><br><span class="line">    Person* pStudent = new Student(&quot;王五&quot;, 18, 20151653);</span><br><span class="line">    </span><br><span class="line">    pTeacher-&gt;DoWork();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pStudent-&gt;DoWork();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    delete pTeacher;</span><br><span class="line">    delete pStudent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">教书…</span><br><span class="line">学习…</span><br></pre></td></tr></table></figure><p>纯虚函数用法要点：</p><p>纯虚函数的声明方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual RETURN_TYPE functionName(ARGS 参数列表) = 0;</span><br></pre></td></tr></table></figure></p><p>含有纯虚函数的类是一个抽象的类，抽象类不能被实例化。</p><p>包含纯虚函数的抽象类常用来当作对外的接口，说明这个类有什么功能，而没有具体的实现，基体的实现交由子类完成。</p><p>通过以上对普通成员函数、虚函数以及纯虚函数的介绍，希望可以对大家有所帮助。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>原文链接<a href="http://www.jb51.net/article/69811.htm" target="_blank" rel="noopener">C++之普通成员函数、虚函数以及纯虚函数的区别与用法要点</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>白衬衫</title>
      <link href="/2017/07/06/%E7%99%BD%E8%A1%AC%E8%A1%AB/"/>
      <url>/2017/07/06/%E7%99%BD%E8%A1%AC%E8%A1%AB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>袁野夕的《白衬衫》</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=478057166&auto=0&height=66"></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 袁野夕 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VS创建动态链接库DLL</title>
      <link href="/2017/07/06/VS%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/"/>
      <url>/2017/07/06/VS%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>官网链接：<a href="https://msdn.microsoft.com/zh-cn/library/ms235636.aspx" target="_blank" rel="noopener">演练：创建和使用动态链接库 (C++)</a></p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visual studio </tag>
            
            <tag> dll </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>matlab中的P代码</title>
      <link href="/2017/06/23/matlab%E4%B8%AD%E7%9A%84P%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/06/23/matlab%E4%B8%AD%E7%9A%84P%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><p>简单来说就是matlab中的加密代码，比M文件的优先级高，在和M文件同时存在时，优先调用P文件。</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一别经年</title>
      <link href="/2017/06/20/%E4%B8%80%E5%88%AB%E7%BB%8F%E5%B9%B4/"/>
      <url>/2017/06/20/%E4%B8%80%E5%88%AB%E7%BB%8F%E5%B9%B4/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>半夜，被鼻炎折磨，以致于睡不着，辗转反侧，手机本是放下复又拿起。APP翻来覆去，直至终于没啥可看。</p><p>半夜，总是怀念。</p><a id="more"></a><p>这学期没回过家，端午假期，于是早就计划利用假期回一趟。开始一切都好，而后母亲大人告诉我你陪你爸去医院看看，才知道父亲身体出了点状况。人到中年，难免会有这样或那样的病，作为人子而且是独生子女听到这样的话有点慌，毕竟没有经历过。焦躁，无助。正是农忙时，家里早已没有地了，只有屋前屋后的菜地，平时上班的父母还折腾点农作物，恰逢农忙，父亲执意要等农忙之后再去看。其实没啥可忙，就那点地，用我的话说，这还没你们一天的工资多呢。作为从那个年代走过来的父亲，多少会对我的言语反感，其实我也是关心则乱。无奈，本来在家甩手掌柜的我，也操起家伙帮他把作物收上来。用父亲的话说，他不弄，等他做完手术只有我妈一个人弄，她哪弄得过来，上班那么累。父亲还是心疼母亲的。于是执意倔强在手术前把该弄的弄好了。为此，我不得不延长假期。工作日就陪父亲去医院，医生说了手术，意料之中。于是就准备着，其实我也不知道准备什么，第一次经历。尽管医生说小手术，但还是担心，后来看是多余的。第一天手术叫了叔伯过来帮忙看着点，从进手术室开始无奈心慌，母亲也请了假，不知道她当时的心理。一小时过后，医生出来，手术顺利。期间我跑上跑下忙来忙去缓解自己紧张的情绪。后来就是漫长的陪床，也有埋怨父母不早点来看。后来静下来想想，又没多说什么，多说无益。总之，这个假期的经历难忘。父亲第三天就能下地慢慢走动了，于是父母开始催我回学校。用室友的话说，谁不心疼自己的孩子。而怕母亲忙不过来，所以一直待到快出院才回南京。父母年纪越大，开始越像小孩。我们之间的角色开始慢慢对调。这时，才感觉父母老了，头上已经有了白发，岁月无情镌刻了道道皱纹。此时才真正理解朱自清的背影所要表达的情感。</p><p><img src="http://o7cub0jo9.bkt.clouddn.com/beiying_zhuziqing.jpg" alt="背影"></p><p>一别经年，曾是少年。</p><p>快到而立之年的我，难免怅然若失。身边好友一个个成家立业，回头看看自己，还在为自己心中的那点执着奋斗。现在回想，其实读不读这个博士都没有关系，工作只是工作，人还有其他追求。有时我走在路上，透过镜片看人来人往，有时也会想这个合适吗，然后擦肩而过。</p><p>习惯独来独往之后，可以肆无忌惮做想做的事，比如死宅。死宅之后，看了好多电影，弹了好多首歌，最后又吃了好多外卖。于是在体重飙升之后，又急忙开始跑步减肥。美其名曰，锻炼身体。于是开始收集网上的教程，指望能够毕其功于一役。可是，哪有这么美得好事。凡事因果，总有轮回。最近异形上映了，筹划着去看啊，然后瞅着一个人去没意思就没有然后了。有时，也会更新博客，想记录点滴，提笔忘词，遂又作罢，本来生活博客硬是写成了技术札记。也算是小有所得，无心插柳。</p><p>现在应该三更天了吧，鼻炎折磨好多了，明天应该快好了吧，俗话病来如山倒。<br>外面还有三两毕业生在说话，以前的我大概也是这样。一别经年，三号路，下马坊，你曾是少年。</p><p>丁酉丙午戊寅仅此小记聊慰长夜。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>visio安装配套</title>
      <link href="/2017/06/15/visio%E5%AE%89%E8%A3%85%E9%85%8D%E5%A5%97/"/>
      <url>/2017/06/15/visio%E5%AE%89%E8%A3%85%E9%85%8D%E5%A5%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>某由于实验室电脑即将坏掉，赶紧在自己的电脑上装上office套装，奈何以前装了好多次，好多流程还得重复试一遍，特此笔记，原谅老年人的健忘症。</p><p>由于是在学校，很多东西有学校特供版本，免去查找各种破解工具，某在学校微软正版化下载office 2013 professional plus安装后，不知道该装2013 32位还是64位版本，经测试之后，需下载32位版本进行安装。</p><p>好了，装完用学校的激活工具激活就可以开心的写论文了！！！👏👏👏👏👏👏👏👏</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> visio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chrome油猴脚本</title>
      <link href="/2017/06/13/Chrome%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"/>
      <url>/2017/06/13/Chrome%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>跑程序之间，给大家推荐一个小程序，叫<a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">油猴脚本</a>，这是应用在浏览器中的脚本，很方便，安装很简单，在此不作介绍。</p><p>说说优点吧，可以跳过视频广告，可以直接观看VIP视频，还有诸多好处等你发现！！！！！！</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://LorrinWWW.github.io/posts/projet-enjeu-plugin-chrome-101/">Chrome插件开发 - Hello world</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows10安装多版本Python</title>
      <link href="/2017/06/11/Windows10%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACPython/"/>
      <url>/2017/06/11/Windows10%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACPython/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文主要简要记录在同一台windows10系统的电脑上安装多版本python用于科学计算。</p><a id="more"></a><blockquote><p>记录主要服务以后。</p></blockquote><p>由于anaconda集成了大量的python库，所以在此用anaconda代替。</p><p>在<a href="https://www.continuum.io/downloads/" target="_blank" rel="noopener">anaconda官网</a>下载最新的64位版本并安装，直到本文开始，python版本为3.6，注意：在安装过程中勾选上conda添加到系统路径以及python作为系统默认python版本。</p><p>上面这一步很简单，接下来完全是命令行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为python35的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.5.x中的最新版本）</span></span><br><span class="line">conda create -n python35 python=3.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用如下命令安装所有conda包</span></span><br><span class="line">conda create -n python35 python=3.5 anaconda</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装好后，使用activate激活某个环境</span></span><br><span class="line">activate python35 <span class="comment"># for Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想返回默认的python 3.6环境，运行</span></span><br><span class="line">deactivate python35 <span class="comment"># for Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个已有的环境</span></span><br><span class="line">conda remove --name python35 --all</span><br></pre></td></tr></table></figure><p>就是如此简单，如果需要安装2.7版本也一样。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://python.jobbole.com/86236/" target="_blank" rel="noopener">Anaconda使用总结</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/11/23/在python下利用opencv读取图片/">在python下利用opencv读取图片</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>邂逅日本</title>
      <link href="/2017/05/15/%E9%82%82%E9%80%85%E6%97%A5%E6%9C%AC/"/>
      <url>/2017/05/15/%E9%82%82%E9%80%85%E6%97%A5%E6%9C%AC/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><a id="more"></a><p>借开会时机，日本一游。</p><p>历史原因，本人对日本并无好感，总认为是一个无廉耻的民族。经此一游，某些方面改变自己的认识，从短暂的几天经历来说，至少日本人在表面上做的还是值得称赞的。我这里说表面上，因为时间短暂，不敢下最终结论，可能他们仅仅表现在表面上。如《菊与刀》所述，他们的另一面在短暂的时间里并不能完全体会到。</p><p>先这样吧，工作时间到了。</p>]]></content>
      
      <categories>
          
          <category> 追忆脚步 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>caffe学习资料收集</title>
      <link href="/2017/04/25/caffe%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>/2017/04/25/caffe%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>一些有关caffe的资料收集，不定期更新！</p></blockquote><a id="more"></a><h3 id="simshang博客"><a href="#simshang博客" class="headerlink" title="simshang博客"></a>simshang博客</h3><ol><li><a href="http://simtalk.cn/2016/11/25/FCN-in-Caffe/" target="_blank" rel="noopener">FCN in Caffe</a></li><li><a href="http://simtalk.cn/2016/11/01/Fully-Convolutional-Networks/" target="_blank" rel="noopener">Fully Convolutional Networks</a></li><li><a href="http://simtalk.cn/2016/10/28/PyCaffe-in-Practice/" target="_blank" rel="noopener">PyCaffe in Practice</a></li></ol><h3 id="caffe如何自定义网络以及自定义层python版"><a href="#caffe如何自定义网络以及自定义层python版" class="headerlink" title="caffe如何自定义网络以及自定义层python版"></a>caffe如何自定义网络以及自定义层python版</h3><ol><li><a href="http://blog.csdn.net/langb2014/article/details/53081911" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（一）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53168473" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（二）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53258721" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（三）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53261179" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（四）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53309618" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（五）</a></li><li><a href="http://blog.csdn.net/langb2014/article/details/53406491" target="_blank" rel="noopener">caffe如何自定义网络以及自定义层（python）（六）</a></li></ol><h3 id="Caffe学习记录"><a href="#Caffe学习记录" class="headerlink" title="Caffe学习记录"></a>Caffe学习记录</h3><ol><li><a href="http://www.cnblogs.com/denny402/p/5041060.html" target="_blank" rel="noopener">caffe windows 学习第一步：编译和安装（vs2012+win 64)</a></li><li><a href="http://www.cnblogs.com/denny402/p/5041122.html" target="_blank" rel="noopener">caffe windows学习：第一个测试程序</a></li><li><a href="http://www.cnblogs.com/denny402/p/5067265.html" target="_blank" rel="noopener">Caffe学习系列(1)：安装配置ubuntu14.04+cuda7.5+caffe+cudnn</a></li><li><a href="http://www.cnblogs.com/denny402/p/5070928.html" target="_blank" rel="noopener">Caffe学习系列(2)：数据层及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5071126.html" target="_blank" rel="noopener">Caffe学习系列(3)：视觉层（Vision Layers)及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5072507.html" target="_blank" rel="noopener">Caffe学习系列(4)：激活层（Activiation Layers)及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5072746.html" target="_blank" rel="noopener">Caffe学习系列(5)：其它常用层及参数</a></li><li><a href="http://www.cnblogs.com/denny402/p/5073427.html" target="_blank" rel="noopener">Caffe学习系列(6)：Blob,Layer and Net以及对应配置文件的编写</a></li><li><a href="http://www.cnblogs.com/denny402/p/5074049.html" target="_blank" rel="noopener">Caffe学习系列(7)：solver及其配置</a></li><li><a href="http://www.cnblogs.com/denny402/p/5074212.html" target="_blank" rel="noopener">Caffe学习系列(8)：solver优化方法</a></li><li><a href="http://www.cnblogs.com/denny402/p/5075490.html" target="_blank" rel="noopener">Caffe学习系列(9)：运行caffe自带的两个简单例子</a></li><li><a href="http://www.cnblogs.com/denny402/p/5076285.html" target="_blank" rel="noopener">Caffe学习系列(10)：命令行解析</a></li><li><a href="http://www.cnblogs.com/denny402/p/5082341.html" target="_blank" rel="noopener">Caffe学习系列(11)：图像数据转换成db（leveldb/lmdb)文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5083300.html" target="_blank" rel="noopener">Caffe学习系列(12)：训练和测试自己的图片</a></li><li><a href="http://www.cnblogs.com/denny402/p/5088399.html" target="_blank" rel="noopener">Caffe学习系列(13)：数据可视化环境（python接口)配置</a></li><li><a href="http://www.cnblogs.com/denny402/p/5092075.html" target="_blank" rel="noopener">Caffe学习系列(14)：初识数据可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5102328.html" target="_blank" rel="noopener">Caffe学习系列(15)：计算图片数据的均值</a></li><li><a href="http://www.cnblogs.com/denny402/p/5103425.html" target="_blank" rel="noopener">Caffe学习系列(16)：caffemodel可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5105911.html" target="_blank" rel="noopener">Caffe学习系列(17)：模型各层数据和参数可视化</a></li><li><a href="http://www.cnblogs.com/denny402/p/5106764.html" target="_blank" rel="noopener">Caffe学习系列(18): 绘制网络模型</a></li><li><a href="http://www.cnblogs.com/denny402/p/5110204.html" target="_blank" rel="noopener">Caffe学习系列(19): 绘制loss和accuracy曲线</a></li><li><a href="http://www.cnblogs.com/denny402/p/5111018.html" target="_blank" rel="noopener">Caffe学习系列(20)：用训练好的caffemodel来进行分类</a></li><li><a href="http://www.cnblogs.com/denny402/p/5136155.html" target="_blank" rel="noopener">Caffe学习系列(21)：caffe图形化操作工具digits的安装与运行</a></li><li><a href="http://www.cnblogs.com/denny402/p/5136262.html" target="_blank" rel="noopener">Caffe学习系列(22)：caffe图形化操作工具digits运行实例</a></li><li><a href="http://www.cnblogs.com/denny402/p/5137534.html" target="_blank" rel="noopener">Caffe学习系列(23)：如何将别人训练好的model用到自己的数据上</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679037.html" target="_blank" rel="noopener">caffe的python接口学习（1）：生成配置文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679154.html" target="_blank" rel="noopener">caffe的python接口学习（2）：生成solver文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5679204.html" target="_blank" rel="noopener">caffe的python接口学习（3）：训练模型（training)</a></li><li><a href="http://www.cnblogs.com/denny402/p/5684431.html" target="_blank" rel="noopener">caffe的python接口学习（4）：mnist实例—手写数字识别</a></li><li><a href="http://www.cnblogs.com/denny402/p/5685818.html" target="_blank" rel="noopener">caffe的python接口学习（5）：生成deploy文件</a></li><li><a href="http://www.cnblogs.com/denny402/p/5685909.html" target="_blank" rel="noopener">caffe的python接口学习（6）：用训练好的模型（caffemodel）来分类新的图片</a></li><li><a href="http://www.cnblogs.com/denny402/p/5686067.html" target="_blank" rel="noopener">caffe的python接口学习（7）：绘制loss和accuracy曲线</a></li><li><a href="http://www.cnblogs.com/denny402/p/5686257.html" target="_blank" rel="noopener">caffe的python接口学习（8）：caffemodel中的参数及特征的抽取</a></li></ol><h3 id="caffe代码阅读"><a href="#caffe代码阅读" class="headerlink" title="caffe代码阅读"></a>caffe代码阅读</h3><ol><li><a href="http://blog.csdn.net/xizero00/article/details/50886829" target="_blank" rel="noopener">caffe代码阅读1：blob的实现细节-2016.3.14</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50889126" target="_blank" rel="noopener">caffe代码阅读2：common的实现细节-2016.3.14</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50901204" target="_blank" rel="noopener">caffe代码阅读3：data_reader、internalthread以及blocking_queue的实现细节-2016.3.15</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50905685" target="_blank" rel="noopener">caffe代码阅读4：DataTransformer以及io的实现细节-2016.3.16</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50914471" target="_blank" rel="noopener">caffe代码阅读5：Layer的实现细节-2016.3.17</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50921692" target="_blank" rel="noopener">caffe代码阅读6：Filler的实现细节-2016.3.18</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50923722" target="_blank" rel="noopener">caffe代码阅读7：LayerRegistry的实现细节-2016.3.18</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/50999630" target="_blank" rel="noopener">caffe代码阅读8: Data_layers的实现细节（各个数据读取层的实现细节） 2016.3.25-28</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/51001206" target="_blank" rel="noopener">caffe代码阅读9：SyncedMemory的实现细节-2016.3.28</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/51049858" target="_blank" rel="noopener">caffe代码阅读10：Caffe中卷积的实现细节（涉及到BaseConvolutionLayer、ConvolutionLayer、im2col等）-2016.4.3</a></li><li><a href="http://blog.csdn.net/xizero00/article/details/52228425" target="_blank" rel="noopener">Caffe代码阅读11：absval_layer层的实现</a></li><li><a href="http://blog.csdn.net/u010402786/article/details/51262004" target="_blank" rel="noopener">Caffe各版本与源码全透析</a></li></ol><h3 id="大魔导师：从零开始山寨caffe"><a href="#大魔导师：从零开始山寨caffe" class="headerlink" title="大魔导师：从零开始山寨caffe"></a>大魔导师：从零开始山寨caffe</h3><ol><li><a href="http://www.cnblogs.com/neopenx/p/5187440.html" target="_blank" rel="noopener">从零开始山寨Caffe·零：必先利其器</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5187586.html" target="_blank" rel="noopener">从零开始山寨Caffe·壹：仰望星空与脚踏实地</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5190282.html" target="_blank" rel="noopener">从零开始山寨Caffe·贰：主存模型</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5194224.html" target="_blank" rel="noopener">从零开始山寨Caffe·叁：全局线程管理器</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5200519.html" target="_blank" rel="noopener">从零开始山寨Caffe·肆：线程系统</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5243188.html" target="_blank" rel="noopener">从零开始山寨Caffe·伍：Protocol Buffer简易指南</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5248102.html" target="_blank" rel="noopener">从零开始山寨Caffe·陆：IO系统(一)</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5269852.html" target="_blank" rel="noopener">从零开始山寨Caffe·柒：KV数据库</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5259197.html" target="_blank" rel="noopener">从零开始山寨Caffe·捌：IO系统(二)</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5294682.html" target="_blank" rel="noopener">从零开始山寨Caffe·玖：BlobFlow</a></li><li><a href="http://www.cnblogs.com/neopenx/p/5315945.html" target="_blank" rel="noopener">从零开始山寨Caffe·拾：IO系统(三)</a></li><li><p><a href="http://www.cnblogs.com/neopenx/p/5322722.html" target="_blank" rel="noopener">从零开始山寨Caffe·拾贰：IO系统(四)</a></p></li><li><p><a href="http://blog.csdn.net/dengbingfeng/article/details/51469051" target="_blank" rel="noopener">caffe使用gdb单步调试及源码阅读</a></p></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51089864" target="_blank" rel="noopener">（Caffe，LeNet）IDE单步调试（一）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090114" target="_blank" rel="noopener">（Caffe，LeNet）网络训练流程（二）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090306" target="_blank" rel="noopener">（Caffe，LeNet）初始化训练网络（三）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51090698" target="_blank" rel="noopener">（Caffe，LeNet）初始化测试网络（四）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51092906" target="_blank" rel="noopener">（Caffe，LeNet）前向计算（五）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51379395" target="_blank" rel="noopener">（Caffe，LeNet）反向传播（六）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51588773" target="_blank" rel="noopener">（Caffe，LeNet）权值更新（七）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51085654" target="_blank" rel="noopener">（Caffe）基本类Blob，Layer，Net（一）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088173" target="_blank" rel="noopener">（Caffe）基本类Solver、Caffe、Batch（二）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088262" target="_blank" rel="noopener">（Caffe）基本类InternalThread（三）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51088361" target="_blank" rel="noopener">（Caffe）基本类DataReader、QueuePair、Body（四）</a></li><li><a href="http://blog.csdn.net/mounty_fsc/article/details/51699568" target="_blank" rel="noopener">（Caffe）基本类Filter（五）</a></li></ol><h3 id="知乎专栏：黑客与画家"><a href="#知乎专栏：黑客与画家" class="headerlink" title="知乎专栏：黑客与画家"></a>知乎专栏：黑客与画家</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/20377462" target="_blank" rel="noopener">深度学习源码解读-ch0-talk is cheap</a></li><li><a href="https://zhuanlan.zhihu.com/p/20399370" target="_blank" rel="noopener">深度学习源码解读-ch1-JSON is awesome</a></li><li><a href="https://zhuanlan.zhihu.com/p/20456504" target="_blank" rel="noopener">深度学习源码解读-ch3-部署 Caffe 网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/20456649" target="_blank" rel="noopener">深度学习源码解读-ch4-Caffe 中的设计模式</a></li></ol><h3 id="知乎专栏：无痛的机器学习"><a href="#知乎专栏：无痛的机器学习" class="headerlink" title="知乎专栏：无痛的机器学习"></a>知乎专栏：无痛的机器学习</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/21796890" target="_blank" rel="noopener">Caffe代码阅读——层次结构</a></li><li><a href="https://zhuanlan.zhihu.com/p/21875025" target="_blank" rel="noopener">Caffe源码阅读——Net组装</a></li><li><a href="https://zhuanlan.zhihu.com/p/21800004" target="_blank" rel="noopener">Caffe代码阅读——Solver</a></li><li><a href="https://zhuanlan.zhihu.com/p/22404295" target="_blank" rel="noopener">Caffe源码阅读——DataLayer&amp;Data Transformer</a></li></ol><h3 id="知乎专栏：晓雷机器学习笔记"><a href="#知乎专栏：晓雷机器学习笔记" class="headerlink" title="知乎专栏：晓雷机器学习笔记"></a>知乎专栏：晓雷机器学习笔记</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/25127756" target="_blank" rel="noopener">caffe源码解析-开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/25094900" target="_blank" rel="noopener">caffe源码解析-命令行接口</a></li><li><a href="https://zhuanlan.zhihu.com/p/25102232" target="_blank" rel="noopener">caffe源码解析-solver_factory</a></li></ol><h3 id="Caffe-Source-Code-Analysis"><a href="#Caffe-Source-Code-Analysis" class="headerlink" title="Caffe Source Code Analysis"></a><a href="https://buptldy.github.io/2016/10/09/2016-10-09-Caffe_Code/" target="_blank" rel="noopener">Caffe Source Code Analysis</a></h3><h3 id="CSDN博客：joshua-1988"><a href="#CSDN博客：joshua-1988" class="headerlink" title="CSDN博客：joshua_1988"></a>CSDN博客：<a href="http://blog.csdn.net/joshua_1988" target="_blank" rel="noopener">joshua_1988</a></h3><ol><li><a href="http://blog.csdn.net/joshua_1988/article/details/45036993" target="_blank" rel="noopener">VS2013配置Caffe卷积神经网络工具（64位Windows 7）——准备依赖库</a></li><li><a href="http://blog.csdn.net/joshua_1988/article/details/45048871" target="_blank" rel="noopener">VS2013配置Caffe卷积神经网络工具（64位Windows 7）——建立工程</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世界末日</title>
      <link href="/2017/04/22/%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5/"/>
      <url>/2017/04/22/%E4%B8%96%E7%95%8C%E6%9C%AB%E6%97%A5/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>翻微博突然听见这首歌，有点感慨。网易没有外链，找了个视频。</p></blockquote><a id="more"></a><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=v0108qjz2c7&tiny=0&auto=0" allowfullscreen></iframe>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周杰伦 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>电脑崩了之后hexo的处置</title>
      <link href="/2017/04/21/%E7%94%B5%E8%84%91%E5%B4%A9%E4%BA%86%E4%B9%8B%E5%90%8Ehexo%E7%9A%84%E5%A4%84%E7%BD%AE/"/>
      <url>/2017/04/21/%E7%94%B5%E8%84%91%E5%B4%A9%E4%BA%86%E4%B9%8B%E5%90%8Ehexo%E7%9A%84%E5%A4%84%E7%BD%AE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>电脑崩溃之后，要重新更新博客是个麻烦的事，以下是个人的历程，现记录下来。</p></blockquote><a id="more"></a><p>既然电脑崩溃了，那么第一步是重新安装git和node.js。</p><p>之后初始化git，设置ssh并添加到github中。</p><p>另寻地方，新建文件夹Hexo。</p><p>右击git bash here。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>将以前保存在github中的源文件下载下来，复制到Hexo文件夹中。</p><p>接下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">npm install hexo-util --save</span><br></pre></td></tr></table></figure><p>这样就可以进行上传到github pages中了。</p><p>至于上传源码到github中，我的处置方法是删除原来的源码repo并新建一个repo，然后先将Hexo：git init，再将其上传到repo中。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你给我听好</title>
      <link href="/2017/04/21/%E4%BD%A0%E7%BB%99%E6%88%91%E5%90%AC%E5%A5%BD/"/>
      <url>/2017/04/21/%E4%BD%A0%E7%BB%99%E6%88%91%E5%90%AC%E5%A5%BD/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>陈奕迅的《你给我听好》。</p></blockquote><a id="more"></a><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/E5E20145DA11F0AC988D737DC01D85CB.flv?sc=916382da26ce80fb&br=769&vid=2047605&aid=157&area=HT&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/E5E20145DA11F0AC988D737DC01D85CB.flv?sc=916382da26ce80fb&br=769&vid=2047605&aid=157&area=HT&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 陈奕迅 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观眉山论剑</title>
      <link href="/2017/04/16/%E8%A7%82%E7%9C%89%E5%B1%B1%E8%AE%BA%E5%89%91/"/>
      <url>/2017/04/16/%E8%A7%82%E7%9C%89%E5%B1%B1%E8%AE%BA%E5%89%91/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>腾讯观视频工作室出品的《眉山论剑》，很好的时事讲坛类节目，对自己是一个启迪。小时候自己什么都不懂，长大了之后目空一切，以为自己什么都懂，再到现在又发现自己还是什么都不懂。除了自己的专业知识以外，政治博弈这个知识在我这还是空白，也许这个节目能给自己和困惑的你一点启发。庆幸中国有如此一批超级大脑，才能为祖国人民创造如此安定的生活环境。他们用自己的大脑解析外国的阴谋阳谋，学以致用，这一点值得我辈学习。尤其想到节目中陈平研究员提到现在的媒体经济学者，估计就是大多数人，很容易被所谓新闻欺骗，联想到共产党人需要辩证的看待事情这一马克思原理，深有感触。以前的知识并没有白学，只是没有好好利用，活读书。再联想到有句话“半部论语治天下”，其实，人是真正活学了论语，而不是死靠论语来治理天下。回到起点来说，要活读书，化为己用，才能透过现象看到本质。</p><a id="more"></a> <p> 在此给出眉山论剑的视频链接，以供读者观看。</p><ol><li><a href="http://v.qq.com/page/f/k/t/f0392qlc5kt.html" target="_blank" rel="noopener">眉山论剑1：听其言不如观其行</a></li><li><a href="http://v.qq.com/page/j/g/8/j0392rsk4g8.html" target="_blank" rel="noopener">眉山论剑2：不学经济，学孙子兵法</a></li><li><a href="http://v.qq.com/page/w/o/r/w0393r31yor.html" target="_blank" rel="noopener">眉山论剑3：媒体经济学的伪命题</a></li><li><a href="http://v.qq.com/page/n/w/7/n0393pi9ow7.html" target="_blank" rel="noopener">眉山论剑4：他们都错了</a></li><li><a href="http://v.qq.com/page/d/j/6/d0393w16aj6.html" target="_blank" rel="noopener">眉山论剑5：印度超越中国？</a></li><li><a href="http://v.qq.com/page/h/9/f/h0393uuwp9f.html" target="_blank" rel="noopener">眉山论剑6：中国是1900年的美国</a></li></ol><p>要用科学的辩证眼光来看待问题，也许节目中的问题讲的是对的，也许讲的是不全面的，要有自己的认识，才能达到学习的目的。</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>摄影杂货铺</title>
      <link href="/2017/04/07/%E6%91%84%E5%BD%B1%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
      <url>/2017/04/07/%E6%91%84%E5%BD%B1%E6%9D%82%E8%B4%A7%E9%93%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文收集了平时看到的有关摄影的小知识，不定时更新。</p></blockquote><a id="more"></a><ol><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=153129" target="_blank" rel="noopener">好照片的秘诀 - 对比和冲突</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=144397" target="_blank" rel="noopener">新手学习摄影应该注意什么？</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=146199" target="_blank" rel="noopener">所谓摄影眼，究竟是什么眼？ | 一点思路</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=141530" target="_blank" rel="noopener">学会调色，从理解HSL面板开始</a></li><li><a href="http://www.sybj.com/may.php?c=w&amp;a=oneClass&amp;t=1&amp;id=133352" target="_blank" rel="noopener">如何突出画面中的主体？布拉德·皮特 告诉你 | 一点技巧</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/22/摄影笔记手机摄影入门/">摄影笔记手机摄影入门</a></li><li><a href="http://www.davidfnck.com/talkshow/obama_top_100_best_photos.html/">创业前辈｜Barack Obama's Top 100 best photos</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 琴棋书画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>湖南行见</title>
      <link href="/2017/04/06/%E6%B9%96%E5%8D%97%E8%A1%8C%E8%A7%81/"/>
      <url>/2017/04/06/%E6%B9%96%E5%8D%97%E8%A1%8C%E8%A7%81/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>TBD</p><blockquote><p>留存，以后再写，简单说两句。</p></blockquote><a id="more"></a><h3 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h3><ol><li>南京到张家界</li><li>张家界到武陵源</li><li>武陵源到张家界</li><li>天门山</li><li>张家界到长沙</li></ol><h3 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h3><p>想去玩的朋友需准备充足的时间，武陵源3天为宜。天门山完全是坐索道，其实没啥可玩的，时间仓促可以不去。长沙小吃还不错，时间匆忙，只去了橘子洲，还没玄武湖漂亮。好了就这么多，有空再写。</p>]]></content>
      
      <categories>
          
          <category> 追忆脚步 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些感悟</title>
      <link href="/2017/04/06/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/"/>
      <url>/2017/04/06/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/26178137" target="_blank" rel="noopener">一些感悟</a>，仅供本博留存观看，其它商业目的请与原文联系。</p><a id="more"></a><p>首先要自律。这是最基本的。如果一个人不能控制自己的行为，那无法走出自己的路。像说到要做到，有规律地锻炼身体，勤奋努力，这些都是重要的。</p><p>接下来要跳出舒适区。举个例子，勤奋本来就是舒适区的一种。“勤能补拙”这个词是很好的，首先它说明现在处于“拙”的状态中，需要继续努力；其次，勤只能用来“补”拙，而不能让拙变巧，不是根本的解决方案。勤奋是一种惶惶然的状态，而不是一种满足的状态，勤奋意味着自己不如别人，于是得要花更多的时间去补救，别人干八小时就够了，自己得花十几个小时才能赶上。这种状态是不长久的，碰到出些小毛小病，或者家里有事，那就补不过来，就要掉队了。勤奋的用处是试错，是让自己在落后时可以多花点时间找到正确的方法，以达到和别人相当甚至更高的效率，从而提高自己的能力。别人是科班出身，我半路杀进来，当然要多花时间去补；别人学习效率高，我的效率不高，于是得要多花点时间去探索更好的方法。勤奋是暂态，它最终目的是找到更好的方法及时补上以离开这个状态，而不是以一直维持这个状态为荣。</p><p>不能按部就班，要随时作好把棋盘翻过来的准备，世事变化很快，以前的所有努力，不管经历过什么样的辛劳，全都是沉没成本，在必要时候都需要扔掉的，或许做了很多年方向A，时势告诉你情况不妙，要换成方向B，那就得坚决换。以前或许这个不常见，但是以后这样的事情会越来越多。干了十年方向A，人工智能把方向A吃掉了，然后马上转做方向B，做了五年，人工智能再把B吃掉，然后继续，如此往复。很多时候转变不是一朝一夕，而是靠滴水穿石的功夫，今天长进一点，明天长进一点，跟着领域一起变，若是一个人跑得比别人快，他就会在市场上稀缺并因此获得相对的安全。做研究的人都习惯这个，每天看新东西，每天打开思路，时刻承认自己老旧了几个月或者几周，马上拍拍屁股跟上。学会了这些再去教徒弟是饿不死师傅的，反而让师傅变得更厉害，因为师傅主动跳出来接受打脸，学得比徒弟快。对很多人来说这个比较难，特别是一直顺风顺水的。但若是一直不敢看外面的世界，那迟早有一天会被逼进去面对。与其被逼，不如提早一些主动跳进去。历史无数次以血的教训告诉了大家，适者生存乃永恒之铁律，人类在千万物种中杀出血路成为地球的主宰，也必将背负着这样的命运走向未来。一个人逃避，这个人会被淘汰，一个领域逃避，这个领域会被淘汰，一个国家逃避，这个国家就会被淘汰。</p><p>任何时候，自己一定是有错的，最可怕的不是自己错了，而是不知道自己哪里错，并且在错的方向上越走越远。如果周围有厉害的同事，这种感觉尤其强烈，碰上了随便讨论两句，就知道自己哪些知识不足，暗地里记下马上回去补。为此，主动发言积极讨论是很重要的，思维有碰撞才知道问题在哪里。我有时候觉得自己一直在悬崖边上走，也许之前走得还行，但那都过去了，下一步随时有可能踏进崖边的泥地即将摔倒。踏错了不要紧，及时发现自己错了收脚就行；怕的是一直走安稳的道，连悬崖长什么样都不知道了。前辈和老师们说的话，也非常有可能是错的，而身为后辈的我们，大任在于如何找出他们的错误来。找出了的话，能力就得到了提升。而自信，往往就是通过这种方式磨练出来的——为什么自己和别人不同？因为选了一条不一样的路。</p><p>再往上走，主次是要分清的。重要的要抓牢，不重要的要放手。有人读过很多文章看过很多书，勤勉自律好学爱问样样不缺，但门门都不精；有人事事亲为，务求完美，大事上往往把握不了。短木板理论是有问题的，大部分岗位不需要全才，要的是一专多能，要的是某方向很牛非常牛，相同程度的可以掰指头数过来，其它的过线就行，甚至不达标也无人关心。如果你不是专家，高薪聘请没有意义；如果你是专家，求全责备没有意义。人一天只有24小时，所以知道哪里要放弃是很重要的，很多时候，没有牺牲就没有得到，要得到就得付出代价，事前权衡利弊，事后愿赌服输。输了不要紧，再来一次。当然在现实中并没有那么惨烈的权衡，而往往是找到了自己的方向，自然而然地就向这个方向发展下去，这时候主要的阻力，就在于登顶之难而非选择之痛。然而，即便生于风平浪静的和平年代，觉悟依然要有，或许将来有一天，得要做出这样的决断。</p><p>最后，不要在优越感中停止自己的脚步。名利于人最可怕的莫过于此，分明刚刚启程，但欢呼声让你觉得已然冲线，本来要万里长征，却变成了百米短跑，接受完了鲜花之后，就再也看不见远处的风景。其实境界到了或是未到，只有自己知道。跋山涉水，风餐露宿，鼓掌的是别人，度化的是自己。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li><li><a href="http://gubangzhong.cn/2016/11/16/女人如政治/">女人如政治</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上传本地博客源码到git服务器</title>
      <link href="/2017/03/28/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/03/28/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0git%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文主要想将本地的博客文件上传到github中，以备系统崩坏or不慎删除。</p></blockquote><a id="more"></a><p>首先创建Repo，例如我创建了Blog（注意：不要添加readme.md）</p><p>然后在本地git bash中输入如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">'上传'</span></span><br><span class="line">git remote add origin https://github.com/maxiaoyuelun/Blog.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新文件</span></span><br><span class="line">git status<span class="comment">#查看已经更新哪些文件</span></span><br><span class="line">git add -u<span class="comment">#把当前文件夹下中所有tracked文件中被修改过或已删除文件的信息添加到索引库，它不会处理untracked的文件。</span></span><br><span class="line">git commit -m <span class="string">'写出你的修改内容'</span><span class="comment">#这一步必须有，否则下一步不成功</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">git add -A<span class="comment">#添加文件时将untracked文件添加到更新索引中</span></span><br><span class="line">git commit -m <span class="string">'写出你的修改内容'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Laravel5-1开发博客系列一/">Laravel5.1开发博客系列一</a></li><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo插件收集</title>
      <link href="/2017/03/28/hexo%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86/"/>
      <url>/2017/03/28/hexo%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文主要记录收集的hexo插件，不定时更新。</p></blockquote><a id="more"></a><h4 id="博文末尾加版权addlink"><a href="#博文末尾加版权addlink" class="headerlink" title="博文末尾加版权addlink"></a><a href="https://github.com/acwong00/hexo-addlink" target="_blank" rel="noopener">博文末尾加版权addlink</a></h4><h4 id="博客加密blog-encrypt"><a href="#博客加密blog-encrypt" class="headerlink" title="博客加密blog-encrypt"></a><a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">博客加密blog-encrypt</a></h4><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows文本快捷键</title>
      <link href="/2017/03/28/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/03/28/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文简记Windows文本的快捷键，以备不时之需，不定期更新。</p></blockquote><a id="more"></a><ol><li>选取块左移    Shift+Tab</li><li>选取块右移    Tab</li><li>关闭当前程序    Alt+F4</li><li>切换程序        Alt+Tab</li><li>将当前行上移、下移一行    Ctrl+Shift+左右方向键</li><li>删除当前行    Ctrl+L</li><li>选中文字        Shift+方向键</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/13/windows右键cmd/">windows右键cmd</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git Bash不能输入中文解决办法</title>
      <link href="/2017/03/14/Git-Bash%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2017/03/14/Git-Bash%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>打开Git Bash后，</p><p>对窗口右键-&gt;Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8，</p><p>关闭再打开。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/git本地文件夹上传至github/">git本地文件夹上传至github</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="http://gubangzhong.cn/2017/07/13/批处理git命令/">批处理git命令</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dlib使用指南</title>
      <link href="/2017/01/03/Dlib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2017/01/03/Dlib%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>最近搞人脸识别的程序，于是广泛搜索可复用代码，再加上以前就知道的工具，在此笔记。</p></blockquote><a id="more"></a><p>进入<code>D:/github/dlib/</code>，打开cmd。在此之前需要安装<a href="https://cmake.org/" target="_blank" rel="noopener">cmake</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> examples</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G <span class="string">"Visual Studio 14 2015 Win64"</span> -DCOMPILER_CAN_DO_CPP_11=ON -DCMAKE_PREFIX_PATH=<span class="string">"D:/githun/cudnn/"</span> ..</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>face_recognition是搭建在dlib之上的代码，一个很好的框架。</p><p>测试代码</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://dlib.net/" target="_blank" rel="noopener">Dlib官网</a></li><li><a href="https://github.com/davisking/dlib" target="_blank" rel="noopener">Dlib github</a></li><li><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">face_recognition github</a></li><li><a href="https://github.com/MarekKowalski/FaceSwap" target="_blank" rel="noopener">FaceSwap github</a></li><li><a href="https://github.com/davisking/dlib/issues/756" target="_blank" rel="noopener">Dlib CUDA安装</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> dlib </tag>
            
            <tag> face_recognition </tag>
            
            <tag> cudnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>车站</title>
      <link href="/2016/12/13/%E8%BD%A6%E7%AB%99/"/>
      <url>/2016/12/13/%E8%BD%A6%E7%AB%99/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><p>写着论文，听到这首车站，不觉潸然。</p><p>读博已经到了第二年，前路可期但前路漫漫。</p><p>越来越明白一些道理，就像有了一定的阅历之后再读某一本书，深有同感。</p><p>回忆会伤人的，在李健歌声的烘托下，那一丝丝的情绪蔓延开来，断了思绪。</p><blockquote><p>只在音悦台找到邓丽君版的。</p></blockquote><iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/3B5E01605352FCC49D8A168B52C1825E.mp4?sc=e02c9c89e4c10460&br=482&vid=3112534&aid=1028&area=HT&vst=3" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>读书这些年，不免多了书生气，少了人生在这个时间段的某种阅历，所谓行万里路。况且，有失必有得，祸福相倚，书读多了，就越来越接近一种说不出的真理，亦或某种大道，亦或某种淡然，有种殊途同归的感觉。</p><p>不理解的人可能会说读傻了，产生一种难以交流的感觉，而这正是经历之后的一种觉悟，尽管我才刚刚开始，但此时才真正知道我需要什么，不需要什么，而不是被环境或者外力裹挟前进。</p><p>还要经历或者两年，写文章，做实验，最终完成毕业论文，天复一天，年复一年，似乎无聊。</p><p>这只是一种经历，经历了之后，会为你打开另外一扇门，不仅仅是苟且，也许是理想。</p><p>音乐作为一种勾起思绪的媒介，的确是个好东西，不然即使平时再无聊，也不会好好沉淀，想想，思考。</p><p>自从研究生开始学起了尤克里里，而后吉他，对其爱不释手，有时候只是简单的扫弦，也会得到某种放松。可惜，这么久才开始学，幸运是，我已经开始学了。</p><!-- 对于我，一切都不算晚。--><!-- 路，一直在脚下。-->]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 李健 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mxnet初步安装及使用指北</title>
      <link href="/2016/12/06/mxnet%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/2016/12/06/mxnet%E5%88%9D%E6%AD%A5%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>windows 10</li><li>visual studio 2013 community update 5</li><li>pycharm community edition 2016.3</li><li>anaconda 4.2.0 64 bit python 2.7.12</li><li>GTX 1070</li></ol><a id="more"></a><h3 id="安装小记"><a href="#安装小记" class="headerlink" title="安装小记"></a>安装小记</h3><blockquote><p>博主安装在D盘上，路径为<code>D:\mxnet\</code></p></blockquote><p>首先确保电脑上已经安装好官方Git，并已经配置成功。</p><p>确保电脑上已经安装好cuda(博主安装版本8.0)，并已经配置成功。</p><blockquote><p>cuda必须在visual studio 2013之前安装，否则不能在visual studio中正确配置cuda。</p></blockquote><p>用Git下载Github上的源文件至指定路径下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git colne https://github.com/dmlc/mxnet.git</span><br></pre></td></tr></table></figure><p>安装编译前必备的库和软件：cudnn，opencv，openblas</p><blockquote><p>以下参考官方文档<a href="http://mxnet.io/get_started/setup.html#building-and-installing-packages-on-windows" target="_blank" rel="noopener">Building and Installing Packages on Windows</a>进行安装并进行补充。</p></blockquote><p>由于博主已经安装了update5，所以不再需要安装<a href="https://www.microsoft.com/en-us/download/details.aspx?id=41151" target="_blank" rel="noopener">visual c++ compiler nov 2013 ctp</a>。如需安装请参考mxnet官方文档。</p><p><strong>cmake 3.7.0</strong></p><p><a href="https://cmake.org/" target="_blank" rel="noopener">cmake官网</a>下载安装最新版本，用来编译Visual Studio Solution。</p><p><strong>cudnn</strong></p><p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cudnn官网</a>下载最新版本5.0，存放在路径<code>D:\cudnn</code>。</p><p><strong>opencv</strong></p><p><a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.0.0/opencv-3.0.0.exe/download" target="_blank" rel="noopener">opencv下载链接</a>下载版本3.0.0，存放在路径<code>D:\opencv</code>。</p><p>在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>OpenCV_DIR</code>，并赋值<code>D:\opencv\build</code>。</p><p><strong>openblas</strong></p><p><a href="https://sourceforge.net/projects/openblas/files/v0.2.14/OpenBLAS-v0.2.14-Win64-int64.zip/download" target="_blank" rel="noopener">OpenBLAS-v0.2.14-Win64-int64下载链接</a>，存放在路径<code>D:\OpenBLAS-v0.2.14-Win64-int64</code>。</p><p>在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>OpenBLAS_HOME</code>，并赋值<code>D:\OpenBLAS-v0.2.14-Win64-int64</code>。</p><p><strong>anaconda</strong></p><p><a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">anaconda官网</a>下载安装anaconda，博主安装路径为<code>C:\Program Files\Anaconda2\</code>。</p><p><strong>visual studio编译配置</strong></p><p>首先在<code>D:\mxnet\</code>下新建文件夹build。</p><p>打开cmake。</p><p>在<code>where is the source code</code>中添加<code>D:\mxnet</code>。<br>在<code>where to build the binaries</code>中添加<code>D:\mxnet\build</code>。</p><p>点击<code>Configure</code>，进行配置，若出现配置不成功，则将需要的路径手动添加在cmake中，<strong>当然根据出现的问题针对改动</strong>。</p><p>配置成功后点击<code>Generate</code>生成solution。</p><p>生成完成后可以发现在<code>D:\mxnet\build</code>下出现solution文件，用visual studio 2013打开solution。</p><p>在visual studio 2013中编译Debug和Release文件，静待几分钟编译成功。</p><p>由于大多数使用在python环境下，需要配置python使用环境，在<code>系统属性&gt;环境变量&gt;用户环境变量</code>中添加变量<code>PYTHONPATH</code>，并添加值<code>D:\mxnet\python</code>。由于需要在python中使用opencv，所以在<code>PYTHONPATH</code>变量中继续添加<code>D:\opencv\build\python\2.7\x64</code>。</p><p><strong>范例测试</strong></p><blockquote><p>由于在pycharm中编写python代码，需要配置pycharm的编译环境，打开pycharm，在<code>File&gt;Settings&gt;Interpreter</code>中配置解释环境为<code>C:\Program Files\Anaconda2\python.exe</code>。</p></blockquote><p>在pycharm中打开文件train_mnist.py。该文件在<code>D:\mxnet\example\image-classification\</code>文件夹下，是官方自带示例。</p><p>在61行中将<code>gpus=None</code>改成<code>gpus=&#39;0&#39;</code>即可用gpu运行代码，最终发现结果约为：0.981190。</p><h3 id="使用小记"><a href="#使用小记" class="headerlink" title="使用小记"></a>使用小记</h3><p>mxnet自带可以将net画成pdf图的工具，但是需要配置相关库。</p><p><strong>下面需按顺序安装</strong></p><p><strong>graphviz</strong></p><p><a href="http://www.graphviz.org/Download_windows.php" target="_blank" rel="noopener">graphviz下载链接</a>，博主下载的是zip文件并解压到<code>D:\graphviz-2.38</code>下。</p><p>接下来配置环境变量，在系统环境变量<code>Path</code>中添加值<code>D:\graphviz-2.38\release\bin</code>，保存关闭。</p><p>接下来<code>以管理员身份运行</code>cmd，由于博主anaconda是安装在C盘中，所以必须以管理员身份运行安装相关软件。</p><p>确保已经用conda安装好pip。</p><p>接下来输入如下代码安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install graphviz</span><br><span class="line">pip install pydot</span><br></pre></td></tr></table></figure><p>重启电脑，graphviz安装成功，至此再次声明，上面的安装顺序不能乱。</p><p>博主在路径<code>D:\DLRVS\train\</code>下创建自己的数据分类文件夹<code>b</code>和<code>f</code>，只有两类。</p><p>用mxnet自带的工具im2rec生成相关rec文件。im2rec.py在路径<code>D:\mxnet\tools</code>下。</p><p>在cmd中切换到路径<code>D:\mxnet\tools</code>下，使用im2rec.py先生成lst文件，然后再生成rec文件。</p><p><strong>生成lst文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python im2rec.py --list True D:\DLRVS\yy D:\DLRVS\train\ --recursive True --shuffle True --train-ratio=0.8</span><br></pre></td></tr></table></figure><p>在路径<code>D:\DLRVS\</code>下生成yy_train.lst，yy_val.lst，yy_test.lst文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python im2rec.py D:\DLRVS\yy_train.lst D:\DLRVS\train --quality=100</span><br></pre></td></tr></table></figure><p>在路径<code>D:\DLRVS\</code>下生成yy_train.rec文件，同样可以生成yy_val.rec和yy_test.rec文件。</p><p>以下是本人的测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> fit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip, struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iterators</span><span class="params">(batch_size,data_shape=<span class="params">(<span class="number">1</span>,<span class="number">27</span>,<span class="number">27</span>)</span>)</span>:</span></span><br><span class="line">    train=mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=<span class="string">"D:\DLRVS\yy_train.rec"</span>,</span><br><span class="line">        mean_img=<span class="string">"\DLRVS\mean.bin"</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        shuffle=<span class="keyword">True</span>,</span><br><span class="line">        rand_crop=<span class="keyword">False</span>,</span><br><span class="line">        rand_mirror=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    val= mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=<span class="string">"D:\DLRVS\yy_val.rec"</span>,</span><br><span class="line">        mean_img=<span class="string">"D:\DLRVS\mean.bin"</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        shuffle=<span class="keyword">True</span>,</span><br><span class="line">        rand_crop=<span class="keyword">False</span>,</span><br><span class="line">        rand_mirror=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> (train,val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_symbol</span><span class="params">(num_classes=<span class="number">10</span>, **kwargs)</span>:</span></span><br><span class="line">    data = mx.symbol.Variable(<span class="string">'data'</span>)</span><br><span class="line">    <span class="comment"># first conv</span></span><br><span class="line">    conv1 = mx.symbol.Convolution(data=data, kernel=(<span class="number">5</span>,<span class="number">5</span>), num_filter=<span class="number">20</span>)</span><br><span class="line">    tanh1 = mx.symbol.Activation(data=conv1, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    pool1 = mx.symbol.Pooling(data=tanh1, pool_type=<span class="string">"max"</span>,</span><br><span class="line">                              kernel=(<span class="number">2</span>,<span class="number">2</span>), stride=(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># second conv</span></span><br><span class="line">    conv2 = mx.symbol.Convolution(data=pool1, kernel=(<span class="number">5</span>,<span class="number">5</span>), num_filter=<span class="number">50</span>)</span><br><span class="line">    tanh2 = mx.symbol.Activation(data=conv2, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    pool2 = mx.symbol.Pooling(data=tanh2, pool_type=<span class="string">"max"</span>,</span><br><span class="line">                              kernel=(<span class="number">2</span>,<span class="number">2</span>), stride=(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># first fullc</span></span><br><span class="line">    flatten = mx.symbol.Flatten(data=pool2)</span><br><span class="line">    fc1 = mx.symbol.FullyConnected(data=flatten, num_hidden=<span class="number">500</span>)</span><br><span class="line">    tanh3 = mx.symbol.Activation(data=fc1, act_type=<span class="string">"tanh"</span>)</span><br><span class="line">    <span class="comment"># second fullc</span></span><br><span class="line">    fc2 = mx.symbol.FullyConnected(data=tanh3, num_hidden=num_classes)</span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    lenet = mx.symbol.SoftmaxOutput(data=fc2, name=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> lenet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(symbol,train,val,batch_size,num_gpus)</span>:</span></span><br><span class="line">    devs=[mx.gpu(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_gpus)]</span><br><span class="line">    mod=mx.mod.Module(symbol=new_sym,context=devs)</span><br><span class="line">    mod.bind(data_shapes=train.provide_data,label_shapes=train.provide_label)</span><br><span class="line">    mod.init_params(initializer=mx.init.Xavier(rnd_type=<span class="string">'gaussian'</span>,factor_type=<span class="string">"in"</span>,magnitude=<span class="number">2</span>))</span><br><span class="line">    mod.fit(train,val,</span><br><span class="line">            num_epoch=<span class="number">1000</span>,</span><br><span class="line">            batch_end_callback=mx.callback.Speedometer(batch_size,<span class="number">10</span>),</span><br><span class="line">            optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">            optimizer_params=&#123;<span class="string">'learning_rate'</span>:<span class="number">0.01</span>&#125;,</span><br><span class="line">            eval_metric=<span class="string">'acc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num_classes=<span class="number">2</span></span><br><span class="line">    batch_per_gpu=<span class="number">600</span></span><br><span class="line">    num_gpus=<span class="number">1</span></span><br><span class="line">    new_sym=get_symbol(num_classes=<span class="number">2</span>)</span><br><span class="line">    batch_size=batch_per_gpu*num_gpus</span><br><span class="line">    (train,val)=get_iterators(batch_size)</span><br><span class="line">    mx.viz.plot_network(new_sym).view()</span><br><span class="line">    fit(new_sym,train,val,batch_size,num_gpus)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.cnblogs.com/daihengchen/p/5924768.html" target="_blank" rel="noopener">从零开始学MXnet(一)</a></li><li><a href="http://blog.csdn.net/panda1942/article/details/50923006" target="_blank" rel="noopener">mxnet深度学习实战：跑自己的数据实验和一些问题总结</a></li><li><a href="http://blog.csdn.net/shuzfan/article/details/50037273" target="_blank" rel="noopener">mxnet学习记录</a></li><li><a href="http://blog.csdn.net/Sunshine_in_Moon/article/category/6020021" target="_blank" rel="noopener">Mxnet学习系列</a></li><li><a href="http://mxnet.io/" target="_blank" rel="noopener">mxnet官网</a></li></ol>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mxnet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我要你</title>
      <link href="/2016/11/26/%E6%88%91%E8%A6%81%E4%BD%A0/"/>
      <url>/2016/11/26/%E6%88%91%E8%A6%81%E4%BD%A0/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近很喜欢听这首歌，主要是在学怎么弹啊，弹了好久都没连贯！！！</p><a id="more"></a><p>网易云音乐</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="448" height="86" src="//music.163.com/outchain/player?type=2&id=436514254&auto=0&height=66"></iframe><p>音悦台</p><!--<iframe width="840" height="473" src="http://hc.yinyuetai.com/uploads/videos/common/740C01580E4D6EDDAB4DB0E4A1D1CE59.flv?sc=0428d8f24652d584&br=796&vid=2712084&aid=41699&area=ML&vst=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>--><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://hc.yinyuetai.com/uploads/videos/common/740C01580E4D6EDDAB4DB0E4A1D1CE59.flv?sc=0428d8f24652d584&br=796&vid=2712084&aid=41699&area=ML&vst=0"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      <categories>
          
          <category> 音乐之声 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>女人如政治</title>
      <link href="/2016/11/16/%E5%A5%B3%E4%BA%BA%E5%A6%82%E6%94%BF%E6%B2%BB/"/>
      <url>/2016/11/16/%E5%A5%B3%E4%BA%BA%E5%A6%82%E6%94%BF%E6%B2%BB/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>女人如政治，自己想去吧！</p><a id="more"></a><p>政治是不需要道德的<br>政治是暴力或者实力征服<br>政治是虚伪的<br>政治是说一套做一套<br>政治是讲究表面的装饰<br>政治是要掩盖残酷真相的<br>政治是需要给人远大幻想的<br>政治是做了再说的</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/12/04/windows绝赞应用/">windows绝赞应用</a></li><li><a href="http://gubangzhong.cn/2017/04/06/一些感悟/">一些感悟</a></li><li><a href="http://gubangzhong.cn/2017/11/25/一些资料翻译收集/">一些资料翻译收集</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Hexo中嵌入图片之七牛插件指北</title>
      <link href="/2016/11/13/%E5%9C%A8Hexo%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87%E4%B9%8B%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/13/%E5%9C%A8Hexo%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87%E4%B9%8B%E4%B8%83%E7%89%9B%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>根据参考文献可以完成初步配置，不够完美，正在寻找新的替代插件（比较难用，博主已放弃）。</p></blockquote><p>问题：</p><p>不能用<code>hexo qiniu sync</code>进行同步，在用<code>hexo g -d</code>也不能进行同步，需要将需要上传的image文件夹拷贝到public文件夹下，并在<code>_config.yml</code>文件中对<code>sync_dir</code>进行配置，则可以完成上传。</p><p>以上步骤还是麻烦，将待上传image文件夹拷贝到public文件夹下，在用<code>hexo d</code>命令时，图片也被上传到github中了，这违背了初始意愿，只能删除重复上传。</p><a id="more"></a><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://github.com/ronesam/hexo-deployer-qiniu" target="_blank" rel="noopener">hexo-deployer-qiniu</a></li><li><a href="http://linusling.com/2016/03/04/images-in-hexo-using-qiniu/" target="_blank" rel="noopener">使用七牛在 Hexo 文档中嵌入图片</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/Hexo静态站点搭建/">Hexo静态站点搭建</a></li><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 七牛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django安装指北</title>
      <link href="/2016/11/10/Django%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/Django%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近来突发兴致学习Django，初始根据教程学习，用内置服务器运行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>在浏览器中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000</span><br></pre></td></tr></table></figure><a id="more"></a><p>得到合适的页面，也是正确的页面。</p><p>但是，在Django的开发文档中也这么说明，runserver只作为开发用途，而不是发行用途。</p><p>所以，寻求用Apache来运行Django。</p><p>这也就带来了难题，即需要如题配置。经过大约一天的时间，各种谷歌、百度寻求帮助，排除一个个error终于配置成功。</p><p>现将过程介绍如下，防止以后再遇到此类问题。</p><blockquote><p>我使用的是Ubuntu 14.04 LTS+Apache2.4+Python2或者3（根据mod_wsgi.so改变）+Django1.6或者以上</p></blockquote><h2 id="安装Apache等"><a href="#安装Apache等" class="headerlink" title="安装Apache等"></a>安装Apache等</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 libapache2-mod-wsgi python-django</span><br></pre></td></tr></table></figure><h2 id="Apache配置"><a href="#Apache配置" class="headerlink" title="Apache配置"></a>Apache配置</h2><p>　　在/etc/apache2/中找到apache2.conf</p><p>　　在最后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line"></span><br><span class="line">    ServerName hello.com</span><br><span class="line">    DocumentRoot /var/www/yourproject</span><br><span class="line">    &lt;Directory /var/www/yourprojec&gt; </span><br><span class="line">　　　　Order allow,deny </span><br><span class="line">　　　　Allow from all</span><br><span class="line">　　 &lt;/Directory&gt; </span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">　　在/etc/apache2/sites-available/中添加wsgi.conf，在新创建的wsgi.conf中输入</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;  </span><br><span class="line">  </span><br><span class="line">    ServerName wsgi.testserver  </span><br><span class="line">    DocumentRoot /var/www/yourproject </span><br><span class="line">  </span><br><span class="line">   &lt;Directory /var/www/yourproject&gt;  </span><br><span class="line">       Order allow,deny  </span><br><span class="line">        Allow from all  </span><br><span class="line">   &lt;/Directory&gt;  </span><br><span class="line">  </span><br><span class="line">    WSGIScriptAlias / /var/www/django.wsgi  </span><br><span class="line">  </span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>　　</p><p>　　</p><h2 id="Django配置"><a href="#Django配置" class="headerlink" title="Django配置"></a>Django配置</h2><p>在/var/www/中创建django.wsgi，并在其中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(<span class="string">'/var/www/yourproject'</span>)</span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'yourproject.settings'</span></span><br><span class="line"></span><br><span class="line">from django.core.wsgi import get_wsgi_application</span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite wsgi.conf</span><br><span class="line"></span><br><span class="line">sudo service apache2 reload</span><br></pre></td></tr></table></figure><p>差不多成功了。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/11/20/win10安装django错误集/">win10安装django错误集</a></li><li><a href="http://gubangzhong.cn/2016/11/09/Python爬虫抓取大伟吉他谱/">Python爬虫抓取大伟吉他谱</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> python </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>月下漫步</title>
      <link href="/2016/11/10/%E6%9C%88%E4%B8%8B%E6%BC%AB%E6%AD%A5/"/>
      <url>/2016/11/10/%E6%9C%88%E4%B8%8B%E6%BC%AB%E6%AD%A5/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>清冷的星光</p><p>不知今夜几更</p><p>漫步在桥头 </p><p>留恋梦更深</p><p>难忘几段曲 </p><p>轻叩夜门</p><a id="more"></a><p><img src="http://wx4.sinaimg.cn/mw690/005IKUsQly1fn4frj7f0bj31kw148hci.jpg" alt=""></p><p>你说今宵很美</p><p>不忍翻过这一夜</p><p>离经叛道的我们 </p><p>都念这里虫声</p><p>云端的月牙偷笑尘世的凡人</p><p>却不懂自己的清冷</p><p>嫦娥孤寂 不再天下人</p><p>又是这个夜 </p><p>早已物是人非</p><p>梧桐雨伴随脚步 </p><p>敲打这不成文</p><p>想你的时候 </p><p>默默呼唤 </p><p>不敢更深</p><p>怕心碎</p><p>无端的烦躁</p><p>莫名的悲痛</p><p>花儿已凋谢 </p><p>何时才能再开</p><p>只是独唱 </p><p>寂寞沙洲冷</p><p>记忆已慢慢消逝 </p><p>还留下什么</p><p>灯火辉煌的校园潜伏着这不知疲倦的老树</p><p>却已等不到灯下的人</p><p>昨天我们的温筑  </p><p>早已变成别人的战场</p><p>避开熟悉的脸皮  </p><p>僵硬的城池 </p><p>踏过漫漫夜波  </p><p>拥抱我身披的三世清辉</p><p>那些不愿说出的细节 </p><p>就让她随风而去</p><p>绕过绿肥红瘦 </p><p>追赶悄悄离开的雨</p><p>在深处  </p><p>忆西窗烛影 </p><p>一曲夜歌</p><p>祝福的哑语</p><p>你听到没？</p>]]></content>
      
      <categories>
          
          <category> 闲话桑麻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MatConvNet安装指北</title>
      <link href="/2016/11/10/MatConvNet%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/MatConvNet%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>Windows 10</li><li>VS2015/VS2013</li><li>Matlab 2016</li><li>MatConvNet各个版本</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>解压下载后的文件夹到指定路径。假定为<code>D:\matconvnet\</code></p><a id="more"></a><p>在<code>matconvnet</code>下创建文件夹<code>local</code>，并将<code>cudnn</code>及文件夹下全部文件拷贝到<code>local</code>下。</p><p>在<code>D:\matconvnet\matlab\</code>下创建<code>mex</code>文件夹。</p><p>将<code>local\cudnn\bin</code>下的<code>dll</code>文件拷贝至<code>mex</code>文件夹下。</p><p>在Matlab工作环境下切换路径至<code>D:\matconvnet\</code>文件夹下，运行如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run ./matlab/vl_setupnn.m</span><br><span class="line"></span><br><span class="line">vl_compilenn(&apos;enableGpu&apos;,true,&apos;enableCudnn&apos;,true,&apos;cudnnRoot&apos;,&apos;.\local\cudnn\&apos;);</span><br></pre></td></tr></table></figure><p>至此安装成功。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matconvnet </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vlfeat编译指北</title>
      <link href="/2016/11/10/Vlfeat%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/"/>
      <url>/2016/11/10/Vlfeat%E7%BC%96%E8%AF%91%E6%8C%87%E5%8C%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>首先下载源码文件解压至指定路径，例如<code>C:\Users\colin\Documents\MATLAB</code>。</p><p>查找<code>C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20</code>路径下发现有<code>Makefile.mak</code>文件。</p><p>打开菜单栏，找到<code>Visual Studio Tools</code>，双击打开<code>VS2013 x64 本机工具命令提示</code>。</p><p>在<code>cmd</code>中输入以下代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20</span><br><span class="line">nmake /f Makefile.mak</span><br></pre></td></tr></table></figure><p>至此，发现输出信息最后几行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.... CC [MEX] toolbox\mex\mexw64\vl_aib.mexw64</span><br><span class="line">系统找不到指定的路径。</span><br><span class="line">NMAKE : fatal error U1077: “echo”: 返回代码“0x1”</span><br><span class="line">Stop.</span><br></pre></td></tr></table></figure><p><strong>不用管这些信息</strong>。</p><p>打开<code>Matlab</code>，切换路径至<code>C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\</code>。</p><p>在Matlab命令窗口中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vl_setup</span><br><span class="line"></span><br><span class="line">vl_compile</span><br></pre></td></tr></table></figure><p>至此编译完成。</p><blockquote><p>估计用nmake编译不成功是没有设置matlab路径。</p></blockquote><p>切换matlab路径至<code>C:\Users\colin\Documents\MATLAB\</code>。</p><p>新建<code>startup.m</code>文件，在其中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(&apos;C:\Users\colin\Documents\MATLAB\vlfeat-0.9.20\toolbox\vl_setup.m&apos;);</span><br></pre></td></tr></table></figure><p>这样就可以让matlab每次都启动vlfeat库。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2017/06/23/matlab中的P代码/">matlab中的P代码</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> vlfeat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>visual-studio-2013编译64位boost</title>
      <link href="/2016/11/09/visual-studio-2013%E7%BC%96%E8%AF%9164%E4%BD%8Dboost/"/>
      <url>/2016/11/09/visual-studio-2013%E7%BC%96%E8%AF%9164%E4%BD%8Dboost/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>windows 10</li><li>visual studio 2013 ultimate</li><li>boost 1.58</li></ol><blockquote><p>由于本人用1.61版本编译不成功，所以转战1.58版本。原因在visual studio 2013上，也许你用其他版本vs就能编译成功。</p></blockquote><a id="more"></a><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><h4 id="编译64位"><a href="#编译64位" class="headerlink" title="编译64位"></a>编译64位</h4><p>进入开始菜单visual studio tools，找到<code>VS2013 x64 本机工具命令提示</code>，双击打开。</p><blockquote><p>你会发现这就是一个cmd，而编译boost不是随便打开一个cmd就行的。编译64位需要打开这个cmd，而编译32位的需要打开<code>VS2013 x86 本机工具命令提示</code>这个cmd。</p></blockquote><p>切换到你的boost根目录，例如我的在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\local\boost_1_58_0</span><br></pre></td></tr></table></figure><p>至此，你会发现在此路径下存在bootstrap.bat，在windows环境中只需运行<code>call bootstrap.bat</code>就会生成64位的<code>b2.exe</code>和<code>bjam.exe</code>。</p><p>接下来就是利用<code>bjam.exe</code>来编译。</p><p>如果需要获取动态库，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 threading=multi link=shared address-model=64</span><br></pre></td></tr></table></figure><p>以上是生成全部的lib，如果只生成需要的库，例如date_time，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --with-date_time toolset=msvc-12.0 threading=multi link=static address-model=64</span><br></pre></td></tr></table></figure><p>要有<code>address-model=64</code>属性，如果没有这个属性，会默认生成32位的平台库，加入这个选项才能生成64位的DLL。</p><p>如果需要获取静态库，编译命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 threading=multi link=static address-model=64</span><br></pre></td></tr></table></figure><p>你会发现，这就是将link属性变为static。</p><p>也可以指定生成库的文件目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bjam --build-type=complete toolset=msvc-9.0 --stagedir=<span class="string">"C:\boostLib"</span> threading=multi link=shared address-model=64</span><br></pre></td></tr></table></figure><h4 id="编译32位"><a href="#编译32位" class="headerlink" title="编译32位"></a>编译32位</h4><p>编译32位库只需要将cmd换为<code>VS2013 x86 本机工具命令提示</code>然后和64位进行相同操作。</p><h3 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h3><p>打开visual studio，创建工程。</p><p>编辑属性，打开<code>配置属性 &gt; VC++目录</code>，配置<code>包含目录</code>和<code>库目录</code>，接着打开<code>配置属性 &gt; 链接器 &gt; 输入</code>，在<code>附加依赖项</code>中添加lib。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libboost_chrono-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_system-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_thread-vc120-mt-gd-1_58.lib</span><br><span class="line">libboost_date_time-vc120-mt-gd-1_58.lib</span><br></pre></td></tr></table></figure><blockquote><p>我是编译的静态库，所以只需要在此添加所需的lib就可以了。如果生成的是动态库，还需要将dll所在的路径添加到系统路径path属性中，==重启==电脑使路径生效。</p></blockquote><p>将visual studio的编译器换成x64。</p><p>至此，可以说环境配置完成，可以贴上测试代码运行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/condition.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/mutex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bounded_buffer</span> :</span> <span class="keyword">private</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> boost::mutex::scoped_lock lock;</span><br><span class="line">bounded_buffer(<span class="keyword">int</span> n) : begin(<span class="number">0</span>), end(<span class="number">0</span>), buffered(<span class="number">0</span>), circular_buf(n) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="function">lock <span class="title">lk</span><span class="params">(monitor)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (buffered == circular_buf.size())</span><br><span class="line">buffer_not_full.wait(lk);</span><br><span class="line">circular_buf[end] = m;</span><br><span class="line">end = (end + <span class="number">1</span>) % circular_buf.size();</span><br><span class="line">++buffered;</span><br><span class="line">buffer_not_empty.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">lock <span class="title">lk</span><span class="params">(monitor)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (buffered == <span class="number">0</span>)</span><br><span class="line">buffer_not_empty.wait(lk);</span><br><span class="line"><span class="keyword">int</span> i = circular_buf[begin];</span><br><span class="line">begin = (begin + <span class="number">1</span>) % circular_buf.size();</span><br><span class="line">--buffered;</span><br><span class="line">buffer_not_full.notify_one();</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> begin, end, buffered;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; circular_buf;</span><br><span class="line">boost::condition buffer_not_full, buffer_not_empty;</span><br><span class="line">boost::mutex monitor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bounded_buffer <span class="title">buf</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">buf.send(n);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sent: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">buf.send(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">n = buf.receive();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"received: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">-1</span>); <span class="comment">// -1 indicates end of buffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">boost::<span class="function">thread <span class="title">thrd1</span><span class="params">(&amp;sender)</span></span>;</span><br><span class="line">boost::<span class="function">thread <span class="title">thrd2</span><span class="params">(&amp;receiver)</span></span>;</span><br><span class="line">thrd1.join();</span><br><span class="line">thrd2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://www.cnblogs.com/codingmylife/archive/2012/11/05/2754778.html" target="_blank" rel="noopener">编译64位boost</a></li><li><a href="http://blog.csdn.net/zhaoya_huangqing/article/details/47318479" target="_blank" rel="noopener">新手，Visual Studio 2013 配置Boost库。 如何编译和选择，遇到无法打开文件“libboost_thread-vc120-mt-gd-1_58.lib的解决办法</a></li><li><a href="http://www.boost.org/" target="_blank" rel="noopener">boost官网</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> boost </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git本地文件夹上传至github</title>
      <link href="/2016/11/09/git%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E8%87%B3github/"/>
      <url>/2016/11/09/git%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E8%87%B3github/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>本文初衷是想将本地部分文件夹推送到github进行保存共享，折腾一番终于有所斩获，在此笔记以备后来参考。</p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ol><li>windows 10</li><li><a href="https://git-scm.com/download" target="_blank" rel="noopener">git bash</a></li></ol><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>安装完git bash之后，就可以在git bash内进行各种操作。</p><p>右键Git Bash Here，你就会发现出现类似于linux的对话框，在这里你可以完全用linux指令来完成各种操作。</p><blockquote><p>本文已经假设你已经安装好git bash，并且完成本地与远程账户的关联，如果还没有完成请右转google。</p></blockquote><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>假设我的根路径在D盘，右键<code>Git Bash Here</code>。在其中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir abc</span><br><span class="line"><span class="built_in">cd</span> abc</span><br><span class="line">git init <span class="comment">#这是用来初始化文件夹git</span></span><br></pre></td></tr></table></figure><p>此时你会发现在<code>D:/abc/</code>下出现<code>.git</code>文件夹，这是用来与github关联的。</p><h3 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir</span><br><span class="line">touch aaa</span><br><span class="line">touch dir/aaa</span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure><h3 id="添加远程Git"><a href="#添加远程Git" class="headerlink" title="添加远程Git"></a>添加远程Git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/maxiaoyuelun/abc.git</span><br></pre></td></tr></table></figure><blockquote><p>假设你已经创建好远程名叫<code>abc</code>的仓库了，并且假设你在仓库你添加了<code>README.md</code>文件。</p></blockquote><h3 id="远程与本地合并"><a href="#远程与本地合并" class="headerlink" title="远程与本地合并"></a>远程与本地合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'merge'</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>至此你会在本地文件夹下发现多了<code>README.md</code>文件。</p><h3 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'upload'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>在浏览器中打开就可以看到已经将本地文件夹内的内容上传至github中了。</p><blockquote><p>在进行<code>push</code>和<code>pull</code>之前，必须进行commit，否则会有error。</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm aaa</span><br><span class="line">git status</span><br><span class="line">git commit -m <span class="string">'del aaa'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>其他对于文件的操作可在参考文献中寻找。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://git.oschina.net/progit/index.html" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://www.yiibai.com/git/home.html" target="_blank" rel="noopener">Git教程</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/14/Git-Bash不能输入中文解决办法/">Git Bash不能输入中文解决办法</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li><li><a href="http://gubangzhong.cn/2017/07/13/批处理git命令/">批处理git命令</a></li><li><a href="https://loremwalker.github.io/note/2018/02-26/bafc086b.html">Hexo备份并推送到Github</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel5.1开发博客系列一</title>
      <link href="/2016/11/09/Laravel5-1%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>/2016/11/09/Laravel5-1%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p><code>WampServer</code>、<code>PHPStorm</code>、浏览器</p><h2 id="开发前设置"><a href="#开发前设置" class="headerlink" title="开发前设置"></a>开发前设置</h2><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改<code>hosts</code>文件</h3><p>打开“我的电脑”，进入 <code>C:\Windows\System32\drivers\etc</code> 目录，然后打开 <code>hosts</code> 文件，在最下面添加一行代码：<code>127.0.0.1 maxiaoyuelun.cn</code>，之后保存退出（可能需要管理员权限）。</p><a id="more"></a><h3 id="启用WampServer虚拟域名功能"><a href="#启用WampServer虚拟域名功能" class="headerlink" title="启用WampServer虚拟域名功能"></a>启用<code>WampServer</code>虚拟域名功能</h3><p>进入 <code>C:\wamp\bin\apache\apache2.4.9\conf</code> 目录，打开<code>apache</code>配置文件 <code>httpd.conf</code> ，在里面搜索 <code>httpd-vhosts.conf</code> ，会找到下面这样一行：<br><code>#Include conf/extra/httpd-vhosts.conf</code><br>把最前面的 <code>#</code> 去掉（没有 <code>#</code> 的话直接进行下一步），保存并退出。</p><h3 id="添加虚拟域名"><a href="#添加虚拟域名" class="headerlink" title="添加虚拟域名"></a>添加虚拟域名</h3><p>进入 <code>C:\wamp\bin\apache\apache2.4.9\conf\extra</code> 目录，打开 <code>httpd-vhosts.conf</code>文件，添加下面的代码：</p><pre><code>&lt;VirtualHost *:80&gt;    ServerAdmin webmaster@laravel.dev    DocumentRoot &quot;d:/wamp/www/laravel5/public&quot;    ServerName laravel.dev    ErrorLog &quot;logs/laravel.dev-error.log&quot;    CustomLog &quot;logs/laravel.dev-access.log&quot; common&lt;/VirtualHost&gt;</code></pre><p>至此，已经启用虚拟域名并添加好了虚拟域名，重启apache服务，在浏览器输入<code>http://laravel.dev/</code>，可以看到已经可以正常访问本地的<code>Laravel 5</code>了。</p><h2 id="开发必要资源"><a href="#开发必要资源" class="headerlink" title="开发必要资源"></a>开发必要资源</h2><h3 id="添加make-view"><a href="#添加make-view" class="headerlink" title="添加make:view"></a>添加<code>make:view</code></h3><p>参考<a href="https://github.com/svenluijten/artisan-view" target="_blank" rel="noopener"><code>artisan-view</code></a>进行添加</p><h3 id="添加AdminLTE"><a href="#添加AdminLTE" class="headerlink" title="添加AdminLTE"></a>添加<code>AdminLTE</code></h3><p>在此之前需安装好bower<br>进入<code>C:\wamp\www\Laravel\public</code>目录中，右击运行<code>Use Composer Here</code>，添加如下代码：<br><code>bower install admin-lte</code><br>参考文献：<a href="https://almsaeedstudio.com/blog/integrate-adminlte-with-laravel" target="_blank" rel="noopener"><code>Integrate AdminLTE with Laravel 5</code></a></p><p>至此，初步准备阶段完成。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2017/03/28/上传本地博客源码到git服务器/">上传本地博客源码到git服务器</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫抓取大伟吉他谱</title>
      <link href="/2016/11/09/Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%A4%A7%E4%BC%9F%E5%90%89%E4%BB%96%E8%B0%B1/"/>
      <url>/2016/11/09/Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%A4%A7%E4%BC%9F%E5%90%89%E4%BB%96%E8%B0%B1/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>喜欢用最近开始，最近由于个人需要，利用爬虫爬了一些东西，不得不说python是一大利器，只要你熟练之后，就可以随意创造你想要的大部分东西。插播点牢骚话，最近看网上的某些言论，实在是不敢苟同，说到创新，就似乎要打碎一切东西，从头再来，我所理解的创新是站在别人的基础上再做出自己的东西。首先，就需要对自己的领域熟悉，然后基于特定的需要，借用某种技术来实现目的。实际上，大部分的创新都是基于某种应用需求，当然前瞻性的理论创新也很重要，这里说的不是简单的一元论。</p></blockquote><p>这篇博文是用python来爬取<a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">大伟吉他教室</a>谱子的例程，在此笔记，加深印象。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>windows 10，pycharm，anaconda，scrapy，google chrome</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文因为有特定的爬取目的，所以在很多步骤上就有了简化的处理。在开始前，需要利用chrome浏览器的调试功能找到需要爬取内容的位置：就是xpath位置，然后再进行编码测试。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><pre><code>scrapy startproject tutorial</code></pre><h4 id="创建spider"><a href="#创建spider" class="headerlink" title="创建spider"></a>创建spider</h4><pre><code>scrapy genspider guitar guitar.com</code></pre><h4 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h4><p>上面两部就创建了guitar.py文件。</p><p>打开guitar.py文件，所示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuitarSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"guitar"</span></span><br><span class="line">    allowed_domains = [<span class="string">"guitar.com"</span>]</span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">'http://www.guitar.com/'</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>添加代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuitarSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"guitar"</span></span><br><span class="line">    allowed_domains = [<span class="string">"guitar.com"</span>]</span><br><span class="line">    start_urls = (</span><br><span class="line">        <span class="string">'http://www.daweijita.com/59492.html'</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================2=================="</span></span><br><span class="line">        <span class="keyword">print</span> response.headers</span><br><span class="line">        <span class="keyword">for</span> sel1 <span class="keyword">in</span> response.xpath(<span class="string">'//*[@id="main-content"]/div[2]/div[2]/div/div[1]'</span>):</span><br><span class="line">            <span class="keyword">for</span> sel <span class="keyword">in</span> sel1.xpath(<span class="string">'.//a/@href'</span>).re(<span class="string">r'.*.gif$'</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"===="</span></span><br><span class="line">                <span class="keyword">print</span> sel</span><br><span class="line">                <span class="keyword">print</span> re.match(<span class="string">r'.*fufei.*'</span>,sel)</span><br><span class="line">                <span class="keyword">if</span> re.match(<span class="string">r'.*fufei.*'</span>,sel) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"$$$$$$$$$$$$$$$$$$$$$"</span></span><br><span class="line">                    s=sel.split(<span class="string">'/'</span>)</span><br><span class="line">                    s2=s[<span class="number">-1</span>].split(<span class="string">'_'</span>)</span><br><span class="line">                    <span class="keyword">print</span> s2</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">                        s3=<span class="string">u'tab_'</span>+s2[<span class="number">1</span>]+<span class="string">u'_'</span>+s2[<span class="number">2</span>]+<span class="string">u'_'</span>+<span class="string">u'%d'</span> % num +<span class="string">u'.gif'</span></span><br><span class="line">                        <span class="keyword">print</span> s3</span><br><span class="line">                        s4=s[:<span class="number">-1</span>]+[s3]</span><br><span class="line">                        <span class="keyword">print</span> s4</span><br><span class="line">                        s5=s4[<span class="number">0</span>]+<span class="string">u'//'</span>+s4[<span class="number">2</span>]+<span class="string">u'/'</span>+s4[<span class="number">3</span>]+<span class="string">u'/'</span>+s4[<span class="number">4</span>]+<span class="string">u'/'</span>+s4[<span class="number">5</span>]</span><br><span class="line">                        local_filename = s3 </span><br><span class="line">                        r = requests.get(s5, stream=<span class="keyword">True</span>) </span><br><span class="line">                        <span class="keyword">print</span> r.status_code</span><br><span class="line">                        <span class="keyword">if</span> r.status_code==<span class="number">200</span>:</span><br><span class="line">                            <span class="keyword">with</span> open(local_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                                <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):  </span><br><span class="line">                                    <span class="keyword">if</span> chunk: <span class="comment"># filter out keep-alive new chunks  </span></span><br><span class="line">                                        f.write(chunk)  </span><br><span class="line">                                        f.flush() </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    local_filename = sel.split(<span class="string">'/'</span>)[<span class="number">-1</span>]  </span><br><span class="line">                    r = requests.get(sel, stream=<span class="keyword">True</span>) </span><br><span class="line">                    <span class="keyword">with</span> open(local_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  </span><br><span class="line">                        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span>):  </span><br><span class="line">                            <span class="keyword">if</span> chunk: <span class="comment"># filter out keep-alive new chunks  </span></span><br><span class="line">                                f.write(chunk)  </span><br><span class="line">                                f.flush()  </span><br><span class="line">               </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"===="</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================2=================="</span></span><br></pre></td></tr></table></figure><p>在此就算简单完成了爬取工作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>多次测试之后，其实可以发现，该网站中的图片都是以这样的形式命名：</p><pre><code>tab_演唱者_歌曲名_数字.gif</code></pre><p>也就是说，修改上面代码中的start_urls，定位到需要爬取的网站，可以爬取大部分的歌曲，但是如果碰到部分不一样的格式，则需要自己手动调试。</p><p>那么可以先定位到<a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">全站教学资源列表</a>爬取歌曲以及演唱者，根据中英文适当转化为拼音，记录到items中保存，然后可以提取items中的信息进行组合来爬取所有曲谱，这在下面的文章中会完善。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">python菜鸟教程</a></li><li><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html" target="_blank" rel="noopener">scrapy中文文档</a></li><li><a href="http://www.daweijita.com/2441.html" target="_blank" rel="noopener">大伟吉他教室</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/Django安装指北/">Django安装指北</a></li><li><a href="http://gubangzhong.cn/2017/06/11/Windows10安装多版本Python/">Windows10安装多版本Python</a></li><li><a href="http://gubangzhong.cn/2017/11/23/在python下利用opencv读取图片/">在python下利用opencv读取图片</a></li><li><a href="http://www.davidfnck.com/python/python-tutorial-01-install.html/">Python 安装指南</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Protobuf安装使用指南</title>
      <link href="/2016/11/09/Protobuf%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2016/11/09/Protobuf%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><ol><li><a href="https://github.com/google/protobuf/" target="_blank" rel="noopener">https://github.com/google/protobuf/</a></li></ol><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ol><li>Windows 10 企业版 64 位（10.0，版本14393）</li><li>Visual Studio 2013</li><li>Git-2.10.1-64-bit.exe</li><li>cmake-3.6.2-win64-x64.msi</li></ol><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>在官网下载protubuf，我将其下载解压到<code>D:\Science\Google</code>下</p><h4 id="创建和编译"><a href="#创建和编译" class="headerlink" title="创建和编译"></a>创建和编译</h4><p>在开始菜单找到<code>Visual Studio Tools</code>，点击。</p><p>在出现的文件中，双击<code>VS2013 x64 本机工具命令提示</code>。</p><p>切换路径到<code>D:\Science\Google</code>下。</p><blockquote><p>在windows下切换路径直接使用<code>D:</code>回车即可，不需要<code>cd</code>命令。</p></blockquote><p>之后按照教程 <a href="https://github.com/google/protobuf/blob/master/cmake/README.md" target="_blank" rel="noopener">https://github.com/google/protobuf/blob/master/cmake/README.md</a> 输入如下指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> protobuf-master</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b release-1.7.0 https://github.com/google/googlemock.git gmock</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> gmoke</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b release-1.7.0 https://github.com/google/googletest.git gtest</span><br></pre></td></tr></table></figure><p>至此，安装成功<code>gmoke</code>。</p><p>下面进行编译，输入如下指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> cmake</span><br><span class="line"></span><br><span class="line">mkdir build &amp; <span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">mkdir solution &amp; <span class="built_in">cd</span> solution</span><br><span class="line"></span><br><span class="line">cmake -G <span class="string">"Visual Studio 12 2013 Win64"</span> ^</span><br><span class="line"> -DCMAKE_INSTALL_PREFIX=../../../../install ^</span><br><span class="line"> ../..</span><br></pre></td></tr></table></figure><p>将会在solution文件夹下创建<code>protobuf.sln</code>。</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>双击打开<code>protobuf.sln</code>。</p><p>在<code>生成</code>工具下打开<code>批生成</code>，选中<code>INSTALL Debug</code>，关闭选项卡。</p><p>之后生成解决方案，静待几分钟之后，生成成功，发现在<code>D:\Science\Google\install</code>下出现需要的bin、include、lib等文件夹。</p><blockquote><p>Release生成同理。</p></blockquote><p>至此，install文件夹如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├─bin</span><br><span class="line">├─cmake</span><br><span class="line">├─include</span><br><span class="line">│  └─google</span><br><span class="line">│      └─protobuf</span><br><span class="line">│          ├─compiler</span><br><span class="line">│          │  ├─cpp</span><br><span class="line">│          │  ├─csharp</span><br><span class="line">│          │  ├─java</span><br><span class="line">│          │  ├─javanano</span><br><span class="line">│          │  ├─js</span><br><span class="line">│          │  ├─objectivec</span><br><span class="line">│          │  ├─php</span><br><span class="line">│          │  ├─python</span><br><span class="line">│          │  └─ruby</span><br><span class="line">│          ├─io</span><br><span class="line">│          ├─stubs</span><br><span class="line">│          └─util</span><br><span class="line">└─lib</span><br></pre></td></tr></table></figure><blockquote><p>上面的树状是用命令<code>tree</code>生成。</p></blockquote><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p>在此初步试用protobuf。</p><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/</a> 中给出了使用指南。</p><p>本文简单给出一个例子，具体使用请查看手册。</p><p>为简单起见，在<code>D:\Science\Google\install\bin</code>下创建person.proto文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package Im;</span><br><span class="line">message helloworld</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    requiredint32  id=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    requiredstring  str=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    optionalint32  opt=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>protoc.exe</code>生成<code>.h</code>和<code>.cc</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=D:\Science\Google\install\bin person.proto</span><br></pre></td></tr></table></figure><p>即在<code>D:\Science\Google\install\bin</code>文件夹下生成person.pb.h和person.pb.cc文件。</p><p>打开visual studio 2013，创建空项目Person_。</p><p>新建main.cpp。在其中输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.pb.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lm::helloworld msg1;</span><br><span class="line">    msg1.set_id(<span class="number">100</span>);</span><br><span class="line">    msg1.set_str(<span class="string">"200"</span>);</span><br><span class="line">    msg1.set_opt(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg1.opt() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将person.pb.h和person.pb.cc文件拷贝到和main.cpp同样的路径下，并将这两个文件添加到工程中。</p><p>之后需要打开工程属性选项卡。</p><p>选择<code>VC++目录</code>。在<code>包含目录</code>中添加D:\Science\Google\install\include，在<code>库目录</code>中添加D:\Science\Google\install\lib。</p><p>选择<code>链接器&gt;输入</code>。在<code>附加依赖项</code>中添加libprotobufd.lib、libprotobuf-lited.lib、libprotocd.lib。</p><p>选择<code>C/C++&gt;代码生成</code>。将<code>运行库</code>中的多线程调试DLL(/MDd)替换为多线程调试(/MTd)。</p><p>至此可以编译生成。</p><p>如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p>至此，整个安装教程结束。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li><li><a href="http://gubangzhong.cn/2017/07/13/glog初步体验/">glog初步体验</a></li><li><a href="http://gubangzhong.cn/2017/07/13/protobuf生成cplusplus代码详解/">protobuf生成c++代码详解(初稿)</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++输出到txt日志</title>
      <link href="/2016/11/09/C++%E8%BE%93%E5%87%BA%E5%88%B0txt%E6%97%A5%E5%BF%97/"/>
      <url>/2016/11/09/C++%E8%BE%93%E5%87%BA%E5%88%B0txt%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="关于C-中使用fstream输出到文件中的部分操作"><a href="#关于C-中使用fstream输出到文件中的部分操作" class="headerlink" title="关于C++中使用fstream输出到文件中的部分操作"></a>关于C++中使用<code>fstream</code>输出到文件中的部分操作</h3><blockquote><p>在编写程序的时候，常常需要将日志输出到类似txt的文件中，这时需要自己编写相关的代码。当用搜索引擎在网上进行搜索时，大多数给予的是有关C的代码，而对于C++的今天，何不用C++来简单实现这些功能呢？作为时代的进步，简化也就意味着高效。这以我在项目中的部分类似代码作为展示，请各位不吝赐教！抱拳！(用引用作为前言是不是不太好…)</p></blockquote><a id="more"></a><p>工具： Visual Studio 2013</p><p>通常都会在工程中加入头文件<code>#include</code></p><p>在这里是将日志输出到txt文件中。</p><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><ul><li>这是将数字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><ul><li>这是将文字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><ul><li>这是将文字和数字输出到txt文件中，可供各位看官复制粘贴。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteToTxt</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="string">"="</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>鉴于以上组合，相信各位看官了解了如何利用C++进行文字的输出，输入请待下回分解。</p></blockquote><h3 id="关于C-中使用SYSTEMTIME获取当前时间的部分操作"><a href="#关于C-中使用SYSTEMTIME获取当前时间的部分操作" class="headerlink" title="关于C++中使用SYSTEMTIME获取当前时间的部分操作"></a>关于C++中使用<code>SYSTEMTIME</code>获取当前时间的部分操作</h3><blockquote><p>在输出日志的时候，通常需要记录日志输出的发生时间，这就需要程序员自己调用内置函数。也许看官看到这已经发现这是有关调试的文章。好吧！我承认了！调试是软件开发过程中不可或缺的步骤，很重要！</p></blockquote><p>工具： Visual Studio 2013</p><p>通常都会在工程中加入头文件<code>#include</code></p><p>在这里是将时间输出到txt文件中。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>这里只是简单实现，需要更好的看官可自行设计。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SYSTEMTIME sys;</span><br><span class="line">    GetLocalTime(&amp;sys);</span><br><span class="line">    ofstream outfile;</span><br><span class="line">    outfile.open(<span class="string">"D:\\log.txt"</span>, ios_base::app);</span><br><span class="line">    <span class="keyword">if</span> (outfile.is_open())&#123;</span><br><span class="line">        outfile &lt;&lt; sys.wYear &lt;&lt; <span class="string">"/"</span> &lt;&lt; sys.wMonth &lt;&lt; <span class="string">"/"</span> &lt;&lt; sys.wDay &lt;&lt; <span class="string">" "</span> &lt;&lt; sys.wHour &lt;&lt; <span class="string">"："</span> &lt;&lt; sys.wMinute &lt;&lt; <span class="string">"："</span> &lt;&lt; sys.wSecond &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能打开文件"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，本节基本结束了，至于函数中各个参数什么意思，相信搜索引擎会帮你的忙的。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/CUDA均值滤波/">CUDA均值滤波</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CUDA均值滤波</title>
      <link href="/2016/11/09/CUDA%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/2016/11/09/CUDA%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>cuda进行均值滤波，主要blockIdx、blockDim、threadIdx等知识点。</p></blockquote><a id="more"></a><h4 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//时间相关头文件，可用其中函数计算图像处理速度  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> datasize 80000</span></span><br></pre></td></tr></table></figure><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">runtest_img</span><span class="params">(<span class="keyword">int</span>* host_a, <span class="keyword">int</span>* host_b, <span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello OpenCV CUDA"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Mat img = imread(<span class="string">"me.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (img.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No \"me.jpg\""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat gray_img;</span><br><span class="line"></span><br><span class="line">cvtColor(img, gray_img, CV_RGB2GRAY);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Gray Image"</span>, gray_img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = gray_img.rows;</span><br><span class="line"><span class="keyword">int</span> cols = gray_img.cols;</span><br><span class="line"><span class="keyword">int</span> channels = gray_img.channels();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rows : "</span> &lt;&lt; rows &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cols : "</span> &lt;&lt; cols &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"channels : "</span> &lt;&lt; channels &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* host_img = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line"><span class="keyword">int</span>* host_output_img = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">uchar* data = gray_img.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols ; j++)&#123;</span><br><span class="line">host_img[i*cols+j] = data[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; host_img[(rows - <span class="number">1</span>)*cols + cols - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">long</span> now1 = clock();<span class="comment">//存储图像处理开始时间   </span></span><br><span class="line">runtest_img(host_img, host_output_img, rows, cols);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"GPU运行时间为：%dms\n"</span>, <span class="keyword">int</span>(((<span class="keyword">double</span>)(clock() - now1)) / CLOCKS_PER_SEC * <span class="number">1000</span>));<span class="comment">//输出GPU处理时间  </span></span><br><span class="line">Mat mean_filter_img(Size(cols, rows), CV_8U);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">uchar* data = mean_filter_img.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">data[j]=host_output_img[i*cols + j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">"Mean Filter Image"</span>, mean_filter_img);</span><br><span class="line"></span><br><span class="line">cvWaitKey();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kernel-cu"><a href="#kernel-cu" class="headerlink" title="kernel.cu"></a>kernel.cu</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">checkCudaErrors</span><span class="params">(cudaError err)</span><span class="comment">//错误处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cudaSuccess != err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"CUDA Runtime API error: %s.\n"</span>, cudaGetErrorString(err));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">meanFilter</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> h,<span class="keyword">int</span> w)</span><span class="comment">//处理核函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tid = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nx = blockIdx.x;</span><br><span class="line"><span class="keyword">int</span> ny = threadIdx.x;</span><br><span class="line"><span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; nx &lt; h<span class="number">-1</span> &amp;&amp; ny&gt;<span class="number">0</span> &amp;&amp; ny &lt; w<span class="number">-1</span>)&#123;</span><br><span class="line">b[tid] = <span class="keyword">int</span>((a[(blockIdx.x - <span class="number">1</span>)*blockDim.x + threadIdx.x - <span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x - <span class="number">1</span>)*blockDim.x + threadIdx.x +<span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x +<span class="number">1</span>)*blockDim.x + threadIdx.x - <span class="number">1</span>] +</span><br><span class="line">a[(blockIdx.x +<span class="number">1</span>)*blockDim.x + threadIdx.x + <span class="number">1</span>]) / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b[tid] = a[tid];</span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">runtest_img</span><span class="params">(<span class="keyword">int</span>* host_a, <span class="keyword">int</span>* host_b, <span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">cudaDeviceProp prop;</span><br><span class="line">checkCudaErrors(cudaGetDeviceCount(&amp;num));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">cudaGetDeviceProperties(&amp;prop, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dev_a, *dev_b; </span><br><span class="line"><span class="comment">//int *dev_h, *dev_w;</span></span><br><span class="line">checkCudaErrors(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w));<span class="comment">//分配显卡内存</span></span><br><span class="line">checkCudaErrors(cudaMalloc((<span class="keyword">void</span>**)&amp;dev_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w));</span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMalloc((void**)&amp;dev_h, sizeof(int)));//分配显卡内存</span></span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMalloc((void**)&amp;dev_w, sizeof(int)));</span></span><br><span class="line"></span><br><span class="line">checkCudaErrors(cudaMemcpy(dev_a, host_a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyHostToDevice));<span class="comment">//将主机待处理数据内存块复制到显卡内存中</span></span><br><span class="line">checkCudaErrors(cudaMemcpy(dev_b, host_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyHostToDevice));</span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMemcpy(dev_h, &amp;h, sizeof(int), cudaMemcpyHostToDevice));//将主机待处理数据内存块复制到显卡内存中</span></span><br><span class="line"><span class="comment">//checkCudaErrors(cudaMemcpy(dev_w, &amp;w, sizeof(int), cudaMemcpyHostToDevice));</span></span><br><span class="line"></span><br><span class="line">meanFilter &lt;&lt;&lt;h, w &gt;&gt;&gt;(dev_a, dev_b, h,w);<span class="comment">//调用显卡处理数据</span></span><br><span class="line">checkCudaErrors(cudaMemcpy(host_b, dev_b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* h*w, cudaMemcpyDeviceToHost));<span class="comment">//将显卡处理完数据拷回来</span></span><br><span class="line"></span><br><span class="line">cudaFree(dev_a);<span class="comment">//清理显卡内存</span></span><br><span class="line">cudaFree(dev_b);</span><br><span class="line"><span class="comment">/*cudaFree(dev_h);</span></span><br><span class="line"><span class="comment">cudaFree(dev_w);*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/09/C++输出到txt日志/">C++输出到txt日志</a></li><li><a href="http://gubangzhong.cn/2016/11/09/visual-studio-2013编译64位boost/">visual-studio-2013编译64位boost</a></li><li><a href="http://gubangzhong.cn/2017/07/07/类之虚函数纯虚函数和普通函数/">类之虚函数,纯虚函数和普通函数</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
            <tag> cuda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo静态站点搭建</title>
      <link href="/2016/11/09/Hexo%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%90%AD%E5%BB%BA/"/>
      <url>/2016/11/09/Hexo%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Windows，Notepad++，Node</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ol><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ol><p>如果您的电脑中尚未安装所需要的程序，请自行安装。</p><a id="more"></a><p>其次需要创建Github Pages。至于如何创建，可自行谷歌，如博主有时间再更。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用Git Bash输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml #网站配置信息，您可以在此配置大部分的参数。</span><br><span class="line">├── package.json    #应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</span><br><span class="line">├── scaffolds   #模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">├── source  #资源文件夹是存放用户资源的地方。</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes  #主题 文件夹。Hexo 会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure><h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p><p>在终端窗口下，定位到 Hexo 站点目录themes下。使用 Git Bash代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h4><p>hexo自带服务器，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>即可在浏览器中查看。</p><h2 id="Hexo部署Git命令"><a href="#Hexo部署Git命令" class="headerlink" title="Hexo部署Git命令"></a>Hexo部署Git命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>其余部分可参考给出的参考文献，至于在Github Pages中使用自己的域名，需要在Repository中部署CNAME文件。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo快速、简洁且高效的博客框架</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next精于心，简于形</a></p><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">hexo你的博客</a></p><p><a href="http://www.zhihu.com/question/20463581" target="_blank" rel="noopener">知乎：如何搭建个人独立博客？</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2017/03/28/hexo插件收集/">hexo插件收集</a></li><li><a href="http://gubangzhong.cn/2018/04/16/next豆瓣插件/">next豆瓣插件</a></li><li><a href="http://gubangzhong.cn/2018/04/16/hexo文章推荐/">hexo文章推荐</a></li><li><a href="http://www.davidfnck.com/blockchain/mine-xmr-in-hexo-by-coinhive.html/">区块链时代的最正确的打赏姿势——在Hexo博客配置Coinhive网页挖矿</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>matlab坐标系疑云</title>
      <link href="/2015/12/20/matlab%E5%9D%90%E6%A0%87%E7%B3%BB%E7%96%91%E4%BA%91/"/>
      <url>/2015/12/20/matlab%E5%9D%90%E6%A0%87%E7%B3%BB%E7%96%91%E4%BA%91/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote><p>编程中总会被matlab的奇怪坐标系坐标搞晕，在此笔记。</p></blockquote><a id="more"></a><p><img src="http://wx1.sinaimg.cn/mw690/005IKUsQly1fmn5rn6v4xj307y07pwea.jpg" alt=""></p><p>如上图所示，即是matlab图像格式，假设图像用<code>I</code>表示，那么在<code>x</code>轴100和<code>y</code>轴50处，读取图像的像素为<code>I(50,100)</code>，此即为matlab的坐标系格式。一般在figure中点击某点显示像素坐标，显示的是<code>x</code>轴和<code>y</code>轴的坐标，但是编写代码的时候就要反过来，注意注意。</p><p>另外，matlab的坐标系是从<code>1</code>开始的，而不是从<code>0</code>开始。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="http://gubangzhong.cn/2016/11/10/MatConvNet安装指北/">MatConvNet安装指北</a></li><li><a href="http://gubangzhong.cn/2017/07/17/Matlab常用函数及技巧/">Matlab常用函数及技巧</a></li><li><a href="http://gubangzhong.cn/2016/11/10/Vlfeat编译指北/">Vlfeat编译指北</a></li></ul></div>]]></content>
      
      <categories>
          
          <category> 技术堆栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2015/01/01/hello-world/"/>
      <url>/2015/01/01/hello-world/</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
